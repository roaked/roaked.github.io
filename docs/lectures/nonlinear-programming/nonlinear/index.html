<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Notes on Nonlinear Programming
  #


  
    
      
        
      tip
    
from classes of OD


  


  Problem Setup
  #


nonlinear programming (NLP) optimizes a nonlinear objective, with optional nonlinear constraints:





  \[\min_{x \in \mathbb{R}^n} f(x)\]



  \[\text{s.t. } g_i(x) \le 0,\; i=1,\dots,m, \qquad h_j(x)=0,\; j=1,\dots,p\]



core challenge:

objective geometry can be curved and nonconvex
constraints can define complex feasible regions
local minima can differ strongly from global minima




  Lagrangian and KKT Conditions
  #


define Lagrangian:


  \[\mathcal{L}(x,\lambda,\nu)=f(x)+\sum_{i=1}^{m}\lambda_i g_i(x)+\sum_{j=1}^{p}\nu_j h_j(x)\]



first-order necessary conditions (under regularity assumptions):

stationarity:

  \[\nabla_x \mathcal{L}(x^\star,\lambda^\star,\nu^\star)=0\]


primal feasibility:

  \[g_i(x^\star)\le0,\quad h_j(x^\star)=0\]


dual feasibility:

  \[\lambda_i^\star \ge 0\]


complementary slackness:

  \[\lambda_i^\star g_i(x^\star)=0\]






  
    
      
        
      important"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://xsleaks.dev/docs/lectures/nonlinear-programming/nonlinear/"><meta property="og:site_name" content="Ricardo Chin"><meta property="og:title" content="Nonlinear Programming"><meta property="og:description" content="Notes on Nonlinear Programming # tip
from classes of OD Problem Setup # nonlinear programming (NLP) optimizes a nonlinear objective, with optional nonlinear constraints: \[\min_{x \in \mathbb{R}^n} f(x)\] \[\text{s.t. } g_i(x) \le 0,\; i=1,\dots,m, \qquad h_j(x)=0,\; j=1,\dots,p\] core challenge: objective geometry can be curved and nonconvex constraints can define complex feasible regions local minima can differ strongly from global minima Lagrangian and KKT Conditions # define Lagrangian: \[\mathcal{L}(x,\lambda,\nu)=f(x)+\sum_{i=1}^{m}\lambda_i g_i(x)+\sum_{j=1}^{p}\nu_j h_j(x)\] first-order necessary conditions (under regularity assumptions): stationarity: \[\nabla_x \mathcal{L}(x^\star,\lambda^\star,\nu^\star)=0\] primal feasibility: \[g_i(x^\star)\le0,\quad h_j(x^\star)=0\] dual feasibility: \[\lambda_i^\star \ge 0\] complementary slackness: \[\lambda_i^\star g_i(x^\star)=0\] important"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2026-02-26T15:40:16+01:00"><title>Nonlinear Programming | Ricardo Chin</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.b1824eea1873de6fd466b2e1d8cc26a9f8e6e7aaf317af5779752ac8f255d4c4.css integrity="sha256-sYJO6hhz3m/UZrLh2Mwmqfjm56rzF69XeXUqyPJV1MQ=" crossorigin=anonymous><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Ricardo Chin</span></a></h2><ul><li class=book-section-flat><a href=/docs/design/>Engineering Repository</a><ul><li><a href=/docs/design/fea-beam-simulation/>FEA Beam Instability Modes</a><ul></ul></li><li><a href=/docs/design/finite-element-method-development/>FEM Package Development</a><ul></ul></li></ul></li><li class=book-section-flat><a href=/docs/code/>System Repository</a><ul><li><a href=/docs/code/agv/>AGV: Stochastic Identification</a><ul></ul></li><li><a href=/docs/code/uav/>UAV: Red Bull Air Racing</a><ul><li><a href=/docs/code/uav/dynamics/>Drone System Dynamics</a></li><li><a href=/docs/code/uav/continuous-controller-design/>Continuous Controller</a></li><li><a href=/docs/code/uav/discrete-controller-design/>Discrete Controller</a></li><li><a href=/docs/code/uav/computer-vision/>Gate Sense: Computer Vision</a></li></ul></li><li><a href=/docs/code/robotics/>Robotics: Kin, Dynamics & Control</a><ul></ul></li><li><a href=/docs/code/deep-learning-fake-news/>Fake News: Inference & Clusters</a><ul></ul></li><li><a href=/docs/code/bin-packing/>EC Optimization: Space & Time</a><ul><li><a href=/docs/code/bin-packing/genetic-algorithm/>Genetic Algorithm</a></li><li><a href=/docs/code/bin-packing/particle-swarm-optimization/>Particle Swarm Optimization</a></li></ul></li><li><a href=/docs/code/snake-game/>Snake: Reinforcement Learning</a><ul><li><a href=/docs/code/snake-game/deepqnetwork/>BaseRL, GA-RL & Hamiltonian</a></li><li><a href=/docs/code/snake-game/adversarial/>Adversarial Multi-Agent RL, BattleMode</a></li></ul></li></ul></li><li class=book-section-flat><a href=/docs/lectures/>My Notes and Lectures</a><ul><li><a href=/docs/lectures/bayesian-machine-learning/bayes/>Bayesian Inference</a></li><li><a href=/docs/lectures/bayesian-optimization/bayesopt/>Bayesian Optimization</a></li><li><a href=/docs/lectures/nonlinear-programming/nonlinear/ class=active>Nonlinear Programming</a></li><li><a href=/docs/lectures/hamiltonian-graphs/hamiltonian/>Hamiltonian Graphs & Linked Lists</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Nonlinear Programming</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#problem-setup><strong>Problem Setup</strong></a></li><li><a href=#lagrangian-and-kkt-conditions><strong>Lagrangian and KKT Conditions</strong></a></li><li><a href=#convex-vs-nonconvex-programs><strong>Convex vs Nonconvex Programs</strong></a></li><li><a href=#major-algorithm-families><strong>Major Algorithm Families</strong></a></li><li><a href=#line-search-and-trust-region><strong>Line Search and Trust Region</strong></a></li><li><a href=#practical-workflow><strong>Practical Workflow</strong></a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=notes-on-nonlinear-programming><strong>Notes on Nonlinear Programming</strong>
<a class=anchor href=#notes-on-nonlinear-programming>#</a></h1><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p><ul><li><strong>from classes of OD</strong></li></ul></blockquote><h3 id=problem-setup><strong>Problem Setup</strong>
<a class=anchor href=#problem-setup>#</a></h3><ul><li>nonlinear programming (NLP) optimizes a nonlinear objective, with optional nonlinear constraints:</li></ul><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><span>\[\min_{x \in \mathbb{R}^n} f(x)\]
</span><span>\[\text{s.t. } g_i(x) \le 0,\; i=1,\dots,m, \qquad h_j(x)=0,\; j=1,\dots,p\]</span><ul><li>core challenge:<ul><li>objective geometry can be curved and nonconvex</li><li>constraints can define complex feasible regions</li><li>local minima can differ strongly from global minima</li></ul></li></ul><h3 id=lagrangian-and-kkt-conditions><strong>Lagrangian and KKT Conditions</strong>
<a class=anchor href=#lagrangian-and-kkt-conditions>#</a></h3><ul><li>define Lagrangian:</li></ul><span>\[\mathcal{L}(x,\lambda,\nu)=f(x)+\sum_{i=1}^{m}\lambda_i g_i(x)+\sum_{j=1}^{p}\nu_j h_j(x)\]</span><ul><li>first-order necessary conditions (under regularity assumptions):<ol><li>stationarity:
<span>\[\nabla_x \mathcal{L}(x^\star,\lambda^\star,\nu^\star)=0\]</span></li><li>primal feasibility:
<span>\[g_i(x^\star)\le0,\quad h_j(x^\star)=0\]</span></li><li>dual feasibility:
<span>\[\lambda_i^\star \ge 0\]</span></li><li>complementary slackness:
<span>\[\lambda_i^\star g_i(x^\star)=0\]</span></li></ol></li></ul><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p><ul><li>KKT gives candidate solutions; for nonconvex NLP it does not guarantee global optimality.</li></ul></blockquote><h3 id=convex-vs-nonconvex-programs><strong>Convex vs Nonconvex Programs</strong>
<a class=anchor href=#convex-vs-nonconvex-programs>#</a></h3><ul><li><p><strong>convex program</strong>:</p><ul><li>convex objective + convex inequality constraints + affine equalities</li><li>every local optimum is global</li><li>duality is often strong and numerically stable</li></ul></li><li><p><strong>nonconvex program</strong>:</p><ul><li>may have multiple local minima/saddles</li><li>initialization strongly impacts final solution</li><li>global methods usually trade optimality guarantees for high compute cost</li></ul></li></ul><h3 id=major-algorithm-families><strong>Major Algorithm Families</strong>
<a class=anchor href=#major-algorithm-families>#</a></h3><ul><li><p><strong>gradient-based unconstrained methods</strong></p><ul><li>steepest descent: low per-step cost, slower convergence</li><li>Newton / quasi-Newton (BFGS, L-BFGS): faster near optimum using curvature</li></ul></li><li><p><strong>constrained methods</strong></p><ul><li>projected gradient: simple constraints (box, simplex)</li><li>penalty / augmented Lagrangian: move constraints into objective</li><li>interior-point (barrier): stay inside feasible region</li><li>SQP (Sequential Quadratic Programming): solve QP subproblems iteratively</li></ul></li></ul><h3 id=line-search-and-trust-region><strong>Line Search and Trust Region</strong>
<a class=anchor href=#line-search-and-trust-region>#</a></h3><ul><li>line search update:</li></ul><span>\[x_{k+1}=x_k+\alpha_k d_k\]</span><ul><li><p>choose step length <span>\(\alpha_k\)
</span>via Wolfe/Armijo conditions to ensure sufficient decrease</p></li><li><p>trust-region update solves:</p></li></ul><span>\[\min_{d} \; m_k(d) \quad \text{s.t. } \|d\| \le \Delta_k\]</span><ul><li>trust-region methods are robust when Hessians are indefinite or badly conditioned</li></ul><h3 id=practical-workflow><strong>Practical Workflow</strong>
<a class=anchor href=#practical-workflow>#</a></h3><ol><li>scale decision variables and constraints before solving</li><li>provide gradients/Jacobians/Hessians when possible</li><li>pick solver based on structure:<ul><li>unconstrained smooth: L-BFGS / Newton-CG</li><li>box constraints: L-BFGS-B</li><li>general constraints: SLSQP / trust-constr / IPOPT</li></ul></li><li>run multiple starts for nonconvex objectives</li><li>verify KKT residuals and sensitivity to initialization</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> scipy.optimize <span style=color:#f92672>import</span> minimize, NonlinearConstraint
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>f</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (x[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.5</span>)<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> (x[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>)<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> np<span style=color:#f92672>.</span>sin(<span style=color:#ae81ff>3.0</span> <span style=color:#f92672>*</span> x[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>g</span>(x):  <span style=color:#75715e># inequality g(x) &lt;= 0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> x[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1.5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x0 <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([<span style=color:#ae81ff>0.2</span>, <span style=color:#ae81ff>0.2</span>])
</span></span><span style=display:flex><span>nlc <span style=color:#f92672>=</span> NonlinearConstraint(g, <span style=color:#f92672>-</span>np<span style=color:#f92672>.</span>inf, <span style=color:#ae81ff>0.0</span>)
</span></span><span style=display:flex><span>bounds <span style=color:#f92672>=</span> [(<span style=color:#f92672>-</span><span style=color:#ae81ff>2.0</span>, <span style=color:#ae81ff>2.0</span>), (<span style=color:#f92672>-</span><span style=color:#ae81ff>2.0</span>, <span style=color:#ae81ff>2.0</span>)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>res <span style=color:#f92672>=</span> minimize(f, x0, method<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;SLSQP&#34;</span>, constraints<span style=color:#f92672>=</span>[nlc], bounds<span style=color:#f92672>=</span>bounds)
</span></span><span style=display:flex><span>print(res<span style=color:#f92672>.</span>x, res<span style=color:#f92672>.</span>fun, res<span style=color:#f92672>.</span>success)
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/roaked/roaked.github.io/commit/dc572594d4a993f11697ca0fd71f20c80c600a07 title='Last modified by roaked | February 26, 2026' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>February 26, 2026</span></a></div><div><a class="flex align-center" href=https://github.com/roaked/roaked.github.io/edit/main/content/content/docs/lectures/nonlinear-programming/nonlinear.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Ricardo Chin</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#problem-setup><strong>Problem Setup</strong></a></li><li><a href=#lagrangian-and-kkt-conditions><strong>Lagrangian and KKT Conditions</strong></a></li><li><a href=#convex-vs-nonconvex-programs><strong>Convex vs Nonconvex Programs</strong></a></li><li><a href=#major-algorithm-families><strong>Major Algorithm Families</strong></a></li><li><a href=#line-search-and-trust-region><strong>Line Search and Trust Region</strong></a></li><li><a href=#practical-workflow><strong>Practical Workflow</strong></a></li></ul></li></ul></nav></div></aside></main></body></html>