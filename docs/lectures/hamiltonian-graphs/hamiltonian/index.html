<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Hamiltonian Paths Demo in Fortran # 1 Simulation and Analysis of Graph Path Selection # Graph theory serves as a fundamental framework for modeling and understanding various systems across scientific domains. This study presents a detailed computational simulation implemented in Fortran, focusing on the manipulation, selection, and analysis of paths and individual entities within a graph. The simulation involves stepwise operations, including path creation, criteria-based selection, and the identification of Hamiltonian paths."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://xsleaks.dev/docs/lectures/hamiltonian-graphs/hamiltonian/"><meta property="og:site_name" content="Ricardo Chin"><meta property="og:title" content="Fortran: Linked Lists"><meta property="og:description" content="Hamiltonian Paths Demo in Fortran # 1 Simulation and Analysis of Graph Path Selection # Graph theory serves as a fundamental framework for modeling and understanding various systems across scientific domains. This study presents a detailed computational simulation implemented in Fortran, focusing on the manipulation, selection, and analysis of paths and individual entities within a graph. The simulation involves stepwise operations, including path creation, criteria-based selection, and the identification of Hamiltonian paths."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-03-04T21:53:09+01:00"><title>Fortran: Linked Lists | Ricardo Chin</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.b74e85bd7803de00c09a320dcf09ae0d7e37702a9918995f5fe9d1c71c55a223.css integrity="sha256-t06FvXgD3gDAmjINzwmuDX43cCqZGJlfX+nRxxxVoiM=" crossorigin=anonymous><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Ricardo Chin</span></a></h2><ul><li class=book-section-flat><a href=/docs/design/>Design Repository</a><ul><li><a href=/docs/design/fea-beam-simulation/>FEA Beam Instability Modes</a><ul></ul></li><li><a href=/docs/design/industrial-crane-design/>Industrial Girder Crane</a><ul></ul></li><li><a href=/docs/design/finite-element-method-development/>FEM Package Development</a><ul></ul></li><li><a href=/docs/design/manual-transmission-design/>Gear Train Transmission</a><ul></ul></li></ul></li><li class=book-section-flat><a href=/docs/code/>System Repository</a><ul><li><a href=/docs/code/agv/>AGV: Stochastic Identification</a><ul></ul></li><li><a href=/docs/code/uav/>UAV: Red Bull Air Racing</a><ul><li><a href=/docs/code/uav/dynamics/>Drone System Dynamics</a></li><li><a href=/docs/code/uav/continuous-controller-design/>Continuous Controller</a></li><li><a href=/docs/code/uav/discrete-controller-design/>Discrete Controller</a></li><li><a href=/docs/code/uav/computer-vision/>Gate Sense: Computer Vision</a></li></ul></li><li><a href=/docs/code/robotics/>Robotics: Kin, Dynamics & Control</a><ul></ul></li><li><a href=/docs/code/deep-learning-fake-news/>Fake News: Inference & Clusters</a><ul></ul></li><li><a href=/docs/code/bin-packing/>EC Optimization: Space & Time</a><ul><li><a href=/docs/code/bin-packing/genetic-algorithm/>Genetic Algorithm</a></li><li><a href=/docs/code/bin-packing/particle-swarm-optimization/>Particle Swarm Optimization</a></li></ul></li><li><a href=/docs/code/snake-game/>Snake: Reinforcement Learning</a><ul><li><a href=/docs/code/snake-game/deepqnetwork/>Off Policy RL & Neuroevolution</a></li><li><a href=/docs/code/snake-game/adversarial/>Adversarial Multi-Agent RL</a></li></ul></li></ul></li><li class=book-section-flat><a href=/docs/lectures/>My Notes and Lectures</a><ul><li><a href=/docs/lectures/bayesian-machine-learning/bayes/>Bayesian Inference</a></li><li><a href=/docs/lectures/bayesian-optimization/bayesopt/>Bayesian Optimization</a></li><li><a href=/docs/lectures/nonlinear-pro/nonlinear/>Nonlinear Programming</a></li></ul></li><li class=book-section-flat><a href=/docs/competitions/>Academic Competitions</a><ul><li><a href=/docs/competitions/fst/>Formula Student Lisbon</a></li><li><a href=/docs/competitions/thermocup/>ThermoCup</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Fortran: Linked Lists</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#1-simulation-and-analysis-of-graph-path-selection>1 Simulation and Analysis of Graph Path Selection</a></li><li><a href=#2-fortran>2 Fortran</a></li><li><a href=#3-goal-and-strategy>3 Goal and Strategy</a><ul><li><a href=#31-methodology--code-implementation>3.1. Methodology & Code Implementation</a></li><li><a href=#32-modules>3.2. Modules</a></li><li><a href=#33-simulator>3.3. Simulator</a></li></ul></li><li><a href=#4-discussion-and-efficiency>4 Discussion and Efficiency</a></li></ul></nav></aside></header><article class=markdown><h1 id=hamiltonian-paths-demo-in-fortran><strong>Hamiltonian Paths Demo in Fortran</strong>
<a class=anchor href=#hamiltonian-paths-demo-in-fortran>#</a></h1><p><img src="https://community.wolfram.com/c/portal/getImageAttachment?filename=sadasdewrhfggjgdfsg423567.gif&amp;userId=11733" alt=202></p><h2 id=1-simulation-and-analysis-of-graph-path-selection>1 Simulation and Analysis of Graph Path Selection
<a class=anchor href=#1-simulation-and-analysis-of-graph-path-selection>#</a></h2><p>Graph theory serves as a fundamental framework for modeling and understanding various systems across scientific domains. This study presents a detailed computational simulation implemented in Fortran, focusing on the manipulation, selection, and analysis of paths and individual entities within a graph. The simulation involves stepwise operations, including path creation, criteria-based selection, and the identification of Hamiltonian paths. Through this process, the efficacy of Fortran in managing graph structures is explored and analyzed.</p><h2 id=2-fortran>2 Fortran
<a class=anchor href=#2-fortran>#</a></h2><p>One of the primary reasons for opting for Fortran was its robustness and reliability in handling numerical simulations. Additionally, Fortran&rsquo;s performance in handling array-based operations and its ability to optimize code for high performance were crucial factors. Its speed and efficiency in managing computational tasks, especially those involving heavy mathematical computations, were significant advantages for this simulation.</p><h2 id=3-goal-and-strategy>3 Goal and Strategy
<a class=anchor href=#3-goal-and-strategy>#</a></h2><p>The primary goal is to identify Hamiltonian paths, which traverse all nodes in a graph exactly once, using a combination of path concatenation, selection, and filtering operations within the <code>soup</code>.</p><p><img src=https://cdn.hashnode.com/res/hashnode/image/upload/v1645474752428/0-9zYOaWg.gif alt=sda></p><p>The steps of the program involve preparing random edges between nodes, populating the <code>soup with individuals</code>, and visualizing these edges. It also involves path concatenation, selection based on specific criteria, and identification of Hamiltonian paths.</p><p>Core functionalities include linked list operations for path representation, concatenation, and selection. Filtering criteria are applied to identify potential Hamiltonian paths within the graph structure.</p><h3 id=31-methodology--code-implementation>3.1. Methodology & Code Implementation
<a class=anchor href=#31-methodology--code-implementation>#</a></h3><p>This project introduces a simulator program that encompasses various graph operations within a modular framework. The program is designed to facilitate the analysis and manipulation of graph structures represented as a collection of paths within a <code>soup</code>. The simulator leverages three essential modules: <code>msoup</code>, <code>mind</code>, and <code>mpath</code>, each contributing distinctive functionalities towards simulating, filtering, and identifying specific path attributes within the graph structure.</p><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p>My <a href=https://github.com/roaked/hamiltonian-paths>Github Repo</a> (Disclaimer: There is a C++ function!)</blockquote><h3 id=32-modules>3.2. Modules
<a class=anchor href=#32-modules>#</a></h3><h4 id=321-msoup>3.2.1. msoup
<a class=anchor href=#321-msoup>#</a></h4><p>The <code>msoup</code> module in this Fortran implementation serves as a robust framework for managing a collection of individuals, each representing a specific path within a graph structure. At its core, this module encapsulates a soup type, acting as a container for these individuals, and a node type, serving as the building block for storing individual references.</p><p>Within the <code>msoup</code> module, the soup type comprises pointers to the first and last individuals in the collection (<code>fst</code> and <code>lst</code>), alongside an integer count (<code>ln</code>) indicating the number of individuals present. This structure offers an organized and efficient means to handle and manipulate these individuals.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#66d9ef>type</span>, <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>::</span> soup
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(node), <span style=color:#66d9ef>pointer</span> <span style=color:#66d9ef>::</span> fst <span style=color:#75715e>! Points to the first individual of path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>type</span>(node), <span style=color:#66d9ef>pointer</span> <span style=color:#66d9ef>::</span> lst <span style=color:#75715e>! Points to the last individual of path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>integer</span> <span style=color:#66d9ef>::</span> ln <span style=color:#75715e>! Number of vertices (length) of path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>end</span> <span style=color:#66d9ef>type</span> soup
</span></span></code></pre></div><p>Individuals themselves are represented as instances of the node type. Each node stores a reference to an individual (<code>ind</code>) and a pointer to the next individual (<code>next</code>) within the collection. This linked structure allows for easy addition, removal, and traversal of individuals within the soup.</p><p>Functionally, the <code>msoup</code> module provides essential procedures:</p><ul><li><code>newS()</code> initializes an empty soup, setting pointers to null() and the individual count to zero.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#66d9ef>function</span> newS() <span style=color:#66d9ef>result</span>(s)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(soup) <span style=color:#66d9ef>::</span> s
</span></span><span style=display:flex><span>    s%fst <span style=color:#f92672>=&gt;</span> null() <span style=color:#75715e>! Set the first individual pointer to null
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    s%lst <span style=color:#f92672>=&gt;</span> null() <span style=color:#75715e>! Set the last individual pointer to null
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    s%ln <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e>! Initialize the count of individuals to zero
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>end</span> <span style=color:#66d9ef>function</span> newS
</span></span></code></pre></div><ul><li><code>insertS()</code> adds an individual to the soup by creating a new node, associating it with the provided individual, and updating pointers accordingly.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#66d9ef>subroutine</span> insertS(i, s)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(ind), <span style=color:#66d9ef>intent</span>(in) <span style=color:#66d9ef>::</span> i
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(soup), <span style=color:#66d9ef>intent</span>(inout) <span style=color:#66d9ef>::</span> s
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(node), <span style=color:#66d9ef>pointer</span> <span style=color:#66d9ef>::</span> aux
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>allocate</span>(aux)
</span></span><span style=display:flex><span>    aux%ind <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (s%ln <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        s%lst%next <span style=color:#f92672>=&gt;</span> aux <span style=color:#75715e>! Link the new node to the last node
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        s%fst <span style=color:#f92672>=&gt;</span> aux <span style=color:#75715e>! Update the first node if the soup is empty
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>if</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    s%lst <span style=color:#f92672>=&gt;</span> aux <span style=color:#75715e>! Update the last node to the newly added node
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    s%ln <span style=color:#f92672>=</span> s%ln <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e>! Increment the count of individuals
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>end</span> <span style=color:#66d9ef>subroutine</span> insertS
</span></span></code></pre></div><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p><p>To acess the 1st, last and count of individuals in the soup:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#75715e>! Accessing the first individual in the soup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>individual_1 <span style=color:#f92672>=</span> sp%fst%ind
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>! Accessing the last individual in the soup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>individual_last <span style=color:#f92672>=</span> sp%lst%ind
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>! Accessing the count of individuals in the soup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>number_of_individuals <span style=color:#f92672>=</span> sp%ln
</span></span></code></pre></div></blockquote><ul><li><code>nextS()</code> identifies pairs of individuals with compatible paths, computing the shortest distance between them, and returning these individuals along with a success indicator.</li><li><code>takeS()</code> removes a specified individual from the soup, adjusting pointers and deallocating the node.</li><li><code>an_indS()</code> retrieves a random individual from the soup, likely accessing the first individual&rsquo;s path.</li><li><code>emptyS()</code> checks if the soup is empty by examining the association of pointers.</li><li><code>sizeS()</code> returns the count of individuals in the soup.</li><li><code>showS()</code> displays details of all individuals in the soup, including their coordinates and paths.</li></ul><h4 id=322-mind>3.2.2. mind
<a class=anchor href=#322-mind>#</a></h4><p>The <code>mind</code> module handles the characteristics of individual entities (<code>ind</code>). It encapsulates their spatial coordinates and associated paths. This module includes functionalities for creating individuals, accessing their coordinates, calculating distances between them, and determining their equality. This <code>ind</code> type comprises attributes for a path (<code>w</code>) and three real-numbered coordinates (<code>x</code>, <code>y</code>, <code>z</code>).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#66d9ef>use</span> mind
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span>(path) <span style=color:#66d9ef>::</span> myPath
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span>(ind) <span style=color:#66d9ef>::</span> myPoint
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>! Assume initialization of myPath and coordinates for myPoint
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>call</span> makeI(myPath, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>2.0</span>, <span style=color:#ae81ff>3.0</span>, myPoint)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>! Retrieving coordinates
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>real</span> <span style=color:#66d9ef>::</span> x_coord, y_coord, z_coord
</span></span><span style=display:flex><span>x_coord <span style=color:#f92672>=</span> xposI(myPoint)
</span></span><span style=display:flex><span>y_coord <span style=color:#f92672>=</span> yposI(myPoint)
</span></span><span style=display:flex><span>z_coord <span style=color:#f92672>=</span> zposI(myPoint)
</span></span></code></pre></div><p>As visible, within this module, there are several functions and subroutines:</p><ul><li><code>makeI</code>: This subroutine creates an ind object with specified coordinates and a path.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#66d9ef>subroutine</span> makeI(w, x, y, z, i)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(path), <span style=color:#66d9ef>intent</span>(in) <span style=color:#66d9ef>::</span> w
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>real</span>, <span style=color:#66d9ef>intent</span>(in) <span style=color:#66d9ef>::</span> x, y, z
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(ind), <span style=color:#66d9ef>intent</span>(out) <span style=color:#66d9ef>::</span> i
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    i%w <span style=color:#f92672>=</span> w
</span></span><span style=display:flex><span>    i%x <span style=color:#f92672>=</span> x
</span></span><span style=display:flex><span>    i%y <span style=color:#f92672>=</span> y
</span></span><span style=display:flex><span>    i%z <span style=color:#f92672>=</span> z
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span> <span style=color:#66d9ef>subroutine</span> makeI
</span></span></code></pre></div><ul><li><code>pathI</code>: Extracts the path attribute from an ind object.</li><li><code>xposI</code>, <code>yposI</code>, <code>zposI</code>: These functions retrieve the x, y, and z coordinates from an ind object.</li><li><code>distI</code>: Computes the Euclidean distance between two ind objects using their coordinates.</li></ul><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p><p>This is only the Euclidean distance!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#66d9ef>function</span> distI(i1, i2) <span style=color:#66d9ef>result</span>(r)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(ind), <span style=color:#66d9ef>intent</span>(in) <span style=color:#66d9ef>::</span> i1, i2
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>real</span> <span style=color:#66d9ef>::</span> r
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    r <span style=color:#f92672>=</span> sqrt(((i1%x <span style=color:#f92672>-</span> i2%x)<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>) <span style=color:#f92672>+</span> ((i1%y <span style=color:#f92672>-</span> i2%y)<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>) <span style=color:#f92672>+</span> ((i1%z <span style=color:#f92672>-</span> i2%z)<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span> <span style=color:#66d9ef>function</span> distI
</span></span></code></pre></div></blockquote><ul><li><code>ind_eqI</code>: This function checks if two ind objects have the same coordinates.</li></ul><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#66d9ef>function</span> ind_eqI(i1, i2) <span style=color:#66d9ef>result</span>(b)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(ind), <span style=color:#66d9ef>intent</span>(in) <span style=color:#66d9ef>::</span> i1, i2
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logical</span> <span style=color:#66d9ef>::</span> b
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((xposI(i1) <span style=color:#f92672>==</span> xposI(i2)) .and. (yposI(i1) <span style=color:#f92672>==</span> yposI(i2)) .and. (zposI(i1) <span style=color:#f92672>==</span> zposI(i2))) <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        b <span style=color:#f92672>=</span> .true.
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        b <span style=color:#f92672>=</span> .false.
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>if</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span> <span style=color:#66d9ef>function</span> ind_eqI
</span></span></code></pre></div><p>Note: As previously mentioned, this function compares if objects (<code>i1</code> and <code>i2</code>) have identical coordinates. It compares coordinates using <code>xposI</code>, <code>yposI</code> and <code>zposI</code> functions and returns a logical value.</p></blockquote><blockquote class="book-hint2 note"><p class="hint-title note"><svg class="book-icon"><use href="/svg/hint-icons.svg#note-notice"/></svg><span>note</span></p>These implementations illustrate how the functions extract coordinates (<code>xposI</code>, <code>yposI</code>, <code>zposI</code>), calculate distances between points (<code>distI</code>), and determine if points share identical coordinates (<code>ind_eqI</code>).</blockquote><h4 id=323-mpath>3.2.3 mpath
<a class=anchor href=#323-mpath>#</a></h4><p>The <code>mpath</code> module in Fortran is dedicated to managing paths using linked lists, represented by the path and node types. The path type contains pointers to the first and last elements of the path (<code>fst</code>, <code>lst</code>) and keeps track of the path&rsquo;s length (<code>ln</code>). On the other hand, each node represents an element in the path, storing an integer value and a pointer to the next node. As visible, within this module, there are several functions and subroutines:</p><ul><li><code>newP</code> creates an empty path by setting pointers to null and initializing the length as zero.</li><li><code>enterP</code> appends an element to the end of a path, updating pointers accordingly.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#66d9ef>subroutine</span> enterP(x, w)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>integer</span>, <span style=color:#66d9ef>intent</span>(in) <span style=color:#66d9ef>::</span> x
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(path), <span style=color:#66d9ef>intent</span>(inout) <span style=color:#66d9ef>::</span> w
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(node), <span style=color:#66d9ef>pointer</span> <span style=color:#66d9ef>::</span> aux
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>allocate</span>(aux)
</span></span><span style=display:flex><span>    aux%<span style=color:#66d9ef>value</span> <span style=color:#f92672>=</span> x
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (w%ln <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        w%lst%next <span style=color:#f92672>=&gt;</span> aux
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        w%fst <span style=color:#f92672>=&gt;</span> aux
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>if</span>
</span></span><span style=display:flex><span>    w%lst <span style=color:#f92672>=&gt;</span> aux
</span></span><span style=display:flex><span>    w%ln <span style=color:#f92672>=</span> w%ln <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span> <span style=color:#66d9ef>subroutine</span> enterP
</span></span></code></pre></div><blockquote class="book-hint2 note"><p class="hint-title note"><svg class="book-icon"><use href="/svg/hint-icons.svg#note-notice"/></svg><span>note</span></p>In turn, it allocates memory for a new node, assigns the value x to it, updates pointers, and increments the path length.</blockquote><ul><li><code>revP</code> copies a specified number of elements from one path to another in reverse order.</li><li><code>shortenP</code> removes the first element from a path, deallocating memory and updating pointers.</li><li><code>makeP</code> creates a path with two specified elements by utilizing newP and enterP.</li><li><code>firstP</code> and <code>lastP</code> retrieve the first and last elements of a path, respectively, handling empty path conditions.</li><li><code>lengthP</code> returns the length of a path by accessing the ln attribute.</li><li><code>compP</code> checks if the last element of one path matches the first element of another path.</li><li><code>glueP</code> merges two compatible paths by linking their nodes, creating a new path.</li><li><code>crossesP</code> determines if a specified value exists within a path by traversing nodes and comparing values.</li><li><code>copyP</code> duplicates the contents of a path to another in reverse order using revP.</li><li><code>deleteP</code> recursively removes elements of a path until it becomes empty, deallocating nodes.</li><li><code>showP</code> displays the elements of a path by reversing it and printing its values.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#66d9ef>subroutine</span> showP(w)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(path), <span style=color:#66d9ef>intent</span>(in) <span style=color:#66d9ef>::</span> w
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(path) <span style=color:#66d9ef>::</span> r
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>integer</span> <span style=color:#66d9ef>::</span> i
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>integer</span>, <span style=color:#66d9ef>dimension</span>(w%ln) <span style=color:#66d9ef>::</span> aux
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    r <span style=color:#f92672>=</span> newP()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>call</span> revP(w, r, w%ln)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>do</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, w%ln
</span></span><span style=display:flex><span>        aux(i) <span style=color:#f92672>=</span> firstP(r)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (r%ln <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>call</span> shortenP(r)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>if</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>print</span> <span style=color:#f92672>*</span>, aux
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span> <span style=color:#66d9ef>subroutine</span> showP
</span></span></code></pre></div><blockquote class="book-hint2 warning"><p class="hint-title warning"><svg class="book-icon"><use href="/svg/hint-icons.svg#warning-notice"/></svg><span>warning</span></p>These functionalities handle path creation, manipulation, comparison, concatenation, element retrieval, deletion, and display efficiently using the linked list structure.</blockquote><h3 id=33-simulator>3.3. Simulator
<a class=anchor href=#33-simulator>#</a></h3><p>The simulation process within this program is orchestrated across several distinct steps, each playing a crucial role in analyzing, manipulating, and presenting pathways within a given graph structure.</p><ul><li>#1. Initialization & Graph Preparation: This initial step involves setting up the simulation environment and creating the initial <code>soup</code>, which holds individual nodes representing edges within the graph.</li></ul><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p><p><strong>Key Actions</strong>:</p><ul><li>Parameter Setup: Initializes user-defined parameters such as the number of nodes (<code>no</code>), edges (<code>s</code>), and other simulation variables (<code>ka</code>, <code>nu</code>).</li><li>Node Creation: Generates individual nodes representing edges, assigning them random coordinates and attributes within the soup.</li></ul></blockquote><ul><li>#2. Hybridization & Path Concatenation: Concatenates compatible paths, creating new paths by merging individual paths from the soup, fostering connections in the graph.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#66d9ef>do</span> c6<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, nu
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>call</span> nextS(sp, i1, i2, sb)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>call</span> pathI(i1, w1)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>call</span> pathI(i2, w2)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>call</span> glueP(w1, w2, w3)
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span> <span style=color:#66d9ef>do</span>
</span></span></code></pre></div><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p><p><strong>Key Actions</strong>:</p><ul><li>Path Merging: Combines compatible paths from individual nodes to create longer, concatenated paths.</li><li>Creation of New Paths: Generates new paths representing connected segments within the graph by merging compatible paths.</li></ul></blockquote><ul><li>#3. Path Selection & Filtering: Selects specific paths based on defined criteria, filtering out paths that do not meet user-defined conditions.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#66d9ef>do</span> c9<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, no
</span></span><span style=display:flex><span>    eln <span style=color:#f92672>=</span> eln <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>do</span> c10<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, sizeS(sp3)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>call</span> an_indS(sp3, i6)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>call</span> pathI(i6, w6)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>call</span> crossesP(w6, eln, ib1)
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span> <span style=color:#66d9ef>do</span>
</span></span></code></pre></div><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p><p><strong>Key Actions</strong>:</p><ul><li>Selection Criteria: Filters paths based on criteria such as starting and ending nodes, path length, or nodes traversed.</li><li>Soup Reorganization: Removes incompatible paths from the soup while organizing selected paths for further analysis.</li></ul></blockquote><ul><li>#4. Hamiltonian Path Identification: Identifies and presents Hamiltonian paths, which are paths that traverse all nodes in the graph.</li></ul><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p><p><strong>Key Actions</strong>:</p><ul><li>Traversal Analysis: Analyzes filtered paths to identify those that traverse all nodes in the graph.</li><li>Presentation of Results: Displays identified Hamiltonian paths for comprehensive graph exploration and analysis.</li></ul></blockquote><p>In the end, the simulation aids in comprehending how different entities or nodes within a network are interconnected. By identifying paths and relationships between nodes, it offers insights into how information, resources, or influence flow through a network. It facilitates the discovery of optimal paths that traverse all nodes or specific ones. This capability is invaluable for planning efficient routes, optimizing processes, or understanding the most effective pathways within a system.</p><p>This project served me as an educational tool, offering a foundational understanding of network theory, paths, and connections &ndash; providing a hands-on approach to learning about complex systems and their underlying structures.</p><h2 id=4-discussion-and-efficiency>4 Discussion and Efficiency
<a class=anchor href=#4-discussion-and-efficiency>#</a></h2><p>This study represented the efficacy of Fortran in computational simulations for graph path selection and analysis. The utilization of modules (<code>msoup</code>, <code>mind</code>, and <code>mpath</code>) showcases how Fortran manages individual entities, paths, and complex graph structures efficiently. The simulation steps, from initialization to the identification of Hamiltonian paths, illustrate the algorithmic flexibility of Fortran in traversing and analyzing graphs.</p><p>The significance of criteria-based path selection is evident in this study. It serves as a fundamental aspect in uncovering specific graph properties, such as Hamiltonian paths. The discussions around computational efficiency and the impact of different criteria on path selection highlight the practical relevance of these simulations in diverse scientific domains.</p><blockquote class="book-hint2 example"><p class="hint-title example"><svg class="book-icon"><use href="/svg/hint-icons.svg#example-notice"/></svg><span>example</span></p><p>Moving forward, several promising directions emerge for advancing this research. Algorithmic improvements hold potential for enhancing computational efficiency, especially when dealing with larger and more intricate graphs. Optimizing path selection methodologies could significantly expedite the analysis process.</p><p>Investigating parallel computing techniques stands as another avenue to explore, leveraging Fortran&rsquo;s capabilities for faster processing of extensive graph structures and enabling more extensive analyses.</p><p>Lastly, integrating machine learning techniques into the analysis pipeline could refine criteria determination, potentially improving accuracy and adaptability in path selection methodologies.</p></blockquote></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/roaked/roaked.github.io/commit/290d52e3bdb24bbd6831441eaa02d235bf3a3ff1 title='Last modified by roaked | March 4, 2024' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>March 4, 2024</span></a></div><div><a class="flex align-center" href=https://github.com/roaked/roaked.github.io/edit/main/content/content/docs/lectures/hamiltonian-graphs/hamiltonian.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Ricardo Chin</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#1-simulation-and-analysis-of-graph-path-selection>1 Simulation and Analysis of Graph Path Selection</a></li><li><a href=#2-fortran>2 Fortran</a></li><li><a href=#3-goal-and-strategy>3 Goal and Strategy</a><ul><li><a href=#31-methodology--code-implementation>3.1. Methodology & Code Implementation</a></li><li><a href=#32-modules>3.2. Modules</a></li><li><a href=#33-simulator>3.3. Simulator</a></li></ul></li><li><a href=#4-discussion-and-efficiency>4 Discussion and Efficiency</a></li></ul></nav></div></aside></main></body></html>