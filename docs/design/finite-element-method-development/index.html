<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Finite Element Method: A Virtual Tetris # 1 DIY: A FEA Playground # tip
If you wish to skip the theoretical and implementation details, and would like to know my thoughts on attempting to code a finite element method software or alternatively develop a SDK for existing SW, please click here to jump to the summarized findings Ch. 4 - My Considerations. 1.1. Partial Differential Equations (PDEs) # In engineering and physics, problems are often described by partial differential equations (PDEs)."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="FEM Package Development"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://xsleaks.dev/docs/design/finite-element-method-development/"><title>FEM Package Development | Ricardo Chin</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.b74e85bd7803de00c09a320dcf09ae0d7e37702a9918995f5fe9d1c71c55a223.css integrity="sha256-t06FvXgD3gDAmjINzwmuDX43cCqZGJlfX+nRxxxVoiM=" crossorigin=anonymous><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-10WQY47KS2"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-10WQY47KS2",{anonymize_ip:!1})}</script><link rel=alternate type=application/rss+xml href=https://xsleaks.dev/docs/design/finite-element-method-development/index.xml title="Ricardo Chin"></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Ricardo Chin</span></a></h2><ul><li class=book-section-flat><a href=/docs/design/>Design Repository</a><ul><li><a href=/docs/design/fea-beam-simulation/>FEA Beam Instability Modes</a><ul></ul></li><li><a href=/docs/design/industrial-crane-design/>Industrial Girder Crane</a><ul></ul></li><li><a href=/docs/design/finite-element-method-development/ class=active>FEM Package Development</a><ul></ul></li><li><a href=/docs/design/manual-transmission-design/>Gear Train Transmission</a><ul></ul></li><li><a href=/docs/design/electron-beam-tech/>Electron Beam Technology</a><ul></ul></li></ul></li><li class=book-section-flat><a href=/docs/code/>Coding Repository</a><ul><li><a href=/docs/code/uav/>UAV Red Bull Air Racing</a><ul><li><a href=/docs/code/uav/dynamics/>Drone Dynamics</a></li><li><a href=/docs/code/uav/continuous-controller-design/>Drone Continuous Controller</a></li><li><a href=/docs/code/uav/discrete-controller-design/>Drone Discrete Controller</a></li><li><a href=/docs/code/uav/computer-vision/>Drone Computer Vision</a></li></ul></li><li><a href=/docs/code/agv/>AGV: System Identification</a><ul></ul></li><li><a href=/docs/code/deep-learning-fake-news/>Deep Learning on Fake News</a><ul></ul></li><li><a href=/docs/code/hamiltonian-graphs/hamiltonian/>Hamiltonian Paths: Linked Lists</a></li><li><a href=/docs/code/bin-packing/>EC Optimization: Space & Time</a><ul><li><a href=/docs/code/bin-packing/genetic-algorithm/>Genetic Algorithm</a></li><li><a href=/docs/code/bin-packing/particle-swarm-optimization/>Particle Swarm Optimization</a></li></ul></li><li><a href=/docs/code/snake-game/>Snake Game: Genetic RL-DQN</a><ul></ul></li><li><a href=/docs/code/micromouse/>Micromouse: Flood Fill to A*</a><ul></ul></li><li><a href=/docs/code/batteries-ev/>PyBaMM-ML EV Battery Status</a><ul></ul></li></ul></li><li class=book-section-flat><a href=/docs/competitions/>Academic Competitions</a><ul><li><a href=/docs/competitions/fst/>Formula Student Lisbon</a></li><li><a href=/docs/competitions/thermocup/>ThermoCup</a></li></ul></li><li class=book-section-flat><a href=/docs/leet/>My LeetCode Solutions</a><ul></ul></li><li class=book-section-flat><a href=/docs/mod/>Website Modifications</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>FEM Package Development</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#1-diy-a-fea-playground>1 DIY: A FEA Playground</a><ul><li><a href=#11-partial-differential-equations-pdes>1.1. Partial Differential Equations (PDEs)</a></li><li><a href=#12-problem-formulation>1.2. Problem Formulation</a></li><li><a href=#13-analytical-integration>1.3. Analytical Integration</a></li><li><a href=#14-numerical-integration>1.4. Numerical Integration</a></li><li><a href=#15-torsional-constant>1.5. Torsional Constant</a></li><li><a href=#16-shear-stresses>1.6. Shear Stresses</a></li></ul></li><li><a href=#2-matlab-time-for-some-coding>2 MATLAB: Time for some coding!</a><ul><li><a href=#21-read_memd>2.1. READ_ME.md</a></li><li><a href=#22-analytical-integration>2.2. Analytical Integration</a></li><li><a href=#23-gauss-integration>2.3. Gauss Integration</a></li><li><a href=#24-nodal-solution>2.4. Nodal Solution</a></li><li><a href=#25-torsion-coefficient>2.5. Torsion Coefficient</a></li><li><a href=#26-maximum-and-minimum-stresses>2.6. Maximum and Minimum Stresses</a></li><li><a href=#27-validation-based-on-book>2.7. Validation Based on Book</a></li></ul></li><li><a href=#3-comparison-with-fem-commercial-software-siemens-nx>3 Comparison with FEM commercial software Siemens NX</a><ul><li><a href=#31-analytical-integration>3.1. Analytical Integration</a></li><li><a href=#32-gauss-integration-2x2>3.2. Gauss Integration 2x2</a></li><li><a href=#33-gauss-integration-2x1>3.3. Gauss Integration 2x1</a></li><li><a href=#34-gauss-integration-1x2>3.4. Gauss Integration 1x2</a></li><li><a href=#35-gauss-integration-1x1>3.5. Gauss Integration 1x1</a></li><li><a href=#36-torsion-coefficients-nx-vs-matlab>3.6. Torsion Coefficients NX vs. Matlab</a></li><li><a href=#37-max-and-min-stresses-nx-vs-matlab>3.7. Max and Min Stresses NX vs. Matlab</a></li><li><a href=#38-results-siemens-nx>3.8. Results Siemens NX</a></li><li><a href=#39-results-matlab>3.9. Results MATLAB</a></li></ul></li><li><a href=#4-my-considerations>4 My Considerations</a></li><li><a href=#5-future-work>5 Future Work</a></li><li><a href=#6-attachments>6 Attachments</a></li></ul></nav></aside></header><article class=markdown><h1 id=finite-element-method-a-virtual-tetris><strong>Finite Element Method: A Virtual Tetris</strong>
<a class=anchor href=#finite-element-method-a-virtual-tetris>#</a></h1><h2 id=1-diy-a-fea-playground>1 DIY: A FEA Playground
<a class=anchor href=#1-diy-a-fea-playground>#</a></h2><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p>If you wish to skip the theoretical and implementation details, and would like to know my thoughts on attempting to code a finite element method software or alternatively develop a SDK for existing SW, <a href=https://ricardochin.com/docs/design/finite-element-method-development/#4-my-considerations>please click here to jump to the summarized findings Ch. 4 - My Considerations</a>.</blockquote><h3 id=11-partial-differential-equations-pdes>1.1. Partial Differential Equations (PDEs)
<a class=anchor href=#11-partial-differential-equations-pdes>#</a></h3><p>In engineering and physics, problems are often described by partial differential equations (PDEs). The &ldquo;strong form&rdquo; refers to the original differential equation that must hold exactly throughout the domain, including both the governing equation and the boundary conditions.</p><p>However, there are cases where directly solving the strong form might be challenging due to complexities in the equation, irregular geometries, or varying boundary conditions. This is where the &ldquo;weak formulation&rdquo; or (&ldquo;weak form&rdquo;) becomes advantageous.</p><p>The weak form introduces a relaxation of the constraints imposed by the strong form by multiplying the governing equation with a weight function (typically a test function) and integrating it over the domain.</p><details><summary>This relaxation allows for more flexibility in solution techniques and offers several advantages: (click to expand)</summary><div class=markdown-inner><ul><li><p>Handling Boundary Conditions: The weak form often simplifies the imposition of different types of boundary conditions.</p></li><li><p>Solvability: Some differential equations in the strong form might not have exact solutions or might be difficult to solve directly. The weak form can lead to a more manageable equation for numerical methods.</p></li><li><p>Adaptability to Numerical Methods: Finite element, boundary element, and other numerical methods are often more easily applied to weak formulations due to the integral nature of the equations.</p></li><li><p>Handling Discontinuities: In problems involving discontinuities or singularities, the weak form can handle these cases more effectively.</p></li><li><p>Minimization of Requirements: In some cases, the requirement for differentiability or the number of times an equation needs to be differentiated is reduced, easing computational complexity.</p></li></ul></div></details><p>Overall, the weak form is favoured in many situations because it relaxes the strictness of the original problem while maintaining the essential properties required for solutions, making it more adaptable for various solution techniques, especially in numerical analysis.</p><h3 id=12-problem-formulation>1.2. Problem Formulation
<a class=anchor href=#12-problem-formulation>#</a></h3><p>Let&rsquo;s assume that the problem involves analyzing the torsional behaviour of a prismatic bar with the cross-section depicted using the Prandtl stress function. The objective is to determine the torsional stiffness constant J and the distribution of shear stresses across the section, shear stress contour lines, identification of maximum and minimum shear stresses due to a unit torsional moment applied to the bar.</p><h4 id=122-strong-form>1.2.2. Strong Form
<a class=anchor href=#122-strong-form>#</a></h4><p>Let&rsquo;s begin by establishing the strong formulation of the problem, which serves as the foundation of our problem. In this formulation, we encapsulate the fundamental differential equation governing the system&rsquo;s behaviour. This equation, along with the precise boundary conditions and initial values, constitutes the direct representation of the underlying physical laws guiding the system&rsquo;s dynamics.</p><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><span>\[\theta - \nabla \cdot (k \nabla u) = f\]</span><p>For the torsional loading problem k = 1 and f = 2. The following equations indulge:</p><span>\[\frac{\partial^2 \phi}{\partial x^2} + \frac{\partial^2 \phi}{\partial y^2} = - 2G \theta\]</span><p>This is referring to the Prandtl stress function, which defines shear stresses as:</p><span>\[\tau_{xz} = \frac{\partial \phi}{\partial y} \text{ and } \tau_{yz} = \frac{\partial \phi}{\partial x}\]</span><p>The resolution of a torsion problem involves solving the Prandtl equation by imposing the boundary condition around the entire perimeter of the figure, as is known:</p><span>\[\phi = 0\]</span><p>To do this, the Prandtl function is divided by <span>\(G\theta\)
</span>, considering this value is not known, as follows in the next set of expressions:</p><span>\[\frac{\partial^2 \psi}{\partial x^2} + \frac{\partial^2 \psi}{\partial y^2} = - 2 \text{ and } \psi = \frac{\phi}{G \theta}\]
</span><span>\[\tau_{yz} = -G \theta \frac{\partial \psi}{\partial x} \text{ and } \tau_{xz} = G \theta \frac{\partial \psi}{\partial y}\]</span><p>The developed program will calculate the solution given by <span>\(\psi\)
</span>for each node, the shear stresses, and the value of torsional rigidity. The problem of <span>\(G \theta\)
</span>is solved using the formula:</p><span>\[G \theta = \frac{Mt}{J}\]</span><p>In the previous formula, the M (torsional moment) and t (thickness) take the value of 1.</p><h4 id=121-weak-form>1.2.1. Weak Form
<a class=anchor href=#121-weak-form>#</a></h4><p>The weak form enables transforming the differential equation into an integral equation, where the initial approach involves integrating the equation across the entire domain. Rules are applied to obtain the weak form, namely, defining the residual by multiplying it with an arbitrary function, integrating by parts the highest-order term, and rearranging the equation. Thus:</p><span>\[\iint_S \frac{\partial \phi_i}{\partial x} \frac{\partial \phi_j}{\partial x} + \frac{\partial \phi_i}{\partial y} \frac{\partial \phi_j}{\partial y} dA = \iint_S 2\phi_i dA\]</span><p>The stiffnex matrix is given by:</p><span>\[K_{ij} = \iint_S \frac{\partial \phi_i}{\partial x} \frac{\partial \phi_j}{\partial x} + \frac{\partial \phi_i}{\partial y} \frac{\partial \phi_j}{\partial y} dx dy\]</span><p>Additionally, the load vector is presented as:</p><span>\[F_i = \iint_S 2 \phi_i dx dy\]</span><p>In the considered problem, the only essential boundary condition will be the null solution across the entire perimeter of the figure, accompanied by a distributed load of magnitude 2 applied across the entire mesh.</p><h3 id=13-analytical-integration>1.3. Analytical Integration
<a class=anchor href=#13-analytical-integration>#</a></h3><p>Simplifying the problem&rsquo;s resolution, only regular 4-node elements with 1 degree of freedom will be considered. Information from the book <a href="https://books.google.at/books/about/An_Introduction_to_the_Finite_Element_Me.html?id=8gqnRwAACAAJ&amp;redir_esc=y">&ldquo;Introduction to the Finite Element Method (3rd edition)&rdquo; by J.N. Reddy</a> provides the following details:</p><ul><li><p>Stiffness matrix (e): <span>\(K^e = \frac{k}{6ab} \begin{bmatrix}
2(a^2+b^2) & a^2-2b^2 & -(a^2+b^2) & -2a^2+b^2\\
a^2-2b^2 & 2(a^2+b^2) & -2a^2+b^2 & -(a^2+b^2)\\
-(a^2+b^2) & -2a^2+b^2 & 2(a^2+b^2) & a^2-2b^2\\
-2a^2+b^2 & -(a^2+b^2) & a^2-2b^2 & 2(a^2+b^2)\\
\end{bmatrix} \)</span></p></li><li><p>Load vector (e): <span>\(f^e =\frac{fab}{4} \begin{bmatrix}
1\\
1\\
1\\
1\\
\end{bmatrix} \)</span></p></li></ul><p>Where &lsquo;a&rsquo; corresponds to the length of the base of the element, and &lsquo;b&rsquo; corresponds to the height of the element.</p><h3 id=14-numerical-integration>1.4. Numerical Integration
<a class=anchor href=#14-numerical-integration>#</a></h3><p>These functions aim to calculate the elemental stiffness matrix using the Gauss-Jordan approximation, which simplifies integration to a summation. To achieve this, a coordinate transformation from <span>\((x,y)\)
</span>to <span>\( (\xi, \eta) \)
</span>is applied, while also computing the Jacobian of this transformation. Subsequently, the rules of Gauss points are employed.</p><p>In Gauss integration, the stiffness matrix K is computed through reduced integrals:</p><span>\[K_{ij} = \frac{\partial \phi_i}{\partial x} \frac{\partial \phi_j}{\partial x} + \frac{\partial \phi_i}{\partial y} \frac{\partial \phi_j}{\partial y} \times J \times w\]
</span><span>\[J = \begin{bmatrix}
\frac{\partial x}{\partial \xi} & \frac{\partial x}{\partial \eta}\\
\frac{\partial y}{\partial \xi} & \frac{\partial y}{\partial \eta}\\
\end{bmatrix} = \frac{ab}{4}\]</span><p>In the previous Gauss integration, &lsquo;w&rsquo; corresponds to the integration weights. For a 1x1 integration, the integration is performed solely at the center of the element, with a weight of w = 1. For 2x1 or 1x2 integration, each &lsquo;w&rsquo; value represents the sum of 2 reduced integrals (2 different points within the element), and the weight is w=2. For a 2x2 integration, the summation includes 4 reduced integrals (4 different points), and w=1. The following values of <span>\(\overline{x}\)
</span>and <span>\(\overline{y}\)
</span>correspond to the Gauss points:</p><span>\[\phi_1 = (1-\frac{\overline{y}}{b})(1-\frac{\overline{x}}{a}) \quad \quad \phi_2 = \frac{\overline{x}}{a}(1-\frac{\overline{y}}{b})\]
</span><span>\[\phi_3 = \frac{\overline{y}}{b}\frac{\overline{x}}{a} \quad \quad \phi_4 = \frac{\overline{y}}{b}(1-\frac{\overline{x}}{a})\]</span><p>Consequently:</p><span>\[ \text{1x1 Rule} : \overline{x}=\frac{a}{2} \quad \text{and} \quad \overline{y}=\frac{b}{2}\]
</span><span>\[ \text{2x2 Rule} : \overline{x_{1,2}}=\frac{a}{2}(1 \pm \sqrt{\frac{1}{3}}) \quad \text{and} \quad \overline{y_{1,2}}=\frac{b}{2}(1 \pm \sqrt{\frac{1}{3}})\]</span><h3 id=15-torsional-constant>1.5. Torsional Constant
<a class=anchor href=#15-torsional-constant>#</a></h3><p>After calculating the nodal solution, the torsion constant J can be determined by:</p><span>\[J^e = \int_0^b \int_0^a 2 \psi^e dxdy = \frac{ab}{2}(\psi_1 + \psi_2 + \psi_3 + \psi_4) \qquad J = \sum_i J_i^e\]</span><h3 id=16-shear-stresses>1.6. Shear Stresses
<a class=anchor href=#16-shear-stresses>#</a></h3><span>\[\tau_{yz} = -G \theta \frac{\partial \psi}{\partial x} = -G \theta (\frac{\partial \phi_1}{\partial \overline{x}}\psi_1 + \frac{\partial \phi_2}{\partial \overline{x}}\psi_2 + \frac{\partial \phi_3}{\partial \overline{x}}\psi_3 + \frac{\partial \phi_4}{\partial \overline{x}}\psi_4)\]
</span><span>\[\tau_{xz} = G \theta \frac{\partial \psi}{\partial y} = G \theta (\frac{\partial \phi_1}{\partial \overline{y}}\psi_1 + \frac{\partial \phi_2}{\partial \overline{y}}\psi_2 + \frac{\partial \phi_3}{\partial \overline{y}}\psi_3 + \frac{\partial \phi_4}{\partial \overline{y}}\psi_4)\]
</span><span>\[\tau_{xy} = \sqrt{\tau_{yz}^2 +\tau_{xz}^2}\]</span><h2 id=2-matlab-time-for-some-coding>2 MATLAB: Time for some coding!
<a class=anchor href=#2-matlab-time-for-some-coding>#</a></h2><h3 id=21-read_memd>2.1. READ_ME.md
<a class=anchor href=#21-read_memd>#</a></h3><p>The program starts by executing the <a href=https://github.com/roaked/fem-math-formulation/blob/main/code/MainG10.m>script MainG10.m</a> and should contain all the subfunctions and their respective &rsquo;txt&rsquo; files in the respective folder. Once the program is initiated, the user inputs the data file name in the form of &ldquo;nome.txt.&rdquo; The data file should contain the node coordinates, connectivity matrix, and boundary conditions. The data file created for this problem is named <a href=https://github.com/roaked/fem-math-formulation/tree/main/code>dadosg10.txt</a>.</p><p>After submitting the data file, the program reads the file and automatically opens a figure displaying the mesh with numbered nodes and elements. Simultaneously, a menu with various options is displayed. The user should first choose the type of integration and then select the desired plots for shear stresses, stress contour lines, and nodal solutions. Submitting the options is done by entering the corresponding number. The program is terminated by entering the number 0.</p><p>Upon program completion, a file is created containing the data obtained from the last integration performed.</p><p><img src=https://live.staticflickr.com/65535/53347766202_f8a2c9e042_q.jpg alt=sds></p><blockquote class="book-hint2 warning"><p class="hint-title warning"><svg class="book-icon"><use href="/svg/hint-icons.svg#warning-notice"/></svg><span>warning</span></p>The node numbering associated with a given element in the incidence matrix is done counterclockwise, as shown in the accompanying image. Any other numbering will yield incorrect results for solving this problem. The coordinates in the node matrix are in SI units, therefore in meters. Introducing values in different units in the data file will result in incorrect units in the final program output. The material conductivity or property should be 1; if it&rsquo;s not, the results won&rsquo;t be valid for this torsion problem. Regarding boundary conditions, only essential boundary conditions equal to zero are allowed. However, they will be set to zero if another finite value is associated. The distributed loading assumes the value 2; however, if the value differs, the program will still provide results—though they may not be reasonable for solving the initially presented problem. All other boundary conditions should be null, and if they&rsquo;re not, an error message will be displayed.</blockquote><h3 id=22-analytical-integration>2.2. Analytical Integration
<a class=anchor href=#22-analytical-integration>#</a></h3><p>The <a href=https://github.com/roaked/fem-math-formulation/blob/main/code/KAnalitico.m>function KAnalitico</a> in <code>MATLAB</code> computes the global stiffness matrix using an analytical integration method for square elements defined by four nodes. It initializes the global stiffness matrix <code>K</code> and an elemental stiffness matrix <code>ke</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Matlab data-lang=Matlab><span style=display:flex><span>k = propriedades(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>);  <span style=color:#75715e>% Constant value (k = 1)</span>
</span></span><span style=display:flex><span>K = zeros(n_nos);        <span style=color:#75715e>% Initializes the global stiffness matrix with zeros</span>
</span></span><span style=display:flex><span>ke = zeros(<span style=color:#ae81ff>4</span>);           <span style=color:#75715e>% Initializes the elemental stiffness matrix with zeros (4x4)</span>
</span></span></code></pre></div><p>The loop iterates through each element, calculates the elemental stiffness matrix based on the element&rsquo;s geometry and material properties, and assembles it into the global stiffness matrix.</p><p>The elemental stiffness matrix <code>ke</code> is computed using specific mathematical formulas for each entry based on the element&rsquo;s area and dimensions. The calculated elemental stiffness matrix is then assembled into the corresponding locations in the global stiffness matrix <code>K</code>, combining contributions from all elements to form the final stiffness matrix.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Matlab data-lang=Matlab><span style=display:flex><span><span style=color:#66d9ef>for</span> i = <span style=color:#ae81ff>1</span>:size(matriz_de_incidencias, <span style=color:#ae81ff>1</span>) <span style=color:#75715e>% Loop through elements</span>
</span></span><span style=display:flex><span>    c = matriz_de_incidencias(i, <span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>4</span>);     <span style=color:#75715e>% Nodes associated with the current element</span>
</span></span><span style=display:flex><span>    c1 = c(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);  <span style=color:#75715e>% Node #1 of the current element</span>
</span></span><span style=display:flex><span>    c2 = c(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>);  <span style=color:#75715e>% Node #2 of the current element</span>
</span></span><span style=display:flex><span>    c3 = c(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>);  <span style=color:#75715e>% Node #3 of the current element</span>
</span></span><span style=display:flex><span>    c4 = c(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>4</span>);  <span style=color:#75715e>% Node #4 of the current element</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Elemental stiffness matrix calculation</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Calculation of ke entries based on the element&#39;s geometry</span>
</span></span><span style=display:flex><span>    ke(c1, c1) = k <span style=color:#f92672>/</span> (<span style=color:#ae81ff>6</span> <span style=color:#f92672>*</span> a(i) <span style=color:#f92672>*</span> b(i)) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> (a(i)^<span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> b(i)^<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>% ... similar calculations for other ke entries</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Assembling ke into the global stiffness matrix K</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> o = [c1, c2, c3, c4]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j = [c1, c2, c3, c4]
</span></span><span style=display:flex><span>            K(o, j) = K(o, j) <span style=color:#f92672>+</span> ke(o, j);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p>This approach leverages analytical calculations specific to the geometry of the square elements to directly compute the stiffness contributions without numerical integration.</blockquote><h3 id=23-gauss-integration>2.3. Gauss Integration
<a class=anchor href=#23-gauss-integration>#</a></h3><p>The <a href=%28https://github.com/roaked/fem-math-formulation/blob/main/code/KGauss.m%29>KGauss function</a> in <code>MATLAB</code> is responsible for computing the global stiffness matrix using Gaussian integration for different element configurations. It initializes the stiffness matrix K and extracts necessary parameters.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Matlab data-lang=Matlab><span style=display:flex><span>K = zeros(n_nos);
</span></span><span style=display:flex><span>k = propriedades(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>);
</span></span></code></pre></div><p>The code branches based on the chosen integration option: 2x2, 2x1 with different weights, 1x2 with varying weights, and 1x1. Within each branch, it iterates over the elements, computes derivatives of shape functions, and assembles the stiffness matrix by performing numerical calculations specific to the integration scheme chosen. The code segments utilize nested loops to compute the contributions to the stiffness matrix for each element based on its geometry and integration configuration, progressively updating the global stiffness matrix <code>K</code> with the calculated values.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Matlab data-lang=Matlab><span style=display:flex><span><span style=color:#66d9ef>for</span> i = <span style=color:#ae81ff>1</span>:size(matriz_de_incidencias, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>% ... calculations for x1, x2, y1, y2, c, c1, c2, c3, c4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Derivatives calculation</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Construction of matrix K with coordinate transformation and subsequent assembly</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> o = [c1,c2,c3,c4]  
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j = [c1,c2,c3,c4]
</span></span><span style=display:flex><span>            <span style=color:#75715e>% Calculation and assembly of stiffness matrix elements</span>
</span></span><span style=display:flex><span>            K(o,j) = K(o,j) <span style=color:#f92672>+</span> (<span style=color:#75715e>... stiffness matrix calculation ...) * k * w * (a(i)*b(i)/4);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p><a href=https://github.com/roaked/fem-math-formulation/blob/main/code/KGauss.m>For more information</a>&mldr;</p><h3 id=24-nodal-solution>2.4. Nodal Solution
<a class=anchor href=#24-nodal-solution>#</a></h3><p>Having obtained previously the global stiffness matrix <code>K</code>, it is necessary to obtain the global vector <code>F</code> in order to compute the nodal solution. Hence, the <a href=https://github.com/roaked/fem-math-formulation/blob/main/code/Loads.m>Loads function</a> is designed specifically to compute the global load vector <code>F</code> based on provided element properties and loading intensities.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-matlab data-lang=matlab><span style=display:flex><span>f = carregamentos(:, <span style=color:#ae81ff>2</span>);        <span style=color:#75715e>% Loading intensities for each element</span>
</span></span><span style=display:flex><span>F = zeros(n_nos, <span style=color:#ae81ff>1</span>);            <span style=color:#75715e>% Initializes a vector for the global load with zeros</span>
</span></span><span style=display:flex><span>fe = zeros(<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span>);               <span style=color:#75715e>% Initializes a vector for elemental loads with zeros</span>
</span></span></code></pre></div><p>It aims to calculate the nodal forces acting on a rectangular element system defined by the <code>matriz_de_incidencias</code> (incidence matrix), which denotes the nodes associated with each element. Each element has dimensions represented by <code>a</code> and <code>b</code> and is subjected to loading intensities specified in the <code>carregamentos</code> (loading) input.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-matlab data-lang=matlab><span style=display:flex><span><span style=color:#66d9ef>for</span> i = <span style=color:#ae81ff>1</span>:size(matriz_de_incidencias, <span style=color:#ae81ff>1</span>) <span style=color:#75715e>% Loop through elements</span>
</span></span><span style=display:flex><span>    c = matriz_de_incidencias(i, <span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>4</span>);     <span style=color:#75715e>% Nodes associated with the current element</span>
</span></span><span style=display:flex><span>    c1 = c(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);  <span style=color:#75715e>% Node #1 of the current element</span>
</span></span><span style=display:flex><span>    c2 = c(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>);  <span style=color:#75715e>% Node #2 of the current element </span>
</span></span><span style=display:flex><span>    c3 = c(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>);  <span style=color:#75715e>% Node #3 of the current element</span>
</span></span><span style=display:flex><span>    c4 = c(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>4</span>);  <span style=color:#75715e>% Node #4 of the current element</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Elemental load vector calculation</span>
</span></span><span style=display:flex><span>    fe(c1) = f(i) <span style=color:#f92672>*</span> a(i) <span style=color:#f92672>*</span> b(i) <span style=color:#f92672>/</span> <span style=color:#ae81ff>4</span>;  <span style=color:#75715e>% Contribution to node 1</span>
</span></span><span style=display:flex><span>    fe(c2) = f(i) <span style=color:#f92672>*</span> a(i) <span style=color:#f92672>*</span> b(i) <span style=color:#f92672>/</span> <span style=color:#ae81ff>4</span>;  <span style=color:#75715e>% Contribution to node 2</span>
</span></span><span style=display:flex><span>    fe(c3) = f(i) <span style=color:#f92672>*</span> a(i) <span style=color:#f92672>*</span> b(i) <span style=color:#f92672>/</span> <span style=color:#ae81ff>4</span>;  <span style=color:#75715e>% Contribution to node 3</span>
</span></span><span style=display:flex><span>    fe(c4) = f(i) <span style=color:#f92672>*</span> a(i) <span style=color:#f92672>*</span> b(i) <span style=color:#f92672>/</span> <span style=color:#ae81ff>4</span>;  <span style=color:#75715e>% Contribution to node 4</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Assembling the elemental load vector into the global load vector</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> o = [c1, c2, c3, c4]
</span></span><span style=display:flex><span>        F(o) = F(o) <span style=color:#f92672>+</span> fe(o);  <span style=color:#75715e>% Accumulating elemental loads to global loads</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>It is now possible to compute the nodal solution. Thus, the <a href=https://github.com/roaked/fem-math-formulation/blob/main/code/Solver.m>Solver function</a> in <code>MATLAB</code> is crucial. Initially, it computes the number of nodes without specified boundary conditions and initializes matrices for the reduced stiffness <code>Kred</code> and force <code>Fred</code> vectors.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-matlab data-lang=matlab><span style=display:flex><span><span style=color:#66d9ef>function</span> [solucao_nodal] = <span style=color:#a6e22e>Solver</span>(K, F, cfronteira, n_nos)
</span></span><span style=display:flex><span><span style=color:#75715e>% Function that computes nodal displacements</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>nos_scf = n_nos <span style=color:#f92672>-</span> length(cfronteira); <span style=color:#75715e>% Nodes without specified boundary conditions</span>
</span></span><span style=display:flex><span>Kred = zeros(nos_scf); <span style=color:#75715e>% Reduced stiffness matrix initialization</span>
</span></span><span style=display:flex><span>Fred = zeros(nos_scf, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>% Reduced force vector initialization</span>
</span></span><span style=display:flex><span>vaux = [];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>% Identifying nodes without boundary conditions</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> p = <span style=color:#ae81ff>1</span>:n_nos
</span></span><span style=display:flex><span>    o = find(cfronteira(:,<span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> p, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> isempty(o)
</span></span><span style=display:flex><span>        vaux = [vaux p]; <span style=color:#75715e>% Nodes without boundary conditions added to vaux</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>The reduced stifness matrix <code>Kred</code> is built by extracting elements from the global stiffness matrix <code>K</code> for nodes without specified boundary conditions. Whereas the reduced force vector <code>Fred</code> is determined using values from the global for vector <code>F</code> for nodes without boundary conditions.</p><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p><ul><li>Efficient Computation: the computation focuses only on the nodes without boundary conditions, allowing for a more efficient and targeted solution process.</li><li>Elimination of Redudancy: avoids unnecessary calculations for nodes where the displacements or forces are already known, optimizing the computational effort in solving for the unknowns (displacements).</li></ul><p>Fred and Kred are essential in simplifying the computation by isolating relevant forces and stiffness elements, respectively, pertaining to nodes without specified boundary conditions, leading to a more efficient and focused solution process in the finite element analysis.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Matlab data-lang=Matlab><span style=display:flex><span><span style=color:#75715e>% Building the reduced stiffness matrix Kred</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i = <span style=color:#ae81ff>1</span>:length(vaux)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> p = <span style=color:#ae81ff>1</span>:length(vaux)
</span></span><span style=display:flex><span>        Kred(i,p) = K(vaux(i), vaux(p)); <span style=color:#75715e>% Extracting elements for Kred from the global stiffness matrix K</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>% Constructing the reduced force vector Fred</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> z = <span style=color:#ae81ff>1</span>:length(vaux)
</span></span><span style=display:flex><span>    Fred(z, <span style=color:#ae81ff>1</span>) = F(vaux(z), <span style=color:#ae81ff>1</span>); <span style=color:#75715e>% Assigning values to Fred corresponding to nodes without boundary conditions</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>In the end, nodal displacements (psis) is obtained using matrix inversion (<span>
\(Kred^{-1} \times Fred\)
</span>) with the reduced stiffness matrix and force vector. The total solution vector (var <code>solucao_nodal</code>) is obtained by assigning computed displacements to their respective nodes, including those without specified boundary conditions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Matlab data-lang=Matlab><span style=display:flex><span><span style=color:#75715e>% Solving for nodal displacements using matrix inversion</span>
</span></span><span style=display:flex><span>psis = (Kred^<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> Fred; <span style=color:#75715e>% Nodal displacements computation</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>solucao_nodal = zeros(n_nos, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>% Initializing total solution vector</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>% Assigning computed displacements to respective nodes</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> z = <span style=color:#ae81ff>1</span>:length(vaux)
</span></span><span style=display:flex><span>    solucao_nodal(vaux(z)) = psis(z); <span style=color:#75715e>% Populating the total solution vector</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h3 id=25-torsion-coefficient>2.5. Torsion Coefficient
<a class=anchor href=#25-torsion-coefficient>#</a></h3><p>Further on, <a href=https://github.com/roaked/fem-math-formulation/blob/main/code/torsionconstantJ.m>function torsionconstantJ</a> computes the contributions of each finite element to <code>Je</code> (elemental torsion constant) and then sums these contributions to compute the total torsion constant <code>J</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Matlab data-lang=Matlab><span style=display:flex><span><span style=color:#66d9ef>function</span> [Je, J] = <span style=color:#a6e22e>torsionconstantJ</span>(solucao_nodal, a, b, n_elementos, matriz_de_incidencias )
</span></span><span style=display:flex><span><span style=color:#75715e>% Calculates contributions of each element for Je and computes the torsion constant J</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>J = <span style=color:#ae81ff>0</span>; <span style=color:#75715e>% Initialize total torsion constant J</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i = <span style=color:#ae81ff>1</span>:n_elementos <span style=color:#75715e>% Loop through all elements</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Calculate contribution Je for each element using the nodal solution</span>
</span></span><span style=display:flex><span>    Je(i) = <span style=color:#ae81ff>1</span><span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> a(i) <span style=color:#f92672>*</span> b(i) <span style=color:#f92672>*</span> (solucao_nodal(matriz_de_incidencias(i, <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>+</span> <span style=color:#75715e>...</span>
</span></span><span style=display:flex><span>        solucao_nodal(matriz_de_incidencias(i, <span style=color:#ae81ff>2</span>)) <span style=color:#f92672>+</span> solucao_nodal(matriz_de_incidencias(i, <span style=color:#ae81ff>3</span>)) <span style=color:#f92672>+</span> <span style=color:#75715e>...</span>
</span></span><span style=display:flex><span>        solucao_nodal(matriz_de_incidencias(i, <span style=color:#ae81ff>4</span>)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    J = J <span style=color:#f92672>+</span> Je(i); <span style=color:#75715e>% Accumulate contribution to the total torsion constant J</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h3 id=26-maximum-and-minimum-stresses>2.6. Maximum and Minimum Stresses
<a class=anchor href=#26-maximum-and-minimum-stresses>#</a></h3><p>Lastly, the <a href=https://github.com/roaked/fem-math-formulation/blob/main/code/Stresses.m>function Stresses</a> calculates the shear stress intensities (tensaoxy, tensaoxz, tensaoyz) for each element after initializing the variables.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-matlab data-lang=matlab><span style=display:flex><span><span style=color:#66d9ef>for</span> i = <span style=color:#ae81ff>1</span>:n_elementos
</span></span><span style=display:flex><span>    x = a(i) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>; <span style=color:#75715e>% X-coordinate of the element center</span>
</span></span><span style=display:flex><span>    y = b(i) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>; <span style=color:#75715e>% Y-coordinate of the element center</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Derivatives of the shape function with respect to x and y</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>% (df1y, df2y, df3y, df4y, df1x, df2x, df3x, df4x)</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Calculation of shear stresses using theoretical formulas</span>
</span></span><span style=display:flex><span>    tensaoxz(i) = (<span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> J) <span style=color:#f92672>*</span> (solucao_nodal(matriz_de_incidencias(i, <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>*</span> df1y <span style=color:#f92672>+</span> <span style=color:#75715e>...); % XZ shear stress</span>
</span></span><span style=display:flex><span>    tensaoyz(i) = (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> J) <span style=color:#f92672>*</span> (solucao_nodal(matriz_de_incidencias(i, <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>*</span> df1x <span style=color:#f92672>+</span> <span style=color:#75715e>...); % YZ shear stress</span>
</span></span><span style=display:flex><span>    tensaoxy(i) = sqrt(tensaoxz(i)^<span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> tensaoyz(i)^<span style=color:#ae81ff>2</span>); <span style=color:#75715e>% Absolute XY shear stress</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>After using <code>min</code> and <code>max</code> <code>MATLAB</code> functions, the maximum and minimum stresses are identified and the coordinates of the centers associated with these extreme stresses within the structural elements are also located.</p><h3 id=27-validation-based-on-book>2.7. Validation Based on Book
<a class=anchor href=#27-validation-based-on-book>#</a></h3><p>The developed program has been tested for a known problem described in the book <a href="https://books.google.at/books/about/An_Introduction_to_the_Finite_Element_Me.html?id=8gqnRwAACAAJ&amp;redir_esc=y">&ldquo;Introduction to the Finite Element Method (3rd edition)&rdquo; by J.N. Reddy</a> - <strong>Example 8.5.6</strong>. In this example, torsion of a square section bar was considered. As the problem is axisymmetric, nodal solution and shear stresses were calculated for a quarter of the square. The following results were obtained at the nodes for the nodal solution, using a 4x4 mesh:</p><span>\[\begin{bmatrix}
x & y & \text{Analytical} & \text{Gauss 2x2} & \text{Gauss 1x2} & \text{Gauss 1x1} & \text{Reddy} \\
0.0000 & 0.0000 & 0.1492 & 0.1492 & 0.1501 & 0.1513 & 0.1492 \\
0.1250 & 0.0000 & 0.1412 & 0.1412 & 0.1421 & 0.1429 & 0.1412 \\
0.2500 & 0.0000 & 0.1161 & 0.1161 & 0.1168 & 0.1176 & 0.1161 \\
0.3750 & 0.0000 & 0.0707 & 0.0707 & 0.0711 & 0.0714 & 0.0707 \\
0.1250 & 0.2500 & 0.1103 & 0.1103 & 0.1110 & 0.1116 & 0.1103 \\
0.2500 & 0.2500 & 0.0919 & 0.0919 & 0.0926 & 0.0935 & 0.0919 \\
0.3750 & 0.2500 & 0.0573 & 0.0573 & 0.0577 & 0.0580 & 0.0573 \\
\end{bmatrix}\]</span><p>The following results were obtained for <span>\(\bar{\tau_{yz}} = \frac{\tau_{yz}}{G\theta} = \tau_{yz} \times J\)
</span>for 4x4 mesh:</p><span>\[\begin{bmatrix}
x & y & \text{Analytical} & \text{Gauss 2x2} & \text{Gauss 1x2} & \text{Gauss 1x1} & \text{Known Sol.} \\
0.06250 & 0.0625 & 0.0618 & 0.0618 & 0.0621 & 0.0625 & 0.0618 \\
0.1875 & 0.0625 & 0.1942 & 0.1942 & 0.1955 & 0.1970 & 0.1939 \\
0.3125 & 0.0625 & 0.3529 & 0.3529 & 0.3553 & 0.3577 & 0.3516 \\
0.4375 & 0.0625 & 0.5528 & 0.5528 & 0.5560 & 0.5593 & 0.5504 \\
\end{bmatrix}\]</span><p>It&rsquo;s observed that stiffness matrices obtained through analytical integration or Gauss 2x2 are closely aligned with the known values. In fact, the values from analytical integration and Gauss 2x2 are identical when approximated to 4 decimal places. The fewer points used in the Gauss integration, the greater the error, with Gauss 1x1 showing the largest discrepancy between obtained and known values. The largest relative error found in analytical integration and Gauss 2x2 was 0.436%. For Gauss 1x2 integration, the largest relative error was 1.05%, while Gauss 1x1 integration showed the largest relative error of 1.73%. Overall, the values are close to the known ones, indicating that the developed program is functioning correctly.</p><h2 id=3-comparison-with-fem-commercial-software-siemens-nx>3 Comparison with FEM commercial software Siemens NX
<a class=anchor href=#3-comparison-with-fem-commercial-software-siemens-nx>#</a></h2><p>In addition, the problem was tackled by resorting to the commercial software NX, which unfortunately lacks a dedicated solver for torsion problems. As a workaround, the issue was addressed using the <em>Sol 153 solver – Steady State Nonlinear Heat Transfer</em>. This approach was selected due to the analogy between torsion and heat problems. Specific conditions were applied, including setting a boundary temperature at T = 0°C, introducing a uniform heat generation of 2 W/m³ throughout the section, and assigning a thermal conductivity value of K = 1 to the material. To compare results, the Prandtl function was solved using different integration methods in Matlab against the outcomes obtained through NX.</p><p>The data from the upcoming tables indicates that the minimum error occurs in the analytical integration type and in the numerical integration type with 2x2 Gauss points. As observed in the known problem, the error values are identical for these two integration types. It&rsquo;s worth noting that in the 1x1 Gauss points integration, there is a considerable relative error percentage (15.2%), which decreases in the case of 2x1 (8.6%) and 1x2 Gauss points (4.84%)</p><h3 id=31-analytical-integration>3.1. Analytical Integration
<a class=anchor href=#31-analytical-integration>#</a></h3><p><strong>Maximum error deviation</strong>: 3,99501E-06%</p><h3 id=32-gauss-integration-2x2>3.2. Gauss Integration 2x2
<a class=anchor href=#32-gauss-integration-2x2>#</a></h3><p><strong>Maximum error deviation</strong>: 3,99501E-06 %</p><h3 id=33-gauss-integration-2x1>3.3. Gauss Integration 2x1
<a class=anchor href=#33-gauss-integration-2x1>#</a></h3><p><strong>Maximum error deviation</strong>: 8,605963869 %</p><h3 id=34-gauss-integration-1x2>3.4. Gauss Integration 1x2
<a class=anchor href=#34-gauss-integration-1x2>#</a></h3><p><strong>Maximum error deviation</strong>: 4,839239833 %</p><h3 id=35-gauss-integration-1x1>3.5. Gauss Integration 1x1
<a class=anchor href=#35-gauss-integration-1x1>#</a></h3><p><strong>Maximum error deviation</strong>: 15,19098164 %</p><h3 id=36-torsion-coefficients-nx-vs-matlab>3.6. Torsion Coefficients NX vs. Matlab
<a class=anchor href=#36-torsion-coefficients-nx-vs-matlab>#</a></h3><p>The nodal solution values, node positions, and connectivity matrix data in NX were used to compute the torsion constant, J, akin to the calculations performed for J in the analytical or Gauss integrations in Matlab.</p><p>Calculating the value of J for various refinements yielded:</p><span>\[\begin{bmatrix}
\text{Number of nodes} & J \text{computed from NX} (m^4) \\
96 & 6.11911850 \times 10^{-5} \\
234 & 6.85679916 \times 10^{-5} \\
600 & 7.06099102 \times 10^{-5} \\
1765 & 7.13958341 \times 10^{-5} \\
4720 & 7.16633419 \times 10^{-5} \\
41461 & 7.18205027 \times 10^{-5} \\
\end{bmatrix}\]</span><p>For the considered 96 nodes:</p><span>\[\begin{bmatrix}
\text{J NX} (m^4) & \text{J Matlab} (m^4) & \text{Relative Error} (\%) \\
6.1191185 \times 10^{-5} & 6.11890982 \times 10^{-5} & 3.41041 \times 10^{-3} \\
\end{bmatrix}\]</span><p>The conclusion drawn from these findings is that as the mesh undergoes refinement, the constant torsion value J tends to stabilize. It&rsquo;s evident from these results that the approximation done by Matlab remains quite acceptable. This is highlighted by the fact that the J value derived from Matlab aligns closely with the analytical integration value and is also in close proximity to the J value computed in NX for 96 nodes, which itself approximates the converged value.</p><h3 id=37-max-and-min-stresses-nx-vs-matlab>3.7. Max and Min Stresses NX vs. Matlab
<a class=anchor href=#37-max-and-min-stresses-nx-vs-matlab>#</a></h3><span>\[\begin{bmatrix}
\text{Stresses} & \text{Matlab} & \text{NX} & \text{Relative Error} (\%) \\
\text{Maximum (Pa)} & 1279.447 & 1279.404 & 3.40677E-03 \\
\text{Minimum (Pa)} & 25.790852 & 25.789972 & 3.41135E-03 \\
\end{bmatrix}\]</span><p>The comparison between the results from Matlab (analytical integration) and NX led to the conclusion that quite satisfactory outcomes were attained. It was observed that the relative error obtained for the extreme values falls within the order of <span>\(10^{-3}\)
</span>in percentage.</p><h3 id=38-results-siemens-nx>3.8. Results Siemens NX
<a class=anchor href=#38-results-siemens-nx>#</a></h3><p>The initial mesh comprises 96 nodes. The mesh underwent 5 refinements to analyze the convergence of values. The results for the temperature distribution and gradient distribution are presented below for the six meshes, respectively on the left and right sides.</p><details><summary><strong>Meshing in NX Siemens:</strong> Initial Mesh - (click to expand)</summary><div class=markdown-inner><img src=https://live.staticflickr.com/65535/53347732682_2ea88fae5e_n.jpg alt=sddst></div></details><p>Lastly, the 41468 nodes are represented for the final mesh refinement.</p><details><summary><strong>Meshing in NX Siemens:</strong> Final Mesh - (click to expand)</summary><div class=markdown-inner><img src=https://live.staticflickr.com/65535/53349056300_d5a49424b2_z.jpg alt=sdasdaddst></div></details><h3 id=39-results-matlab>3.9. Results MATLAB
<a class=anchor href=#39-results-matlab>#</a></h3><p>When the program is executed, it generates several figures such as the mesh representation with numbered elements and nodes, the contour lines representing stress, and the display of shear stresses with their respective distribution.</p><ul><li><strong>Elements and Nodes of the Mesh</strong></li></ul><p><img src=https://live.staticflickr.com/65535/53349066455_9f29d491fa.jpg alt=sdasdsssaddst></p><ul><li><strong>Shear Stress Ditribution</strong></li></ul><p><img src=https://live.staticflickr.com/65535/53348939254_05f55130fc.jpg alt=sdasdssdadassaddst></p><ul><li><strong>Shear Stress Contour Plot</strong></li></ul><p><img src=https://live.staticflickr.com/65535/53348616926_9b32186f03.jpg alt=sdasdsasdasdadassaddst></p><ul><li><strong>Nodal Solution: Analytical Integration</strong></li></ul><p><img src=https://live.staticflickr.com/65535/53347742997_a52836da0d_w.jpg alt=sdasdsasdasdsdadassaddst></p><ul><li><strong>Isometric View: Stress Isolines</strong></li></ul><p><img src=https://live.staticflickr.com/65535/53348939259_279f7d009e_w.jpg alt=sdasdsasdasdsdadassdssaddst></p><p>The nodal solution values, distribution of shear stresses, value of J, and torsional stiffness were, in addition, also obtained from the analytical integration, as reported.</p><ul><li>Minimum stress of 1.28<span>
\(\times 10^{3}\)
</span>Pa: (x,y) = (2.0<span>
\(\times 10^{-1}\)
</span>, 1.1<span>
\(\times 10^{-1}\)
</span>) m</li><li>Minimum stress of 2.58<span>
\(\times 10^{1}\)
</span>Pa: (x,y) = (2.4<span>
\(\times 10^{-1}\)
</span>, 9.0<span>
\(\times 10^{-2}\)
</span>) m</li><li>Torsion cofficient J: 6.11<span>
\(\times 10^{-5} Pa \cdot m^4\)</span></li><li>Torsional stiffness GJ: 4.65<span>
\(\times 10^{6} Pa \cdot m^4\)</span></li></ul><p>To calculate GJ, the torsional stiffness, simply multiply the torsion coefficient J by the shear modulus, typically around 76 GPa.</p><h2 id=4-my-considerations>4 My Considerations
<a class=anchor href=#4-my-considerations>#</a></h2><p>While the current analysis has demonstrated promising alignment between the NX and Matlab outputs, future endeavours could focus on enhancing the model&rsquo;s precision and expanding its applicability.</p><p>The reason for choosing MATLAB over other programming languages was mainly due to the fact that at this time I was most proficient with using MATLAB &ndash; not being so confident in my skills in regards to other languages. Nonetheless, while developing the Finite Element Method (FEM) software in MATLAB, I encountered several limitations that made me reconsider the choice of programming language. MATLAB, with its user-friendly environment and extensive libraries, initially seemed suitable for rapid prototyping and algorithm testing. However, as the project progressed, certain factors became evident that might have been better addressed using alternatives such as: C++.</p><p>MATLAB&rsquo;s interpreted nature, though convenient for quick code iterations, posed performance concerns as the simulations scaled. The compiled nature of C++ would have offered better performance optimization, crucial for handling large datasets and computationally intensive FEM calculations. Control over memory management and low-level operations in C++ would have allowed for fine-tuning algorithms and achieving higher efficiency in handling complex simulations.</p><p>Moreover, MATLAB&rsquo;s portability requirements often necessitated the distribution of MATLAB Runtime or Compiler for deployment on other systems (let alone requirements). In contrast, C++ offers inherent portability, allowing for easier cross-platform compatibility without additional runtime dependencies.</p><p>While MATLAB&rsquo;s user-friendliness is remarkable (honestly, most people should implement it and surely would rise up to the same outcome), after a brief web searching, I found that dedicated FEM libraries in C++, such as deal.II, DUNE, and libMesh, provide specialized tools for FEM simulations, offering robust solvers, mesh generation capabilities, and a community-driven framework specifically tailored for such applications. Are they really capable? I am not sure.</p><p>In retrospect, considering the computational demands, performance optimizations, and scalability required for the FEM software, implementing it in C++ might have offered a more efficient and scalable solution, despite MATLAB&rsquo;s initial ease of use, adequacy to simple cases and rapid development capabilities.</p><p>However&mldr;</p><p>Instead of embarking on independent software development, I also explored alternative avenues. For instance, my experience with electron beam technology highlighted the crucial need for simulating phenomena within a vacuum chamber &ndash; extremely low pressures. I discovered existing Software Development Kits tailored precisely for this purpose. Prominent software packages like ANSYS and COMSOL Multiphysics offer simulations that encompass this specific phenomenon.</p><p>This approach would have potentially offered a balanced solution, combining the advantages of a robust, commercially supported framework with the customization required for such project. However, it&rsquo;s essential to consider licensing costs and the level of customization achievable within the confines of these SDKs compared to developing from scratch in MATLAB or C++. As obviously, you are somehow restricted..</p><h2 id=5-future-work>5 Future Work
<a class=anchor href=#5-future-work>#</a></h2><p>As for attempting to improve my MATLAB model, I would probably steer in the following direction:</p><blockquote class="book-hint2 example"><p class="hint-title example"><svg class="book-icon"><use href="/svg/hint-icons.svg#example-notice"/></svg><span>example</span></p><p><strong>Validation with Experimental Data</strong>: Conducting experiments or obtaining real-world data to validate the computational findings could strengthen the model&rsquo;s reliability.</p><p><strong>Complex Geometries and Material Variations</strong>: Expanding the study to encompass more complex geometries and diverse material properties can broaden the application scope of the torsion problem solution.</p><p><strong>Parametric Studies</strong>: Conducting parametric studies to evaluate the impact of various parameters (such as material properties, dimensions, or loading conditions) on the torsional behavior can provide deeper insights.</p><p><strong>Integration of Advanced Techniques</strong>: Exploring the integration of advanced numerical methods or simulation techniques could improve the computational efficiency and accuracy of the analysis.</p></blockquote><h2 id=6-attachments>6 Attachments
<a class=anchor href=#6-attachments>#</a></h2><p><code>Main script:</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Matlab data-lang=Matlab><span style=display:flex><span><span style=color:#75715e>%</span>
</span></span><span style=display:flex><span><span style=color:#75715e>%</span>
</span></span><span style=display:flex><span><span style=color:#75715e>%Ricardo Chin</span>
</span></span><span style=display:flex><span><span style=color:#75715e>%</span>
</span></span><span style=display:flex><span><span style=color:#75715e>%</span>
</span></span><span style=display:flex><span><span style=color:#75715e>%</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>clc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fprintf(<span style=color:#e6db74>&#39;\nFormulating a Finite Element Analysis Model\n&#39;</span>);
</span></span><span style=display:flex><span>fprintf(<span style=color:#e6db74>&#39;This program solves torsion problems of prismatic bars.\n&#39;</span>);
</span></span><span style=display:flex><span>nome = input(<span style=color:#e6db74>&#39;Enter the data file name (&#34;name.txt&#34;): \n&#39;</span>,<span style=color:#e6db74>&#39;s&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[n_nos,matriz_dos_nos,n_elementos,matriz_de_incidencias,n_propriedades,<span style=color:#75715e>...</span>
</span></span><span style=display:flex><span>    propriedades,n_carregamentos,carregamentos,n_cfront,cfronteira,n_pontual,pontual,<span style=color:#75715e>...</span>
</span></span><span style=display:flex><span>    n_fluxofront,fluxofront,n_convec,convec,a,b,nome,matriz_aux] = DataReading(nome);
</span></span><span style=display:flex><span><span style=color:#75715e>% Call function DataReading</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>aviso = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> n_pontual <span style=color:#f92672>~=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e>% if there are point loads</span>
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;\nWarning! The data file contains imposed point sources/loads!\n&#39;</span>);
</span></span><span style=display:flex><span>    aviso = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> n_fluxofront <span style=color:#f92672>~=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e>% if there is flux at the boundary</span>
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;\nWarning! The data file contains imposed flux at the boundary!\n&#39;</span>);
</span></span><span style=display:flex><span>    aviso = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> n_convec <span style=color:#f92672>~=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e>% if there is imposed natural convection</span>
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;\nWarning! The data file contains imposed natural convection!\n&#39;</span>);
</span></span><span style=display:flex><span>    aviso = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> aviso <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;There are invalid boundary conditions for the torsion problem!\n&#39;</span>);
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;Invalid boundary conditions will be ignored by the program.\n&#39;</span>);
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;It is suggested to terminate the program and change the values.\n&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i = <span style=color:#ae81ff>1</span>:n_carregamentos <span style=color:#75715e>%% loops up to the number of loads</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> carregamentos(i,<span style=color:#ae81ff>2</span>) <span style=color:#f92672>~=</span>  <span style=color:#ae81ff>2</span> <span style=color:#75715e>% if load is different from 2</span>
</span></span><span style=display:flex><span>        fprintf(<span style=color:#e6db74>&#39;\nWarning! Distributed loads are not suitable for the torsion problem!\n&#39;</span>);
</span></span><span style=display:flex><span>        fprintf(<span style=color:#e6db74>&#39;It is suggested to terminate the program and change the load values to 2.\n&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i = <span style=color:#ae81ff>1</span>:n_cfront <span style=color:#75715e>% loops up to the number of nodes with boundary condition</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> cfronteira(i,<span style=color:#ae81ff>2</span>) <span style=color:#f92672>~=</span>  <span style=color:#ae81ff>0</span> <span style=color:#75715e>% if boundary condition is different from 0</span>
</span></span><span style=display:flex><span>        fprintf(<span style=color:#e6db74>&#39;\nWarning! The boundary conditions are invalid for the torsion problem!\n&#39;</span>);
</span></span><span style=display:flex><span>        fprintf(<span style=color:#e6db74>&#39;The imposed psis at the boundary must be equal to zero.\n&#39;</span>)
</span></span><span style=display:flex><span>        fprintf(<span style=color:#e6db74>&#39;It is suggested to terminate the program and change the values.\n&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> propriedades(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>) <span style=color:#f92672>~=</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e>% if property k is not 1</span>
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;\nWarning! The material property is not suitable for the torsion problem!\n&#39;</span>);
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;It is suggested to terminate the program and change the property value to 1.\n&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> n_carregamentos <span style=color:#f92672>~=</span> n_elementos <span style=color:#75715e>% if the number of loads does not equal the number of elements</span>
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;\nWarning! There are elements without applied distributed loads!\n&#39;</span>);
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;It is suggested to terminate the program and modify the data file.\n&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mesh_display(n_nos,n_elementos,matriz_dos_nos,matriz_de_incidencias,a,b)
</span></span><span style=display:flex><span><span style=color:#75715e>%plots of mesh with nodes and elements</span>
</span></span><span style=display:flex><span>hold on
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>selec = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>resolvido = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (selec <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Waiting.....</span>
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;\nChoose an option, starting with the type of integration:\n&#39;</span>);
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;1: Analytical Integration\n&#39;</span>);
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;2: Numerical Integration - Gauss 2x2\n&#39;</span>);
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;3: Reduced Integration - Gauss 2x1\n&#39;</span>);
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;4: Reduced Integration - Gauss 1x2\n&#39;</span>);
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;5: Reduced Integration - Gauss 1x1\n&#39;</span>);
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;6: Obtain Prandtl solution, shear stresses, and stress contour plots\n&#39;</span>);
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;7: Replot the mesh\n&#39;</span>);
</span></span><span style=display:flex><span>    fprintf(<span style=color:#e6db74>&#39;0: Exit the program\n&#39;</span>);
</span></span><span style=display:flex><span>    opcao = input(<span style=color:#e6db74>&#39;&#39;</span>);
</span></span><span style=display:flex><span>    valido = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span>(opcao)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span>{<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>,<span style=color:#ae81ff>7</span>}
</span></span><span style=display:flex><span>            valido=<span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(valido<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        fprintf(<span style=color:#e6db74>&#39;\nERROR! Invalid option!\n&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>switch</span>(opcao) <span style=color:#75715e>%Interface integration options</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span>{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> opcao<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>           [K] = KAnalitico(matriz_de_incidencias,n_nos,a,b,propriedades);          
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>           [K] = KGauss(opcao, matriz_de_incidencias, n_nos, a, b, propriedades); 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        tipoint = opcao;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        [F] = Loads(matriz_de_incidencias,n_nos,a,b,carregamentos );
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        [solucao_nodal] = Solver(K,F,cfronteira,n_nos);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        [Je, J] = torsionconstantJ(solucao_nodal,a,b,n_elementos,matriz_de_incidencias);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        [centro_max,centro_min,tensao_max,tensao_min,tensaoxy,tensaoxz,tensaoyz] = Stresses(n_elementos, matriz_dos_nos, matriz_de_incidencias,a,b,J,solucao_nodal);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        resolvido = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        fprintf(<span style=color:#e6db74>&#39;\nIntegration completed. Choose the next option:\n&#39;</span>);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span>{<span style=color:#ae81ff>6</span>} <span style=color:#75715e>% Displays plots after integration type is chosen</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> resolvido<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            fprintf(<span style=color:#e6db74>&#39;\nError! No integration has been performed yet!\n&#39;</span>);
</span></span><span style=display:flex><span>            fprintf(<span style=color:#e6db74>&#39;Choose an integration type (1, 2, 3, 4, or 5) first.\n&#39;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>           
</span></span><span style=display:flex><span>            graph_Prandtl(solucao_nodal,n_nos,matriz_dos_nos,tipoint)
</span></span><span style=display:flex><span>            hold on
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>            [centroX, centroY] = graph_shear_stresses(a,b,matriz_de_incidencias,matriz_dos_nos,n_elementos,tensaoxz,tensaoyz,tipoint);
</span></span><span style=display:flex><span>            hold on
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>            stress_contour_plots(n_elementos,matriz_dos_nos,centroX,centroY,tensaoxy,n_nos,tipoint)
</span></span><span style=display:flex><span>            hold on
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            fprintf(<span style=color:#e6db74>&#39;\nPlots obtained. Choose the next option:\n&#39;</span>);    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span>{<span style=color:#ae81ff>7</span>} <span style=color:#75715e>% Displays the mesh plot if the user wants</span>
</span></span><span style=display:flex><span>        figure
</span></span><span style=display:flex><span>        mesh_display(n_nos,n_elementos,matriz_dos_nos,matriz_de_incidencias,a,b)
</span></span><span style=display:flex><span>        hold on
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        fprintf(<span style=color:#e6db74>&#39;\nMesh plot obtained. Choose the next option:\n&#39;</span>);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span>{<span style=color:#ae81ff>0</span>} <span style=color:#75715e>% Option to terminate the program</span>
</span></span><span style=display:flex><span>        selec=<span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        fprintf(<span style=color:#e6db74>&#39;\n\nProgram terminated.\n&#39;</span>);             
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>aux1(matriz_aux,n_elementos,tensaoxz,tensaoyz,tensaoxy,tensao_max,tensao_min,centro_max,J,centro_min,centroX,centroY)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>clear i selec valido resolvido warning matriz_aux;
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/roaked/roaked.github.io/commit/f08208156f40a7b016c7154801b33130b432e18f title='Last modified by roaked | December 15, 2023' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>December 15, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/roaked/roaked.github.io/edit/main/content/content/docs/design/finite-element-method-development/_index.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Ricardo Chin</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#1-diy-a-fea-playground>1 DIY: A FEA Playground</a><ul><li><a href=#11-partial-differential-equations-pdes>1.1. Partial Differential Equations (PDEs)</a></li><li><a href=#12-problem-formulation>1.2. Problem Formulation</a></li><li><a href=#13-analytical-integration>1.3. Analytical Integration</a></li><li><a href=#14-numerical-integration>1.4. Numerical Integration</a></li><li><a href=#15-torsional-constant>1.5. Torsional Constant</a></li><li><a href=#16-shear-stresses>1.6. Shear Stresses</a></li></ul></li><li><a href=#2-matlab-time-for-some-coding>2 MATLAB: Time for some coding!</a><ul><li><a href=#21-read_memd>2.1. READ_ME.md</a></li><li><a href=#22-analytical-integration>2.2. Analytical Integration</a></li><li><a href=#23-gauss-integration>2.3. Gauss Integration</a></li><li><a href=#24-nodal-solution>2.4. Nodal Solution</a></li><li><a href=#25-torsion-coefficient>2.5. Torsion Coefficient</a></li><li><a href=#26-maximum-and-minimum-stresses>2.6. Maximum and Minimum Stresses</a></li><li><a href=#27-validation-based-on-book>2.7. Validation Based on Book</a></li></ul></li><li><a href=#3-comparison-with-fem-commercial-software-siemens-nx>3 Comparison with FEM commercial software Siemens NX</a><ul><li><a href=#31-analytical-integration>3.1. Analytical Integration</a></li><li><a href=#32-gauss-integration-2x2>3.2. Gauss Integration 2x2</a></li><li><a href=#33-gauss-integration-2x1>3.3. Gauss Integration 2x1</a></li><li><a href=#34-gauss-integration-1x2>3.4. Gauss Integration 1x2</a></li><li><a href=#35-gauss-integration-1x1>3.5. Gauss Integration 1x1</a></li><li><a href=#36-torsion-coefficients-nx-vs-matlab>3.6. Torsion Coefficients NX vs. Matlab</a></li><li><a href=#37-max-and-min-stresses-nx-vs-matlab>3.7. Max and Min Stresses NX vs. Matlab</a></li><li><a href=#38-results-siemens-nx>3.8. Results Siemens NX</a></li><li><a href=#39-results-matlab>3.9. Results MATLAB</a></li></ul></li><li><a href=#4-my-considerations>4 My Considerations</a></li><li><a href=#5-future-work>5 Future Work</a></li><li><a href=#6-attachments>6 Attachments</a></li></ul></nav></div></aside></main></body></html>