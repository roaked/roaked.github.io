<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Hamiltonian Graphs: Connectivity Revolution # 1 Simulation and Analysis of Graph Path Selection # Graph theory serves as a fundamental framework for modeling and understanding various systems across scientific domains. This study presents a detailed computational simulation implemented in Fortran, focusing on the manipulation, selection, and analysis of paths and individual entities within a graph. The simulation involves stepwise operations, including path creation, criteria-based selection, and the identification of Hamiltonian paths."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="Fortran: Hamiltonian Graphs"><meta property="og:description" content="Hamiltonian Graphs: Connectivity Revolution # 1 Simulation and Analysis of Graph Path Selection # Graph theory serves as a fundamental framework for modeling and understanding various systems across scientific domains. This study presents a detailed computational simulation implemented in Fortran, focusing on the manipulation, selection, and analysis of paths and individual entities within a graph. The simulation involves stepwise operations, including path creation, criteria-based selection, and the identification of Hamiltonian paths."><meta property="og:type" content="article"><meta property="og:url" content="https://xsleaks.dev/docs/2code/7cp/hamiltonian/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-12-03T17:02:56+01:00"><title>Fortran: Hamiltonian Graphs | Ricardo Chin</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.b74e85bd7803de00c09a320dcf09ae0d7e37702a9918995f5fe9d1c71c55a223.css integrity="sha256-t06FvXgD3gDAmjINzwmuDX43cCqZGJlfX+nRxxxVoiM=" crossorigin=anonymous><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-10WQY47KS2"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-10WQY47KS2",{anonymize_ip:!1})}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Ricardo Chin</span></a></h2><ul><li class=book-section-flat><a href=/docs/1design/>Design Portfolio</a><ul><li><a href=/docs/1design/1mest/>FEA Beam Instability Modes</a><ul></ul></li><li><a href=/docs/1design/2thermo/>ThermoCup</a><ul></ul></li><li><a href=/docs/1design/3pmec/>Industrial Crane Design</a><ul></ul></li><li><a href=/docs/1design/4mcomp/>FEM Package Development</a><ul></ul></li><li><a href=/docs/1design/5om/>Car Transmission Design</a><ul></ul></li><li><a href=/docs/1design/6ebw/>Electron Beam Technology</a><ul></ul></li><li><a href=/docs/1design/7fst/>Formula Student Lisbon</a><ul></ul></li></ul></li><li class=book-section-flat><a href=/docs/2code/>Coding Portfolio</a><ul><li><a href=/docs/2code/1drone/>UAV Red Bull Air Racing</a><ul><li><a href=/docs/2code/1drone/_index2/>Drone Dynamics</a></li><li><a href=/docs/2code/1drone/_index3/>Drone Controller Design Pt. 1</a></li><li><a href=/docs/2code/1drone/_index4/>Drone Controller Design Pt. 2</a></li><li><a href=/docs/2code/1drone/_index5/>Drone Computer Vision</a></li></ul></li><li><a href=/docs/2code/2is/>AGV: System Identification</a><ul></ul></li><li><a href=/docs/2code/3si/>Deep Learning on Fake News</a><ul></ul></li><li><a href=/docs/2code/5od/>EC Optimization: Space & Time</a><ul><li><a href=/docs/2code/5od/_index2/>Genetic Algorithm</a></li><li><a href=/docs/2code/5od/_index3/>Particle Swarm Optimization</a></li></ul></li><li><a href=/docs/2code/6au/>Sardine FAB E2E Automation</a><ul></ul></li><li><a href=/docs/2code/7cp/hamiltonian/ class=active>Fortran: Hamiltonian Graphs</a></li><li><a href=/docs/2code/8snake/>Snake Game: Genetic RL-DQN</a><ul></ul></li><li><a href=/docs/2code/9cod/>PyBaMM-ML EV Battery Status</a><ul></ul></li></ul></li><li class=book-section-flat><a href=/docs/mod/>Website Modifications</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Fortran: Hamiltonian Graphs</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#1-simulation-and-analysis-of-graph-path-selection>1 Simulation and Analysis of Graph Path Selection</a></li><li><a href=#2-theoretical-considerations>2 Theoretical Considerations</a></li><li><a href=#3-code-implementation>3 Code Implementation</a><ul><li><a href=#31-methodology>3.1. Methodology</a></li><li><a href=#32-modules>3.2. Modules</a></li><li><a href=#33-simulation-steps>3.3. Simulation Steps</a></li></ul></li><li><a href=#4-discussion-and-efficiency>4 Discussion and Efficiency</a></li></ul></nav></aside></header><article class=markdown><h1 id=hamiltonian-graphs-connectivity-revolution><strong>Hamiltonian Graphs: Connectivity Revolution</strong>
<a class=anchor href=#hamiltonian-graphs-connectivity-revolution>#</a></h1><p><img src="https://community.wolfram.com/c/portal/getImageAttachment?filename=sadasdewrhfggjgdfsg423567.gif&amp;userId=11733" alt=202></p><h2 id=1-simulation-and-analysis-of-graph-path-selection>1 Simulation and Analysis of Graph Path Selection
<a class=anchor href=#1-simulation-and-analysis-of-graph-path-selection>#</a></h2><p>Graph theory serves as a fundamental framework for modeling and understanding various systems across scientific domains. This study presents a detailed computational simulation implemented in Fortran, focusing on the manipulation, selection, and analysis of paths and individual entities within a graph. The simulation involves stepwise operations, including path creation, criteria-based selection, and the identification of Hamiltonian paths. Through this process, the efficacy of Fortran in managing graph structures is explored and analyzed.</p><h2 id=2-theoretical-considerations>2 Theoretical Considerations
<a class=anchor href=#2-theoretical-considerations>#</a></h2><p>Graph theory plays a pivotal role in various scientific and computational domains, offering insights into network structures and paths. This project focuses on a computational simulation implemented in Fortran, a programming language renowned for its numerical computation capabilities, to explore graph path selection and manipulation.</p><h2 id=3-code-implementation>3 Code Implementation
<a class=anchor href=#3-code-implementation>#</a></h2><h3 id=31-methodology>3.1. Methodology
<a class=anchor href=#31-methodology>#</a></h3><p>This study utilizes three essential Fortran modules — <code>msoup</code>, <code>mind</code>, and <code>mpath</code> — each contributing critical functionalities to the overall simulation process.</p><h3 id=32-modules>3.2. Modules
<a class=anchor href=#32-modules>#</a></h3><ul><li><code>msoup</code> module</li></ul><p>The <code>msoup</code> module in this Fortran implementation serves as a robust framework for managing a collection of individuals, each representing a specific path within a graph structure. At its core, this module encapsulates a soup type, acting as a container for these individuals, and a node type, serving as the building block for storing individual references.</p><p>Within the <code>msoup</code> module, the soup type comprises pointers to the first and last individuals in the collection (<code>fst</code> and <code>lst</code>), alongside an integer count (<code>ln</code>) indicating the number of individuals present. This structure offers an organized and efficient means to handle and manipulate these individuals.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#66d9ef>type</span>, <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>::</span> soup
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(node), <span style=color:#66d9ef>pointer</span> <span style=color:#66d9ef>::</span> fst <span style=color:#75715e>! Points to the first individual of path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>type</span>(node), <span style=color:#66d9ef>pointer</span> <span style=color:#66d9ef>::</span> lst <span style=color:#75715e>! Points to the last individual of path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>integer</span> <span style=color:#66d9ef>::</span> ln <span style=color:#75715e>! Number of vertices (length) of path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>end</span> <span style=color:#66d9ef>type</span> soup
</span></span></code></pre></div><p>Individuals themselves are represented as instances of the node type. Each node stores a reference to an individual (<code>ind</code>) and a pointer to the next individual (<code>next</code>) within the collection. This linked structure allows for easy addition, removal, and traversal of individuals within the soup.</p><p>Functionally, the <code>msoup</code> module provides essential procedures:</p><ul><li><code>newS()</code> initializes an empty soup, setting pointers to null() and the individual count to zero.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#66d9ef>function</span> newS() <span style=color:#66d9ef>result</span>(s)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(soup) <span style=color:#66d9ef>::</span> s
</span></span><span style=display:flex><span>    s%fst <span style=color:#f92672>=&gt;</span> null() <span style=color:#75715e>! Set the first individual pointer to null
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    s%lst <span style=color:#f92672>=&gt;</span> null() <span style=color:#75715e>! Set the last individual pointer to null
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    s%ln <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e>! Initialize the count of individuals to zero
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>end</span> <span style=color:#66d9ef>function</span> newS
</span></span></code></pre></div><ul><li><code>insertS()</code> adds an individual to the soup by creating a new node, associating it with the provided individual, and updating pointers accordingly.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#66d9ef>subroutine</span> insertS(i, s)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(ind), <span style=color:#66d9ef>intent</span>(in) <span style=color:#66d9ef>::</span> i
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(soup), <span style=color:#66d9ef>intent</span>(inout) <span style=color:#66d9ef>::</span> s
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span>(node), <span style=color:#66d9ef>pointer</span> <span style=color:#66d9ef>::</span> aux
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>allocate</span>(aux)
</span></span><span style=display:flex><span>    aux%ind <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (s%ln <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        s%lst%next <span style=color:#f92672>=&gt;</span> aux <span style=color:#75715e>! Link the new node to the last node
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        s%fst <span style=color:#f92672>=&gt;</span> aux <span style=color:#75715e>! Update the first node if the soup is empty
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>if</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    s%lst <span style=color:#f92672>=&gt;</span> aux <span style=color:#75715e>! Update the last node to the newly added node
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    s%ln <span style=color:#f92672>=</span> s%ln <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e>! Increment the count of individuals
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>end</span> <span style=color:#66d9ef>subroutine</span> insertS
</span></span></code></pre></div><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p><p>To acess the 1st, last and count of individuals in the soup:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#75715e>! Accessing the first individual in the soup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>individual_1 <span style=color:#f92672>=</span> sp%fst%ind
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>! Accessing the last individual in the soup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>individual_last <span style=color:#f92672>=</span> sp%lst%ind
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>! Accessing the count of individuals in the soup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>number_of_individuals <span style=color:#f92672>=</span> sp%ln
</span></span></code></pre></div></blockquote><ul><li><p><code>nextS()</code> identifies pairs of individuals with compatible paths, computing the shortest distance between them, and returning these individuals along with a success indicator.</p></li><li><p><code>takeS()</code> removes a specified individual from the soup, adjusting pointers and deallocating the node.</p></li><li><p><code>an_indS()</code> retrieves a random individual from the soup, likely accessing the first individual&rsquo;s path.</p></li><li><p><code>emptyS()</code> checks if the soup is empty by examining the association of pointers.</p></li><li><p><code>sizeS()</code> returns the count of individuals in the soup.</p></li><li><p><code>showS()</code> displays details of all individuals in the soup, including their coordinates and paths.</p></li><li><p><code>mind</code> module</p></li></ul><p>The <code>mind</code> module handles the characteristics of individual entities (<code>ind</code>). It encapsulates their spatial coordinates and associated paths. This module includes functionalities for creating individuals, accessing their coordinates, calculating distances between them, and determining their equality.</p><ul><li><code>mpath</code> module</li></ul><p>The <code>mpath</code> module deals with representing paths within the graph structure. It defines the path data structure and includes various procedures for path creation, manipulation, and analysis, such as determining the first and last elements, checking compatibility between paths, and displaying paths.</p><h3 id=33-simulation-steps>3.3. Simulation Steps
<a class=anchor href=#33-simulation-steps>#</a></h3><ul><li><p>Step 0: Initialization: User-defined parameters and data structure initialization.</p></li><li><p>Step 1: Hybridization: Creation of random edges and path generation within the soup.</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#66d9ef>do</span> c6<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, nu
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>call</span> nextS(sp, i1, i2, sb)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>call</span> pathI(i1, w1)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>call</span> pathI(i2, w2)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>call</span> glueP(w1, w2, w3)
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span> <span style=color:#66d9ef>do</span>
</span></span></code></pre></div><ul><li>Steps 2-4: Selection of Paths: Criteria-based filtering and selection of paths.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fortran data-lang=fortran><span style=display:flex><span><span style=color:#66d9ef>do</span> c9<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, no
</span></span><span style=display:flex><span>    eln <span style=color:#f92672>=</span> eln <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>do</span> c10<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, sizeS(sp3)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>call</span> an_indS(sp3, i6)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>call</span> pathI(i6, w6)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>call</span> crossesP(w6, eln, ib1)
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span> <span style=color:#66d9ef>do</span>
</span></span></code></pre></div><h2 id=4-discussion-and-efficiency>4 Discussion and Efficiency
<a class=anchor href=#4-discussion-and-efficiency>#</a></h2><p>This study represented the efficacy of Fortran in computational simulations for graph path selection and analysis. The utilization of modules (<code>msoup</code>, <code>mind</code>, and <code>mpath</code>) showcases how Fortran manages individual entities, paths, and complex graph structures efficiently. The simulation steps, from initialization to the identification of Hamiltonian paths, illustrate the algorithmic flexibility of Fortran in traversing and analyzing graphs.</p><p>The significance of criteria-based path selection is evident in this study. It serves as a fundamental aspect in uncovering specific graph properties, such as Hamiltonian paths. The discussions around computational efficiency and the impact of different criteria on path selection highlight the practical relevance of these simulations in diverse scientific domains.</p><p>Moving forward, several promising directions emerge for advancing this research. Algorithmic improvements hold potential for enhancing computational efficiency, especially when dealing with larger and more intricate graphs. Optimizing path selection methodologies could significantly expedite the analysis process.</p><p>Investigating parallel computing techniques stands as another avenue to explore, leveraging Fortran&rsquo;s capabilities for faster processing of extensive graph structures and enabling more extensive analyses.</p><p>Lastly, integrating machine learning techniques into the analysis pipeline could refine criteria determination, potentially improving accuracy and adaptability in path selection methodologies.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/roaked/roaked.github.io/commit/dc6945862128731adeaa923ac7bd6815b26c6322 title='Last modified by roaked | December 3, 2023' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>December 3, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/roaked/roaked.github.io/edit/main/content/content/docs/2code/7cp/hamiltonian.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Ricardo Chin</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#1-simulation-and-analysis-of-graph-path-selection>1 Simulation and Analysis of Graph Path Selection</a></li><li><a href=#2-theoretical-considerations>2 Theoretical Considerations</a></li><li><a href=#3-code-implementation>3 Code Implementation</a><ul><li><a href=#31-methodology>3.1. Methodology</a></li><li><a href=#32-modules>3.2. Modules</a></li><li><a href=#33-simulation-steps>3.3. Simulation Steps</a></li></ul></li><li><a href=#4-discussion-and-efficiency>4 Discussion and Efficiency</a></li></ul></nav></div></aside></main></body></html>