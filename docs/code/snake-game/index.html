<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Smarter Reinforcement Learning
  #


  
    
      
        
      warning
    
Report not updated
Bug: Parameter ranges is mutating with values from a different param_range
Disclaimer - used the freeCodeCamp.org and GH repo base code for the Snake Game


  



  1 Introduction
  #


  1.1. Background and Rules
  #

Blockade, a classic arcade game also recognized as Snake, debuted on the Gremlin platform back in 1976. Initially, it was exclusively accessible on consoles like the Atari 2600. However, its global popularity surged around the turn of the twenty-first century with its release on Nokia mobile phones. The primary objective of the game is to accumulate as many &ldquo;apples&rdquo; as possible within the confines of the board. Nevertheless, as the score escalates, the snake&rsquo;s length increases, and the available space on the board diminishes, rendering navigation progressively challenging. The core rules of the game are as follows:"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://xsleaks.dev/docs/code/snake-game/"><meta property="og:site_name" content="Ricardo Chin"><meta property="og:title" content="Snake: Reinforcement Learning"><meta property="og:description" content="Smarter Reinforcement Learning # warning
Report not updated Bug: Parameter ranges is mutating with values from a different param_range Disclaimer - used the freeCodeCamp.org and GH repo base code for the Snake Game 1 Introduction # 1.1. Background and Rules # Blockade, a classic arcade game also recognized as Snake, debuted on the Gremlin platform back in 1976. Initially, it was exclusively accessible on consoles like the Atari 2600. However, its global popularity surged around the turn of the twenty-first century with its release on Nokia mobile phones. The primary objective of the game is to accumulate as many “apples” as possible within the confines of the board. Nevertheless, as the score escalates, the snake’s length increases, and the available space on the board diminishes, rendering navigation progressively challenging. The core rules of the game are as follows:"><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><title>Snake: Reinforcement Learning | Ricardo Chin</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.b1824eea1873de6fd466b2e1d8cc26a9f8e6e7aaf317af5779752ac8f255d4c4.css integrity="sha256-sYJO6hhz3m/UZrLh2Mwmqfjm56rzF69XeXUqyPJV1MQ=" crossorigin=anonymous><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><link rel=alternate type=application/rss+xml href=https://xsleaks.dev/docs/code/snake-game/index.xml title="Ricardo Chin"></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Ricardo Chin</span></a></h2><ul><li class=book-section-flat><a href=/docs/design/>Engineering Repository</a><ul><li><a href=/docs/design/fea-beam-simulation/>FEA Beam Instability Modes</a><ul></ul></li><li><a href=/docs/design/finite-element-method-development/>FEM Package Development</a><ul></ul></li></ul></li><li class=book-section-flat><a href=/docs/code/>System Repository</a><ul><li><a href=/docs/code/agv/>AGV: Stochastic Identification</a><ul></ul></li><li><a href=/docs/code/uav/>UAV: Red Bull Air Racing</a><ul><li><a href=/docs/code/uav/dynamics/>Drone System Dynamics</a></li><li><a href=/docs/code/uav/continuous-controller-design/>Continuous Controller</a></li><li><a href=/docs/code/uav/discrete-controller-design/>Discrete Controller</a></li><li><a href=/docs/code/uav/computer-vision/>Gate Sense: Computer Vision</a></li></ul></li><li><a href=/docs/code/robotics/>Robotics: Kin, Dynamics & Control</a><ul></ul></li><li><a href=/docs/code/deep-learning-fake-news/>Fake News: Inference & Clusters</a><ul></ul></li><li><a href=/docs/code/bin-packing/>EC Optimization: Space & Time</a><ul><li><a href=/docs/code/bin-packing/genetic-algorithm/>Genetic Algorithm</a></li><li><a href=/docs/code/bin-packing/particle-swarm-optimization/>Particle Swarm Optimization</a></li></ul></li><li><a href=/docs/code/snake-game/ class=active>Snake: Reinforcement Learning</a><ul><li><a href=/docs/code/snake-game/deepqnetwork/>BaseRL, GA-RL & Hamiltonian</a></li><li><a href=/docs/code/snake-game/adversarial/>Adversarial Multi-Agent RL, BattleMode</a></li></ul></li></ul></li><li class=book-section-flat><a href=/docs/lectures/>My Notes and Lectures</a><ul><li><a href=/docs/lectures/bayesian-machine-learning/bayes/>Bayesian Inference</a></li><li><a href=/docs/lectures/bayesian-optimization/bayesopt/>Bayesian Optimization</a></li><li><a href=/docs/lectures/nonlinear-programming/nonlinear/>Nonlinear Programming</a></li><li><a href=/docs/lectures/hamiltonian-graphs/hamiltonian/>Hamiltonian Graphs & Linked Lists</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Snake: Reinforcement Learning</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#1-introduction>1 Introduction</a><ul><li><a href=#11-background-and-rules>1.1. Background and Rules</a></li><li><a href=#12-ai-interplay>1.2. AI Interplay</a></li><li><a href=#13-reinforcement-learning-in-game-theory>1.3. Reinforcement Learning in Game Theory</a></li></ul></li><li><a href=#2-theoretical-foundation>2 Theoretical Foundation</a></li><li><a href=#3-method-selection>3 Method Selection</a></li><li><a href=#4-user-controlled-snake>4 User Controlled Snake</a></li></ul></nav></aside></header><article class=markdown><h1 id=smarter-reinforcement-learning><strong>Smarter Reinforcement Learning</strong>
<a class=anchor href=#smarter-reinforcement-learning>#</a></h1><blockquote class="book-hint2 warning"><p class="hint-title warning"><svg class="book-icon"><use href="/svg/hint-icons.svg#warning-notice"/></svg><span>warning</span></p><ul><li><strong>Report not updated</strong></li><li><strong>Bug</strong>: Parameter ranges is mutating with values from a different param_range</li><li><strong>Disclaimer</strong> - used the <a href=https://www.freecodecamp.org/news/train-an-ai-to-play-a-snake-game-using-python/>freeCodeCamp.org</a> and <a href=https://github.com/GNiendorf/snake>GH repo</a> base code for the Snake Game</li></ul></blockquote><p><img src=https://i.ytimg.com/vi/xcPqs92j4r4/maxresdefault.jpg alt=213d></p><h2 id=1-introduction>1 Introduction
<a class=anchor href=#1-introduction>#</a></h2><h3 id=11-background-and-rules>1.1. Background and Rules
<a class=anchor href=#11-background-and-rules>#</a></h3><p><a href=https://en.wikipedia.org/wiki/Blockade_%28video_game%29>Blockade, a classic arcade game also recognized as Snake</a>, debuted on the Gremlin platform back in 1976. Initially, it was exclusively accessible on consoles like the Atari 2600. However, its global popularity surged around the turn of the twenty-first century with its release on Nokia mobile phones. The primary objective of the game is to accumulate as many &ldquo;apples&rdquo; as possible within the confines of the board. Nevertheless, as the score escalates, the snake&rsquo;s length increases, and the available space on the board diminishes, rendering navigation progressively challenging. The <strong>core</strong> rules of the game are as follows:</p><ul><li><ol><li>The snake’s movement can be directed: up, down, left, or right.</li></ol></li><li><ol start=2><li>The snake always moves forward and increases in length by one frame (i.e., one pixel) after eating
an apple. (Otherwise the tail in the stack is popped)</li></ol></li><li><ol start=3><li>If the snake hits its own body or the border of the board, the game ends.</li></ol></li><li><ol start=4><li>The position of the apples on the board is random, and there is only one apple present at any
one time.</li></ol></li></ul><h3 id=12-ai-interplay>1.2. AI Interplay
<a class=anchor href=#12-ai-interplay>#</a></h3><p>The Snake game typically presents two critical phases:</p><ul><li>Early game</li><li>Late game</li></ul><p>Initially, when the snake&rsquo;s body is short and moves slowly, potentially leading to distractions and eventual demise, perhaps considered as not being challenging enough; and later, when fatigue sets in, player attention decreases resulting in the snake colliding with its own body or eventually getting stuck within its own boundaries, abruptly ending the game. These challenges are player-induced and a keyplay here is to introduc AI as it remains unaffected by emotional fluctuations and fatigue-induced errors.</p><p>To achieve this goal, a simple Reinforcement Learning (RL) approach was taken. Notably, successes such as Google&rsquo;s DeepMind Challenge¹ in <a href=https://en.wikipedia.org/wiki/AlphaGo>AlphaGo in 2017</a> mastering complex games have demonstrated the efficacy of RL. Hence, it can be seen that this is a commonly applied strategy to game-theory environments &mdash; training the AI to achieve higher scores in less time through RL.</p><p><img src=https://i.makeagif.com/media/5-09-2017/qNfoPW.gif alt=dsadas></p><p>¹ Google DeepMind Challenge Match with top-ranked Go player Lee Sedol.</p><p><strong>But how to find the perfect solution?</strong></p><p>Let us delve into the foundational concepts underpinning the most prominent scientific advances in RL algorithms.</p><h3 id=13-reinforcement-learning-in-game-theory>1.3. Reinforcement Learning in Game Theory
<a class=anchor href=#13-reinforcement-learning-in-game-theory>#</a></h3><p>Arguably, over the past decade a lot of significant contributions have been made. <a href=https://www.cs.toronto.edu/~vmnih/docs/dqn.pdf>DeepMind team&rsquo;s utilization of the DQN algorithm on the Atari 2600</a> platform to surpass human-level performance levels. Subsequently, further advancements in RL algorithms for video games emerged.</p><p><img src=https://www.marktechpost.com/wp-content/uploads/2021/02/image6.gif alt=eka></p><p><a href=https://cs229.stanford.edu/proj2015/362_report.pdf>For instance, Kevin Chen successfully employed DQN to play Flappy Bird</a>. However, it was observed that with increased training sessions, overfitting occurred, leading to a gradual decline in the AI&rsquo;s performance score.</p><p><img src=https://d3i71xaburhd42.cloudfront.net/b56c7703337cb9db008422b9b3410c97fff8bb54/1-Figure1-1.png alt=sad></p><p>Since then, both DeepMind and OpenAI have achieved remarkable success by applying RL algorithms to games like Starcraft 2. <a href=https://www.wired.co.uk/article/deepmind-starcraft-results-alphastar>&ldquo;This is how Google&rsquo;s DeepMind crushed puny humans at StarCraft.&rdquo;</a></p><p>Furthermore, there are numerous competitions, encompassing iterative deepening search, Monte Carlo Tree Search, Flood Fill and the A* algorithm, like the Micromouse Competition in Japan. <a href=https://towardsdatascience.com/reinforcement-learning-3f87a0290ba2>Many papers and articles have emmerged in different topics for applied RL</a>.</p><p><img src=https://miro.medium.com/v2/resize:fit:786/format:webp/1*ueJkuVP8fkY8p5nXN2gc7Q.png alt=adoska></p><p>Motivated by these advancements, a study on the algorithms used was performed building upon the successes of previous endeavours. Further, hyperparameter selection optimization was also considered using a genetic algorithm.</p><h2 id=2-theoretical-foundation>2 Theoretical Foundation
<a class=anchor href=#2-theoretical-foundation>#</a></h2><p>Following the previous section, a brief analysis of the suitability of the Snake game for RL methods was done focusing on the algorithms: Proximal Policy Optimization (PPO) and Deep Q-Network (DQN).</p><p>The Snake game inherently embodies typical characteristics of a RL problem, making it well-suited for such algorithms. Firstly, the game environment is discrete and stationary (except in the <a href=https://ricardochin.com/docs/code/snake-game/adversarial/>case of multi-agent RL</a>), as the snake can only navigate within a limited game window and can execute a finite set of actions. Secondly, at each time step, the state of the game is fully observable since the snake can perceive its surrounding environment and its own current state. Lastly, the primary objective is to maximize the game score, which translates to achieving the highest possible return.</p><p>In the core, these algorithms function by enabling a machine learning model, or agent, to interact with the environment, learning optimal strategies to maximize returns. The agent operates by taking actions based on the current state of the environment and receives rewards accordingly. Through iterative learning, the agent attempts to optimize its decision-making process, aiming to maximize long-term returns by identifying the most effective strategies for action selection.</p><p><img src=https://miro.medium.com/v2/resize:fit:1400/1*yknXrUYahqjDCc28xHk_sQ.png alt=wdok></p><p>As per visualized, methods can be categorized into model-free and model-based approaches based on whether environmental models are utilized. Model-based algorithms involve the use of environmental models in decision-making, enabling the learning of dynamic laws and state transition probabilities to inform decisions. On the other hand, model-free algorithms learn strategies directly from experience without relying on pre-defined environmental models.</p><p>Both PPO and DQN algorithms fall under the model-free category. This is primarily because in many practical scenarios, the environment exhibits a large state and action space, making it challenging to accurately model its dynamics. Model-free algorithms alleviate this challenge by learning strategies directly from interactions with the environment, making them more versatile.</p><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p>In the context of the Snake game, constructing a universal environmental model poses difficulties due to variations in the game window size and obstacle placement. Additionally, the discrete nature of states and actions in the Snake game necessitates extensive modeling and computation, resulting in high computational complexity for model-based approaches. In contrast, PPO and DQN algorithms utilize neural networks to approximate strategy and value functions, offering adaptability to different game maps and states with faster computation speeds. Hence, employing a model-free algorithm is more suitable for the Snake game.</blockquote><h2 id=3-method-selection>3 Method Selection
<a class=anchor href=#3-method-selection>#</a></h2><p>Based on the provided information, the lies on model-free algorithms, which can be categorized into policy-based and value-based approaches. The two widely-used algorithms from each category selected are: PPO and DQN, respectively, for separate experimentation.</p><p>Value-based algorithms, such as DQN, aim to learn an Action-Value Function (AVF) that predicts the long-term return of each action in every state. In the context of the Snake game, DQN can predict the expected return for actions. The agent then selects the action with the highest predicted return to maximize its score.</p><p><img src=https://bruceoutdoors.files.wordpress.com/2017/08/2017-08-29-23_43_58-final-report-pdf-xchange-viewer.png alt=dsajidajs></p><p>On the other hand, policy-based algorithms, like PPO, learn a policy function to directly select the optimal action in each state. In the Snake game, PPO learns a strategy function to choose the best action for maximizing returns.</p><p>In theory, while DQN excels in predicting action values and achieving stability, PPO outperforms in learning optimal policies swiftly and reliably, resulting in superior performance in the Snake game.</p><p>The PPO algorithm employs a strategy known as the &ldquo;clipped surrogate objective&rdquo; during training. This strategy, rooted in the concept of proximal policy optimization, aims to maximize strategy improvement while ensuring that each updated policy remains close to the previous one. Although effective in practice, this approach introduces randomness in decision-making.</p><p><img src=https://spinningup.openai.com/en/latest/_images/math/e62a8971472597f4b014c2da064f636ffe365ba3.svg alt=saokdoakd></p><p>In essence, PPO represents the strategy using a probability distribution during training and updates this distribution through sampling to enhance strategy refinement continuously. Consequently, decision-making during gameplay may vary due to the randomness inherent in each sampling process. Moreover, PPO incorporates an &ldquo;exploration term&rdquo; mechanism to promote exploratory behaviour within the strategy. This introduces randomness into the decision-making process, enabling the algorithm to explore new states and action combinations, thus avoiding over-reliance on existing experiences and facilitating adaptation to diverse environments.</p><p>While the randomness inherent in PPO aids in better environmental adaptation and helps avoid local optima, it can also lead to suboptimal decision-making.</p><h2 id=4-user-controlled-snake>4 User Controlled Snake
<a class=anchor href=#4-user-controlled-snake>#</a></h2><p>For comparison purposes, initially a user-controlled Snake game was thoroughly implemented. Below, it is a detailed description of the core game mechanisms.</p><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p>Most of the code for the game implementation was adapted using Pygame for providing a robust framework for game development in Python.</blockquote><p>The code begins with initializing Pygame and setting up essential game parameters such as window size, colors, and game speed. Pygame&rsquo;s functionalities are leveraged for window creation, event handling, and display rendering.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> random<span style=color:#f92672>,</span> pygame<span style=color:#f92672>,</span> sys<span style=color:#f92672>,</span> time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Pygame initialization and window setup</span>
</span></span><span style=display:flex><span>check_errors <span style=color:#f92672>=</span> pygame<span style=color:#f92672>.</span>init()
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> check_errors[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;[!] Had </span><span style=color:#e6db74>{</span>check_errors[<span style=color:#ae81ff>1</span>]<span style=color:#e6db74>}</span><span style=color:#e6db74> errors when initializing game, exiting...&#39;</span>)
</span></span><span style=display:flex><span>    sys<span style=color:#f92672>.</span>exit(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;[+] Game successfully initialized&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Defined other variables here, adapt fontsize, window size, colors, speed, </span>
</span></span><span style=display:flex><span><span style=color:#75715e># block size, etc...</span>
</span></span></code></pre></div><p>In addition, <code>SnakeGameUser</code> and <code>SnakeGameAI</code> classes are defined which encapsulate the game logic, managing the game state, snake movement, collision detection, and food placement.</p><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p><p>Vital functions encompass:</p><ul><li><code>def __init__</code> &ndash; Initializing game window and start up the game state</li><li><code>def _init_game</code> &ndash; Initialize game state variables (snake position, score, food)</li><li><code>def _place_food</code> &ndash; Places food randomly within the game window, avoiding snake collision</li><li><code>def _move</code> &ndash; Handling snake movement based on user or AI action</li><li><code>def play_step </code>&ndash; Process each step of the game based on user (and later AI actions). (in addition, collects user input, move snake, check collision, update score, etc.)</li></ul></blockquote><p>Given <code>__init__</code> and <code>__init__game</code> functions, the snake is initialized with a starting position, consisting of three body parts (<code>self.head</code> and two segments) positioned horizontally to the right - this is normally executed in good practice for developing a snake game, including representing the <code>self.head</code> at the center of the window. This setup essentially creates an initial length for the snake, allowing it to start the game with a visible length and direction. The snake initially consists of these three segments, and as the game progresses and the snake moves, additional segments will be added or removed based on its movement, food consumption, and collision detection.</p><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p>Having an initial length provides a visible presence of the snake on the screen, allowing the player or AI agent to see its position and direction from the beginning of the game.</blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_init_game</span>(self):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Game state variables (snake position, score, food)</span>
</span></span><span style=display:flex><span>    start_x <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>width <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    start_y <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>height <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>direction <span style=color:#f92672>=</span> Direction<span style=color:#f92672>.</span>RIGHT
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Point(start_x, start_y)
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>snake <span style=color:#f92672>=</span> [self<span style=color:#f92672>.</span>head]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Create initial instance of the snake with three blocks</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>snake<span style=color:#f92672>.</span>append(Point(self<span style=color:#f92672>.</span>head<span style=color:#f92672>.</span>x <span style=color:#f92672>-</span> i <span style=color:#f92672>*</span> BLOCK_SIZE, start_y))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>score <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>food <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>frame_iteration <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>_place_food()
</span></span></code></pre></div><p>After snake initialization, the <code>_move</code> function adjusts the snake&rsquo;s direction based on the received action (from user or AI). This is done using a list <code>clockwise_directions</code> that represents the directional movement of the snake - right, down, left, up (clockwise). Moreover, it determines the intended change in direction: no change, right turn, or left turn. Calculating the new direction index by locating the current direction within the <code>clockwise_directions</code> list and adjusting it based on the determined change, it then updates the snake&rsquo;s direction accordingly.</p><blockquote class="book-hint2 note"><p class="hint-title note"><svg class="book-icon"><use href="/svg/hint-icons.svg#note-notice"/></svg><span>note</span></p>Case scenarios:
If the action indicates no change [1, 0, 0] -> snake maintains its current direction.
If the action indicates a right turn [0, 1, 0] -> snake updates the direction to the next index in the clockwise order.
If the action indicates a left turn [0, 0, 1] -> snake updates the direction to the previous index in the clockwise order (effectively, anti-clockwise).</blockquote><p>Furthermore, using a dictionary <code>movement_adjustments</code> that maps directions for movement adjustments (changes in <code>x</code> and <code>y</code> coordinates), it applies the corresponding adjustment to the snake&rsquo;s head position, effectively moving it in the intended direction by a distance specified by the <code>BLOCK_SIZE</code>, aligning its position with the game grid.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_move</span>(self, action):
</span></span><span style=display:flex><span>        <span style=color:#75715e># Define clockwise directions</span>
</span></span><span style=display:flex><span>        clockwise_directions <span style=color:#f92672>=</span> [Direction<span style=color:#f92672>.</span>RIGHT, Direction<span style=color:#f92672>.</span>DOWN,
</span></span><span style=display:flex><span>                                 Direction<span style=color:#f92672>.</span>LEFT, Direction<span style=color:#f92672>.</span>UP]
</span></span><span style=display:flex><span>        current_direction <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>direction
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Define action codes for each movement direction</span>
</span></span><span style=display:flex><span>        no_change_action <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        right_turn_action <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        left_turn_action <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Determine the change in direction based on action</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> action <span style=color:#f92672>==</span> no_change_action:
</span></span><span style=display:flex><span>            direction_change <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> action <span style=color:#f92672>==</span> right_turn_action:
</span></span><span style=display:flex><span>            direction_change <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> action <span style=color:#f92672>==</span> left_turn_action:
</span></span><span style=display:flex><span>            direction_change <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Calculate the new direction index</span>
</span></span><span style=display:flex><span>        current_index <span style=color:#f92672>=</span> clockwise_directions<span style=color:#f92672>.</span>index(current_direction)
</span></span><span style=display:flex><span>        new_index <span style=color:#f92672>=</span> (current_index <span style=color:#f92672>+</span> direction_change) <span style=color:#f92672>%</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>        new_direction <span style=color:#f92672>=</span> clockwise_directions[new_index]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Update the direction</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>direction <span style=color:#f92672>=</span> new_direction
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Define movement adjustments for each direction</span>
</span></span><span style=display:flex><span>        movement_adjustments <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>            Direction<span style=color:#f92672>.</span>RIGHT: (BLOCK_SIZE, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>            Direction<span style=color:#f92672>.</span>LEFT: (<span style=color:#f92672>-</span>BLOCK_SIZE, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>            Direction<span style=color:#f92672>.</span>DOWN: (<span style=color:#ae81ff>0</span>, BLOCK_SIZE),
</span></span><span style=display:flex><span>            Direction<span style=color:#f92672>.</span>UP: (<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span>BLOCK_SIZE)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Apply movement adjustments to update the head position</span>
</span></span><span style=display:flex><span>        move_x, move_y <span style=color:#f92672>=</span> movement_adjustments[self<span style=color:#f92672>.</span>direction]
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>head <span style=color:#f92672>=</span> Point(self<span style=color:#f92672>.</span>head<span style=color:#f92672>.</span>x <span style=color:#f92672>+</span> move_x, self<span style=color:#f92672>.</span>head<span style=color:#f92672>.</span>y <span style=color:#f92672>+</span> move_y)
</span></span></code></pre></div><p>Afterwards, the <code>_place_food</code> selects a random position within the game grid to place the food for the snake. Initially creating a set containing all current positions occupied by the snake segments, it enters a loop that generates random <code>x</code> and <code>y</code> coordinates within the game boundaries, scaled by the block size, effectively aligning with the grid. These coordinates form a potential new food position. The loop continues generating random positions until it finds a position that doesn&rsquo;t coincide with any segment of the snake. Once a suitable position is found, it assigns this new position as the food&rsquo;s location, effectively placing the food at an unoccupied spot within the game grid, ensuring it does not overlap with the snake&rsquo;s current positions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_place_food</span>(self):
</span></span><span style=display:flex><span>    snake_positions <span style=color:#f92672>=</span> {point <span style=color:#66d9ef>for</span> point <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>snake}  <span style=color:#75715e># set of snake positions</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Generate random positions until an available one is found</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>        x <span style=color:#f92672>=</span> random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>0</span>, (self<span style=color:#f92672>.</span>width <span style=color:#f92672>-</span> BLOCK_SIZE) <span style=color:#f92672>//</span> BLOCK_SIZE) <span style=color:#f92672>*</span> BLOCK_SIZE
</span></span><span style=display:flex><span>        y <span style=color:#f92672>=</span> random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>0</span>, (self<span style=color:#f92672>.</span>height <span style=color:#f92672>-</span> BLOCK_SIZE) <span style=color:#f92672>//</span> BLOCK_SIZE) <span style=color:#f92672>*</span> BLOCK_SIZE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        new_food_position <span style=color:#f92672>=</span> Point(x, y)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> new_food_position <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> snake_positions:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>food <span style=color:#f92672>=</span> new_food_position
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span></code></pre></div><p>For defining the game over condition, the <code>is_collision</code> function determines if a collision occurs at a given point within the game. Initially checking the point&rsquo;s existence, defaulting to the snake&rsquo;s head if not provided, it then examines whether the point lies beyond the game&rsquo;s boundaries, assessing if its coordinates exceed the game area&rsquo;s width or height. Additionally, it verifies if the point coincides with any part of the snake&rsquo;s body, excluding the head. If the point is outside the game boundaries or matches a segment of the snake&rsquo;s body, the function returns <code>True</code>, indicating a collision has occurred. Otherwise, it returns <code>False</code>, signifying no collision at that specific point in the game.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_collision</span>(self, pt<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> pt <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            pt <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>head
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Boundary collision check</span>
</span></span><span style=display:flex><span>        collides_with_boundary <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>            pt<span style=color:#f92672>.</span>x <span style=color:#f92672>&gt;</span> self<span style=color:#f92672>.</span>width <span style=color:#f92672>-</span> BLOCK_SIZE <span style=color:#f92672>or</span>
</span></span><span style=display:flex><span>            pt<span style=color:#f92672>.</span>x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>or</span>
</span></span><span style=display:flex><span>            pt<span style=color:#f92672>.</span>y <span style=color:#f92672>&gt;</span> self<span style=color:#f92672>.</span>height <span style=color:#f92672>-</span> BLOCK_SIZE <span style=color:#f92672>or</span>
</span></span><span style=display:flex><span>            pt<span style=color:#f92672>.</span>y <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Snake body collision check</span>
</span></span><span style=display:flex><span>        collides_with_snake <span style=color:#f92672>=</span> pt <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>snake[<span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> collides_with_boundary <span style=color:#f92672>or</span> collides_with_snake
</span></span></code></pre></div><p>Lastly, the <code>play_step</code> function manages a single step within the game loop. It increments the frame count to track game progress and handles events like quitting the game. It updates the snake&rsquo;s movement based on the received action, adding a new head position to the snake&rsquo;s body. In the case of a user-controlled snake game, it must take as input, the respective key that is being pressed at the time and adjust the action based on that specific task. Otherwise, <code>play_step</code> will take the action as an input value (in case of AI controlled).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>play_step</span>(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>frame_iteration <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> event <span style=color:#f92672>in</span> pygame<span style=color:#f92672>.</span>event<span style=color:#f92672>.</span>get():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> event<span style=color:#f92672>.</span>type <span style=color:#f92672>==</span> pygame<span style=color:#f92672>.</span>QUIT:
</span></span><span style=display:flex><span>                pygame<span style=color:#f92672>.</span>quit()
</span></span><span style=display:flex><span>                quit()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> event<span style=color:#f92672>.</span>type <span style=color:#f92672>==</span> pygame<span style=color:#f92672>.</span>KEYDOWN:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> event<span style=color:#f92672>.</span>key <span style=color:#f92672>==</span> pygame<span style=color:#f92672>.</span>K_LEFT:
</span></span><span style=display:flex><span>                    self<span style=color:#f92672>.</span>direction <span style=color:#f92672>=</span> Direction<span style=color:#f92672>.</span>LEFT
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>elif</span> event<span style=color:#f92672>.</span>key <span style=color:#f92672>==</span> pygame<span style=color:#f92672>.</span>K_RIGHT:
</span></span><span style=display:flex><span>                    self<span style=color:#f92672>.</span>direction <span style=color:#f92672>=</span> Direction<span style=color:#f92672>.</span>RIGHT
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>elif</span> event<span style=color:#f92672>.</span>key <span style=color:#f92672>==</span> pygame<span style=color:#f92672>.</span>K_UP:
</span></span><span style=display:flex><span>                    self<span style=color:#f92672>.</span>direction <span style=color:#f92672>=</span> Direction<span style=color:#f92672>.</span>UP
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>elif</span> event<span style=color:#f92672>.</span>key <span style=color:#f92672>==</span> pygame<span style=color:#f92672>.</span>K_DOWN:
</span></span><span style=display:flex><span>                    self<span style=color:#f92672>.</span>direction <span style=color:#f92672>=</span> Direction<span style=color:#f92672>.</span>DOWN
</span></span></code></pre></div><p>Moreover, the function checks for game-ending conditions — such as collision with itself or exceeding a frame limit—and sets the game over status accordingly, applying penalties if necessary. If the snake consumes the food, it increments the score and updates the food position. After these actions, it refreshes the game display and controls the game&rsquo;s frame rate before returning the reward earned, the game over status, and the current score, providing essential information for the game loop to proceed.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>play_step</span>(self, action):
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>frame_iteration <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> event <span style=color:#f92672>in</span> pygame<span style=color:#f92672>.</span>event<span style=color:#f92672>.</span>get():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> event<span style=color:#f92672>.</span>type <span style=color:#f92672>==</span> pygame<span style=color:#f92672>.</span>QUIT:
</span></span><span style=display:flex><span>                pygame<span style=color:#f92672>.</span>quit()
</span></span><span style=display:flex><span>                quit()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Move the snake</span>
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>_move(action)
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>snake<span style=color:#f92672>.</span>insert(<span style=color:#ae81ff>0</span>, self<span style=color:#f92672>.</span>head)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Check for game over conditions</span>
</span></span><span style=display:flex><span>    game_over <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    reward <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    collision_or_frame_limit <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>is_collision() <span style=color:#f92672>or</span>
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>frame_iteration <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>100</span> <span style=color:#f92672>*</span> len(self<span style=color:#f92672>.</span>snake)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> collision_or_frame_limit:
</span></span><span style=display:flex><span>        game_over <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>        reward <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> reward, game_over, self<span style=color:#f92672>.</span>score
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Check if the snake has eaten the food</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>head <span style=color:#f92672>==</span> self<span style=color:#f92672>.</span>food:
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>score <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        reward <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_place_food()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>snake<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Update UI and clock</span>
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>_update_ui()
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>clock<span style=color:#f92672>.</span>tick(SPEED)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Return game status and score</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> reward, game_over, self<span style=color:#f92672>.</span>score
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/roaked/roaked.github.io/commit/4aca1b7a7ce8cb937b4bb2b9220c8a23f3b1cd47 title='Last modified by roaked | February 26, 2026' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>February 26, 2026</span></a></div><div><a class="flex align-center" href=https://github.com/roaked/roaked.github.io/edit/main/content/content/docs/code/snake-game/_index.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Ricardo Chin</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#1-introduction>1 Introduction</a><ul><li><a href=#11-background-and-rules>1.1. Background and Rules</a></li><li><a href=#12-ai-interplay>1.2. AI Interplay</a></li><li><a href=#13-reinforcement-learning-in-game-theory>1.3. Reinforcement Learning in Game Theory</a></li></ul></li><li><a href=#2-theoretical-foundation>2 Theoretical Foundation</a></li><li><a href=#3-method-selection>3 Method Selection</a></li><li><a href=#4-user-controlled-snake>4 User Controlled Snake</a></li></ul></nav></div></aside></main></body></html>