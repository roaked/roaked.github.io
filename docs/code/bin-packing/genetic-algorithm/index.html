<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Space in Bin Packing: Genetic Algorithm # Source Source 1 Theoretical Remarks # Genetic Algorithm (GA) stands as an adaptive method employed for resolving search and optimization dilemmas. Operating across numerous generations, it simulates the evolutionary process observed in natural populations, adhering to the principles of natural selection and the concept of &ldquo;survival of the fittest.&rdquo; By emulating this phenomenon, GAs possess the capability to &ldquo;evolve&rdquo; solutions for real-world problems, provided they have been encoded effectively."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="Genetic Algorithm"><meta property="og:description" content="Space in Bin Packing: Genetic Algorithm # Source Source 1 Theoretical Remarks # Genetic Algorithm (GA) stands as an adaptive method employed for resolving search and optimization dilemmas. Operating across numerous generations, it simulates the evolutionary process observed in natural populations, adhering to the principles of natural selection and the concept of &ldquo;survival of the fittest.&rdquo; By emulating this phenomenon, GAs possess the capability to &ldquo;evolve&rdquo; solutions for real-world problems, provided they have been encoded effectively."><meta property="og:type" content="article"><meta property="og:url" content="https://xsleaks.dev/docs/code/bin-packing/genetic-algorithm/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-02-16T14:19:04+01:00"><title>Genetic Algorithm | Ricardo Chin</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.b74e85bd7803de00c09a320dcf09ae0d7e37702a9918995f5fe9d1c71c55a223.css integrity="sha256-t06FvXgD3gDAmjINzwmuDX43cCqZGJlfX+nRxxxVoiM=" crossorigin=anonymous><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Ricardo Chin</span></a></h2><ul><li class=book-section-flat><a href=/docs/design/>Design Repository</a><ul><li><a href=/docs/design/fea-beam-simulation/>FEA Beam Instability Modes</a><ul></ul></li><li><a href=/docs/design/industrial-crane-design/>Industrial Girder Crane</a><ul></ul></li><li><a href=/docs/design/finite-element-method-development/>FEM Package Development</a><ul></ul></li><li><a href=/docs/design/manual-transmission-design/>Gear Train Transmission</a><ul></ul></li><li><a href=/docs/design/electron-beam-tech/>Electron Beam Technology</a><ul></ul></li></ul></li><li class=book-section-flat><a href=/docs/code/>System Repository</a><ul><li><a href=/docs/code/agv/>AGV: Stochastic Identification</a><ul></ul></li><li><a href=/docs/code/uav/>UAV: Red Bull Air Racing</a><ul><li><a href=/docs/code/uav/dynamics/>Drone System Dynamics</a></li><li><a href=/docs/code/uav/continuous-controller-design/>Continuous Controller</a></li><li><a href=/docs/code/uav/discrete-controller-design/>Discrete Controller</a></li><li><a href=/docs/code/uav/computer-vision/>Gate Sense: Computer Vision</a></li></ul></li><li><a href=/docs/code/robotics/>Robotics: Kin, Dynamics & Control</a><ul></ul></li><li><a href=/docs/code/deep-learning-fake-news/>Fake News: Inference & Clusters</a><ul></ul></li><li><a href=/docs/code/bin-packing/>EC Optimization: Space & Time</a><ul><li><a href=/docs/code/bin-packing/genetic-algorithm/ class=active>Genetic Algorithm</a></li><li><a href=/docs/code/bin-packing/particle-swarm-optimization/>Particle Swarm Optimization</a></li></ul></li><li><a href=/docs/code/snake-game/>Snake: Reinforcement Learning</a><ul><li><a href=/docs/code/snake-game/deepqnetwork/>Off Policy RL & Neuroevolution</a></li><li><a href=/docs/code/snake-game/policy/>Policy Based Decision-Making</a></li><li><a href=/docs/code/snake-game/adversarial/>Adversarial Multi-Agent RL</a></li></ul></li></ul></li><li class=book-section-flat><a href=/docs/competitions/>Academic Competitions</a><ul><li><a href=/docs/competitions/fst/>Formula Student Lisbon</a></li><li><a href=/docs/competitions/thermocup/>ThermoCup</a></li></ul></li><li class=book-section-flat><a href=/docs/lectures/>My Programming Lectures</a><ul><li><a href=/docs/lectures/hamiltonian-graphs/hamiltonian/>Hamiltonian Paths: Linked Lists</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Genetic Algorithm</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#1-theoretical-remarks>1 Theoretical Remarks</a></li><li><a href=#2-code-implementation>2 Code Implementation</a><ul><li><a href=#21-cost-function-and-stopping-criteria>2.1. Cost Function and Stopping Criteria</a></li><li><a href=#22-initialization-crossing-and-mutation>2.2. Initialization, Crossing and Mutation</a></li></ul></li><li><a href=#3-results>3 Results</a><ul><li><a href=#31-first-benchmark>3.1. First Benchmark</a></li><li><a href=#32-second-benchmark>3.2. Second Benchmark</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=space-in-bin-packing-genetic-algorithm><strong>Space in Bin Packing: Genetic Algorithm</strong>
<a class=anchor href=#space-in-bin-packing-genetic-algorithm>#</a></h1><div class="book-columns flex flex-wrap"><div class="flex-even markdown-inner"><img src=https://user-images.githubusercontent.com/36581610/78828900-6d6a2080-79b3-11ea-81a3-bd284849c3f2.gif alt=sa></div><div class="flex-even markdown-inner"><img src=https://user-images.githubusercontent.com/36581610/78828927-79ee7900-79b3-11ea-9b25-936f19c4bf4a.gif alt=asd></div></div><details><summary>Source</summary><div class=markdown-inner><a href=https://github.com/greerviau/TetrisAI>Source</a></div></details><h2 id=1-theoretical-remarks>1 Theoretical Remarks
<a class=anchor href=#1-theoretical-remarks>#</a></h2><p>Genetic Algorithm (GA) stands as an adaptive method employed for resolving search and optimization dilemmas. Operating across numerous generations, it simulates the evolutionary process observed in natural populations, adhering to the principles of natural selection and the concept of &ldquo;survival of the fittest.&rdquo; By emulating this phenomenon, GAs possess the capability to &ldquo;evolve&rdquo; solutions for real-world problems, provided they have been encoded effectively.</p><p>While GA does not assure convergence or the discovery of the global optimal solution, it does tend to furnish an &ldquo;acceptably good&rdquo; solution relatively swiftly, on average. Typically, GA is extensively tailored to suit specific applications, resulting in a myriad of variants. Consequently, pinning down a singular &ldquo;generic&rdquo; or &ldquo;traditional&rdquo; GA proves challenging due to this diversity. Nevertheless, a study of the foundational concepts behind early GA, along with exploration of its various adaptations, enables the identification of key operations, culminating in a conceptualization of a &ldquo;traditional&rdquo; GA.</p><p>The fundamental components of the &ldquo;traditional&rdquo; GA encompass a fitness function, a selection technique, and fixed-probability-driven crossover and mutation operators. The population comprises all chromosomes, treated as individuals, with each iteration referred to as a generation, signifying an iterative updating of the population. Chromosomes, composed of genes reflecting parameters for optimization, embody potential solutions to the optimization problem, facilitating the simultaneous evaluation of multiple solutions.</p><p>The GA&rsquo;s dimension corresponds to the search space dimension, equating to the number of genes housed within each chromosome. The fitness function assumes a pivotal role, enabling the GA to assess the performance of each chromosome within the population. Tailored for each specific problem, the fitness function serves as the sole bridge between the GA and the application itself, necessitating a careful and precise selection. Its design must accurately mirror the application&rsquo;s parameters and their optimization criteria.</p><p>The selection operator plays a critical role by electing chromosomes from the current generation to act as parents for the subsequent generation. This selection process favors the most fit individuals, and the probability of each chromosome&rsquo;s selection adheres to a specific scheme, dictating the genetic inheritance for the subsequent iterations.</p><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><span>\[P_s(i) = \frac{f(i)}{\sum_{J=1}^{N} f(J)}\]</span><p>The process described outlines the selection, crossover, and mutation stages within GAs framework:</p><ol><li><strong>Selection</strong>:</li></ol><ul><li><span>\(F_s(i)\)
</span>represents the probability of selection for the <span>\(i^{th}\)
</span>chromosome, while f(i) denotes its fitness value.</li><li>Chromosomes are selected in pairs, ensuring diversity by re-normalizing probabilities after each selection to avoid selecting the same chromosome.</li><li>Each pair consists of two distinct chromosomes, allowing for multiple associations of a single chromosome across different pairs.</li></ul><ol start=2><li><strong>Crossover</strong>:</li></ol><ul><li>As the primary local search process, crossover drives the generation of new offspring from selected parent pairs.</li><li>Two offspring are generated for each parent pair selected by the selection operator.</li><li>Prior to the algorithm&rsquo;s execution, a predetermined probability of crossover determines whether each parent pair undergoes crossover or replication.</li><li>Replication leads to offspring identical to their parents, while crossover involves converting parent pairs to binary notation and exchanging bits beyond a randomly chosen crossover point to form the offspring pair.</li></ul><p>This iterative process, involving selection of diverse parent pairs, crossover, and mutation of offspring, fuels the continual evolution and generation of new solutions within the GA framework.</p><p><img src=https://live.staticflickr.com/65535/53359214517_b44b86b342_b.jpg alt=2></p><ol start=3><li><strong>Mutations</strong>: are global searches. A predetermined probability of mutation, established before the algorithm&rsquo;s initiation, is applied to every individual bit of each offspring chromosome. This probability governs whether a specific bit within an offspring chromosome will be inverted.</li></ol><p><img src=https://live.staticflickr.com/65535/53360310243_b6be608583_h.jpg alt=3></p><p>The elitist operator in GA&rsquo;s serves to maintain or improve the algorithm&rsquo;s performance throughout its progression. It accomplishes this by replicating the best chromosome into the succeeding generation, bypassing both crossover and mutation operators. This strategy ensures that the best-performing chromosome, in terms of fitness, remains constant or improves, preventing a decrease in its fitness value.</p><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p><p>The termination criteria is based upon:</p><ul><li>Number of generations</li><li>Fitness of the best individual in the population</li><li>Average fitness of the entire population</li><li>Differences in the best fitness or average fitness values across successive generations.</li></ul></blockquote><h2 id=2-code-implementation>2 Code Implementation
<a class=anchor href=#2-code-implementation>#</a></h2><p>Initially, implementing the Best Fit Decreasing (BFD) method was way too simple. Hence, I decided to ommit implementation and results &ndash; since it&rsquo;s a basic heuristic and doesn&rsquo;t need a complex cost function. It was coded from scratch in Matlab.</p><p>However, the GA is a bit more intricate. Instead of creating these algorithms from scratch, existing Matlab codes from online sources were adapted and optimized to suit the problem&rsquo;s requirements and parameters. The code can be seen at <a href=https://github.com/roaked/genetic-algorithm-optimization/tree/main/bpp>the following GitHub repo</a>.</p><h3 id=21-cost-function-and-stopping-criteria>2.1. Cost Function and Stopping Criteria
<a class=anchor href=#21-cost-function-and-stopping-criteria>#</a></h3><p>For GA to work, a cost function is needed. This function must consider the main goal (minimizing the number of bins) and the constraints (all weights should fit within the bin capacity). If a bin&rsquo;s capacity is exceeded, it&rsquo;s termed a &ldquo;bin violation.&rdquo; Initially, the attempt was made to prevent any bin violations from occurring during the simulation. However, this led to the algorithms getting stuck at a suboptimal solution of 16 bins for a problem where the optimal solution was 15 bins. It was challenging for the algorithms to redistribute weights across bins without exceeding their capacities in a single step.</p><p>A different approach, found in literature, allowed bin capacities to be exceeded temporarily during iterations. In this approach, bin violations were included in the cost function, aiming to minimize them to zero. So, the algorithms started with several bin violations, but reducing these led to improvements in the cost function, unveiling better solutions.</p><p>The cost function used became: <span>\( J = nBin + \alpha \times MeanViol + LBPenalty \)</span></p><blockquote class="book-hint2 note"><p class="hint-title note"><svg class="book-icon"><use href="/svg/hint-icons.svg#note-notice"/></svg><span>note</span></p><p>The variables are described as:</p><ul><li>nBin: Number of bins used</li><li>MeanViol: Average of violations across the bins</li><li>α: Tuning parameter - if low converges to solutions with fewer bins than optimal. if too high, the solutions are feasible, but not optimal</li><li>LBPenalty: Prevents algorithms from converging to a number of bins below a certain lower bound.</li></ul></blockquote><p>As per seen below, the function takes <code>pos</code> and <code>model</code> input parameters to represent the allocation of item to bins and problem parameteres <code>n</code>, <code>w</code> and <code>c</code>, respectively. To start with, <code>Sep</code> need to be verified by checking the position where bins are divided in the <code>pos</code> vector. Consequently, divides the position vector into bins <code>B</code> based on the separators.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-matlab data-lang=matlab><span style=display:flex><span><span style=color:#66d9ef>function</span> [J, sol] = <span style=color:#a6e22e>GA_BinPackingCost</span>(pos, model)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    n = model.n;
</span></span><span style=display:flex><span>    w = model.w;
</span></span><span style=display:flex><span>    c = model.c;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Sep = find(pos<span style=color:#f92672>&gt;</span>n);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    From = [<span style=color:#ae81ff>0</span> Sep] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    To = [Sep length(pos)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    B = {};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i=<span style=color:#ae81ff>1</span>:length(From)
</span></span><span style=display:flex><span>        Bi = pos(From(i):To(i));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> numel(Bi)<span style=color:#f92672>&gt;</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            B = [B; Bi]; <span style=color:#75715e>%#ok</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    nBin = numel(B);
</span></span><span style=display:flex><span>    Viol = zeros(nBin,<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i=<span style=color:#ae81ff>1</span>:nBin
</span></span><span style=display:flex><span>        Vi = sum(w(B{i}));
</span></span><span style=display:flex><span>        Viol(i) = max(Vi<span style=color:#f92672>/</span>c<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    MeanViol = mean(Viol);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>        alpha = <span style=color:#ae81ff>0.7</span><span style=color:#f92672>*</span>n;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        alpha = <span style=color:#ae81ff>1.25</span><span style=color:#f92672>*</span>n;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>%sum(w)/c = lower bound of bins needed</span>
</span></span><span style=display:flex><span>    J = nBin <span style=color:#f92672>+</span> alpha<span style=color:#f92672>*</span>MeanViol <span style=color:#f92672>+</span> max(sum(model.w)<span style=color:#f92672>/</span>model.c <span style=color:#f92672>-</span> nBin,<span style=color:#ae81ff>0</span>)<span style=color:#f92672>*</span><span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    sol.nBin = nBin;
</span></span><span style=display:flex><span>    sol.BPos = B;
</span></span><span style=display:flex><span>    sol.Viol = Viol;
</span></span><span style=display:flex><span>    sol.MeanViol = MeanViol;
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>To solve the bin packing problem with these algorithms, the program received a set of items with weights that needed to be assigned. A position vector was created and shuffled to obtain a solution. For example, if weights were [20, 15, 10, 5], shuffling them to [2, 3, 1, 4] meant arranging them as [15, 10, 20, 5]. Each item needed at least one decision variable in the position vector.</p><p>Items had to be assigned to different bins. More variables were added inside the position vector to handle this. For instance, [2, 3, 5, 1, 4] could mean two bins: [15, 10] and [20, 5]. Integers higher than the number of items represented bin divisions. Stopping criteria included a maximum number of iterations, adjusted according to the number of items to be assigned due to the inherent randomness in these heuristics.</p><p>Another criterion introduced is a &ldquo;stuck counter.&rdquo; Often, it&rsquo;s ambiguous whether the algorithm is stuck in a local minimum or encountering difficulties in finding an improved solution. To address this, if the program identifies that the best cost remains unchanged from the previous iteration, it initiates a count of iterations. Upon surpassing a predetermined limit, the program halts. Additionally, if the best cost is an integer value, it suggests that the program might have discovered a feasible solution and is trapped within it. This &ldquo;stuck counter&rdquo; proves to be a valuable stopping criterion.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Matlab data-lang=Matlab><span style=display:flex><span><span style=color:#66d9ef>for</span> it = <span style=color:#ae81ff>1</span>:MaxIt
</span></span><span style=display:flex><span>    <span style=color:#75715e>% The visualization allows tracking the allocation of weights into bins as the algorithm progresses.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> it <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> BestCost(it, <span style=color:#ae81ff>1</span>) <span style=color:#f92672>~=</span> BestCost(it<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        Solution = zeros(max(model.w), BestSol.Sol.nBin);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i = <span style=color:#ae81ff>1</span>:BestSol.Sol.nBin
</span></span><span style=display:flex><span>            BWeights = cell2mat(BestSol.Sol.BWeights(i));
</span></span><span style=display:flex><span>            Solution(<span style=color:#ae81ff>1</span>:length(BWeights), i) = BWeights<span style=color:#f92672>&#39;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>        
</span></span><span style=display:flex><span>        figure(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        bar(Solution<span style=color:#f92672>&#39;</span>, <span style=color:#e6db74>&#39;stacked&#39;</span>)
</span></span><span style=display:flex><span>        title(<span style=color:#e6db74>&#39;Weights assignment&#39;</span>)
</span></span><span style=display:flex><span>        xlabel(<span style=color:#e6db74>&#39;Bins&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Stopping criteria</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (it <span style=color:#f92672>&gt;</span>= <span style=color:#ae81ff>50</span>)  
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (BestCost(it, <span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> BestCost(it<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>&amp;&amp;</span> BestCost(it, <span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> floor(BestCost(it, <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>            <span style=color:#75715e>% Handling stagnation in feasible solution</span>
</span></span><span style=display:flex><span>            stuckCounter = stuckCounter <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (stuckCounter <span style=color:#f92672>==</span> <span style=color:#ae81ff>100</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;        
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elseif</span> (BestCost(it, <span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> BestCost(it<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>            <span style=color:#75715e>% Handling stagnation in unfeasible solution</span>
</span></span><span style=display:flex><span>            stuckCounter = stuckCounter <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (stuckCounter <span style=color:#f92672>==</span> <span style=color:#ae81ff>1000</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;        
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> 
</span></span><span style=display:flex><span>            stuckCounter = <span style=color:#ae81ff>1</span>;   
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h3 id=22-initialization-crossing-and-mutation>2.2. Initialization, Crossing and Mutation
<a class=anchor href=#22-initialization-crossing-and-mutation>#</a></h3><p>Analogous to previous chapter, the algorithm is started by initializing the population. This is done by creating a structure <code>empty_individual</code> and then populating pop with random positions for each individual. The fitness cost of each individual is also evaluated using the provided objective function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Matlab data-lang=Matlab><span style=display:flex><span>empty_individual.Position = [];
</span></span><span style=display:flex><span>empty_individual.Cost = [];
</span></span><span style=display:flex><span>empty_individual.Sol = [];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pop = repmat(empty_individual, nPop, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i = <span style=color:#ae81ff>1</span>:nPop
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Initialize Position</span>
</span></span><span style=display:flex><span>    pop(i).Position = randperm(nVar);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Evaluate Fitness (Cost) based on the objective function</span>
</span></span><span style=display:flex><span>    [pop(i).Cost, pop(i).Sol] = CostFunction(pop(i).Position);
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Following to population initialization, the parents individuals are selected using roulette wheel selection. Afterwards, crossover to generate offspring is performed, and again, the fitness of the offspring based on the objective function is evaluated.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Matlab data-lang=Matlab><span style=display:flex><span>popc = repmat(empty_individual, nc<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> k = <span style=color:#ae81ff>1</span>:nc<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Select Parents using Roulette Wheel Selection</span>
</span></span><span style=display:flex><span>    i1 = GA_RouletteWheelSelection(P);
</span></span><span style=display:flex><span>    i2 = GA_RouletteWheelSelection(P);
</span></span><span style=display:flex><span>    p1 = pop(i1);
</span></span><span style=display:flex><span>    p2 = pop(i2);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Apply Crossover</span>
</span></span><span style=display:flex><span>    [popc(k, <span style=color:#ae81ff>1</span>).Position, popc(k, <span style=color:#ae81ff>2</span>).Position] = GA_PermutationCrossover(p1.Position, p2.Position);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Evaluate Offsprings&#39; Fitness</span>
</span></span><span style=display:flex><span>    [popc(k, <span style=color:#ae81ff>1</span>).Cost, popc(k, <span style=color:#ae81ff>1</span>).Sol] = CostFunction(popc(k, <span style=color:#ae81ff>1</span>).Position);
</span></span><span style=display:flex><span>    [popc(k, <span style=color:#ae81ff>2</span>).Cost, popc(k, <span style=color:#ae81ff>2</span>).Sol] = CostFunction(popc(k, <span style=color:#ae81ff>2</span>).Position);
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>popc = popc(:);
</span></span></code></pre></div><p>The <code>GA_PermutationCrossover</code> and <code>GA_RouletteWheelSelection</code> are relatively simple implementations. <code>GA_PermutationCrossover</code> performs a permutation-based crossover operation for GAs on two parent individuals <code>x1</code> and <code>x2</code>. On the other hand, tThe function <code>GA_RouletteWheelSelection</code> is an utility function used in GAs for selecting individuals based on a roulette wheel selection scheme. Given a set of probabilities <code>P</code>, it selects an individual index based on these probabilities using a random number <code>r</code>. This function helps in the selection process during crossover operations.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Matlab data-lang=Matlab><span style=display:flex><span><span style=color:#66d9ef>function</span> [y1, y2] = <span style=color:#a6e22e>GA_PermutationCrossover</span>(x1,x2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    nVar=numel(x1);   
</span></span><span style=display:flex><span>    c=randi([<span style=color:#ae81ff>1</span> nVar<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    x11=x1(<span style=color:#ae81ff>1</span>:c);
</span></span><span style=display:flex><span>    x12=x1(c<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:<span style=color:#66d9ef>end</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    x21=x2(<span style=color:#ae81ff>1</span>:c);
</span></span><span style=display:flex><span>    x22=x2(c<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:<span style=color:#66d9ef>end</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    r1=intersect(x11,x22);
</span></span><span style=display:flex><span>    r2=intersect(x21,x12);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    x11(ismember(x11,r1))=r2;
</span></span><span style=display:flex><span>    x21(ismember(x21,r2))=r1; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    y1=[x11 x22];
</span></span><span style=display:flex><span>    y2=[x21 x12];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> i = <span style=color:#a6e22e>GA_RouletteWheelSelection</span>(P)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    r=rand;    
</span></span><span style=display:flex><span>    C=cumsum(P);   
</span></span><span style=display:flex><span>    i=find(r<span style=color:#f92672>&lt;</span>=C,<span style=color:#ae81ff>1</span>,<span style=color:#e6db74>&#39;first&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>This process ensures that the offspring have a mixture of segments from both parents while maintaining the uniqueness of elements within segments. Further on, part of the individuals from the population for mutation are selected for mutation. Hence, their positions are mutated and the fitness of the resulting mutants using the provided objective function is also evaluated.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Matlab data-lang=Matlab><span style=display:flex><span>popm = repmat(empty_individual, nm, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> k = <span style=color:#ae81ff>1</span>:nm
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Select Parent Index</span>
</span></span><span style=display:flex><span>    i = randi([<span style=color:#ae81ff>1</span>, nPop]);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Select Parent</span>
</span></span><span style=display:flex><span>    p = pop(i);
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Apply Mutation</span>
</span></span><span style=display:flex><span>    popm(k).Position = GA_PermutationMutate(p.Position);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Evaluate Mutant&#39;s Fitness</span>
</span></span><span style=display:flex><span>    [popm(k).Cost, popm(k).Sol] = CostFunction(popm(k).Position);
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>The function <code>GA_PermutationMutate</code> randomnly selects one of three mutation operations: swap, reversion, or insertion, and applies the chosen mutation to the individual <code>x</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Matlab data-lang=Matlab><span style=display:flex><span><span style=color:#66d9ef>function</span> y = <span style=color:#a6e22e>GA_PermutationMutate</span>(x)
</span></span><span style=display:flex><span>    M=randi([<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>3</span>]);   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> M
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>% Swap</span>
</span></span><span style=display:flex><span>            y=DoSwap(x);            
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>% Reversion</span>
</span></span><span style=display:flex><span>            y=DoReversion(x);            
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>% Insertion</span>
</span></span><span style=display:flex><span>            y=DoInsertion(x);            
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> y=<span style=color:#a6e22e>DoSwap</span>(x)   
</span></span><span style=display:flex><span>    n=numel(x);    
</span></span><span style=display:flex><span>    i=randsample(n,<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    i1=i(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    i2=i(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    y=x;
</span></span><span style=display:flex><span>    y([i1 i2])=x([i2 i1]);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> y=<span style=color:#a6e22e>DoReversion</span>(x)
</span></span><span style=display:flex><span>    n=numel(x);  
</span></span><span style=display:flex><span>    i=randsample(n,<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    i1=min(i(<span style=color:#ae81ff>1</span>),i(<span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    i2=max(i(<span style=color:#ae81ff>1</span>),i(<span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    y=x;
</span></span><span style=display:flex><span>    y(i1:i2)=x(i2:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>:i1);
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> y=<span style=color:#a6e22e>DoInsertion</span>(x)
</span></span><span style=display:flex><span>    n=numel(x);  
</span></span><span style=display:flex><span>    i=randsample(n,<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    i1=i(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    i2=i(<span style=color:#ae81ff>2</span>); 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> i1<span style=color:#f92672>&lt;</span>i2
</span></span><span style=display:flex><span>        y=[x(<span style=color:#ae81ff>1</span>:i1<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) x(i1<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:i2) x(i1) x(i2<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:<span style=color:#66d9ef>end</span>)];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        y=[x(<span style=color:#ae81ff>1</span>:i2) x(i1) x(i2<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:i1<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) x(i1<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:<span style=color:#66d9ef>end</span>)];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Basically, it selects one of the mutation operations based on a <code>randomized M</code>and applies it to the input permutation <code>x</code>, resulting in a modified permutation <code>y</code>.</p><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p><p>M is a random integer between 1 and 3, determining the type of mutation to be performed.</p><ul><li>M = 1: Swap mutation</li><li>M = 2: Reversion mutation</li><li>M = 3: Insertion mutation</li></ul></blockquote><p>These mutation operations introduce diversity in the population by altering individuals to explore different regions of the search space in the GA.</p><h2 id=3-results>3 Results
<a class=anchor href=#3-results>#</a></h2><h3 id=31-first-benchmark>3.1. First Benchmark
<a class=anchor href=#31-first-benchmark>#</a></h3><p>In the GA algorithm, the primary parameters for adjustment include population size <code>nPop</code>, crossover probability <code>pc</code>, and mutation probability <code>pm</code>. Initial trials utilized high crossover and low mutation probabilities, aligning with common recommendations. Each parameter set underwent 100 tests to offer a comprehensive understanding of their impact. Results for a population size of 100 are detailed below.</p><table><thead><tr><th>Crossover</th><th>Mutation</th><th># Optimal</th><th># Non-Opt</th><th># Non Feasible</th><th>AVG Time (s)</th><th>Best Time (s)</th></tr></thead><tbody><tr><td>0.8</td><td>0.1</td><td>57</td><td>25</td><td>18</td><td>16.7065</td><td>2.9367</td></tr><tr><td>0.4</td><td>0.1</td><td>60</td><td>23</td><td>17</td><td>10.2069</td><td>2.2047</td></tr><tr><td>0.4</td><td>0.5</td><td>79</td><td>12</td><td>9</td><td>8.4275</td><td>2.6534</td></tr><tr><td>0.1</td><td>0.9</td><td>80</td><td>12</td><td>8</td><td>7.5532</td><td>3.0711</td></tr><tr><td>0.1</td><td>0.5</td><td><strong>81</strong></td><td>6</td><td>13</td><td><strong>7.1172</strong></td><td><strong>2.1431</strong></td></tr><tr><td>0.2</td><td>0.8</td><td>75</td><td>10</td><td>15</td><td>9.0226</td><td>3.1714</td></tr></tbody></table><p>The bold highlights denote the best outcomes. Surprisingly, a higher mutation probability proves advantageous for this specific problem, whereas the crossover probability appears less influential. The most favorable result achieved 81 optimal solutions out of 100 simulations, a decent outcome but with room for improvement. Reducing the population size to 50 and retesting yielded the results detailed as follows:</p><table><thead><tr><th>Crossover</th><th>Mutation</th><th># Optimal</th><th># Non-Opt</th><th># Non Feasible</th><th>AVG Time (s)</th><th>Best Time (s)</th></tr></thead><tbody><tr><td>0.8</td><td>0.1</td><td>43</td><td>27</td><td>30</td><td>13.1624</td><td>2.2969</td></tr><tr><td>0.4</td><td>0.1</td><td>34</td><td>26</td><td>40</td><td>8.3888</td><td>1.5564</td></tr><tr><td>0.4</td><td>0.5</td><td>66</td><td>19</td><td>15</td><td>6.2721</td><td>1.4918</td></tr><tr><td>0.1</td><td>0.9</td><td>78</td><td>14</td><td>8</td><td>4.7672</td><td>1.7086</td></tr><tr><td>0.1</td><td>0.5</td><td>75</td><td>13</td><td>12</td><td><strong>4.6430</strong></td><td><strong>1.334</strong></td></tr><tr><td>0.2</td><td>0.8</td><td><strong>83</strong></td><td>8</td><td>9</td><td>5.3174</td><td>1.6009</td></tr></tbody></table><p>When the population size reduced to 50, the results remained close to those with 100. Notably, simulations ran faster with the smaller population, requiring a higher mutation probability for good outcomes (50% mutation wasn’t sufficient for 50 individuals, while it performed well with 100). Optimal results — 83 in total — were achieved with a 0.2 crossover, 0.8 mutation, and a population of 50. Although some parameter sets were faster, their lower accuracy led to their exclusion.</p><p>Further tests with varying population sizes indicated that a higher population slowed simulations without improving optimal solutions. Conversely, lower populations sped up the process but resulted in fewer optimal solutions due to the algorithm getting stuck in local minimums. Hence, a population size of 50 proved optimal.</p><blockquote class="book-hint2 info"><p class="hint-title info"><svg class="book-icon"><use href="/svg/hint-icons.svg#info-notice"/></svg><span>info</span></p>Attempts to modify and test the selection probabilities function yielded inconclusive results.</blockquote><p>In the initial benchmark, the GA underwent testing with the parameters: population size <code>nPop = 50</code>, crossover probability <code>pc = 0.2</code>, and mutation probability <code>pm = 0.8</code>. A single simulation&rsquo;s outcome is depicted as follows:</p><p><img src=https://live.staticflickr.com/65535/53359214487_89cbbc4d1d.jpg alt=wqdj></p><p><img src=https://live.staticflickr.com/65535/53359214442_857c059317_b.jpg alt=3i></p><p>In this simulation, the GA algorithm reached a stopping criterion after 390 iterations, concluding within 7.55 seconds. The algorithm demonstrated swift convergence. The average cost across the population closely mirrored the best cost, albeit with a slight delay, eventually settling at 15.</p><h3 id=32-second-benchmark>3.2. Second Benchmark
<a class=anchor href=#32-second-benchmark>#</a></h3><p>In the second benchmark, the GA was tested with identical parameters to the first benchmark: population size <code>nPop = 50</code>, crossover probability <code>pc = 0.2</code>, and mutation probability <code>pm = 0.8</code>. While the algorithm may not produce the same result in every simulation, after several runs, it managed to approach a near-optimal solution, achieving 101 bins. Results are visualized below.</p><p><img src=https://live.staticflickr.com/65535/53360419414_5ec7249cc5.jpg alt=3i2kd></p><p><img src=https://live.staticflickr.com/65535/53360310158_6129aa5ea6_b.jpg alt=sad0></p><p>In this simulation, the GA algorithm required 5583 iterations over 237 seconds before meeting the stopping criteria. Interestingly, the average cost of the particles matched the global best cost. The algorithm exhibited swift convergence initially but encountered challenges in converging to a feasible solution.</p><p>Despite attempts to achieve 100 bins by tweaking parameters, the algorithm consistently faced difficulties. It often became stuck with just a few bin violations unresolved, persisting even after nearly 20000 iterations, resulting in non-feasible solutions slightly above a cost of 100. The randomness inherent in the GA can contribute to such outcomes, making luck a potential factor in its performance.</p><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p><p><a href=https://ricardochin.com/docs/code/bin-packing/particle-swarm-optimization/>Implementation of PSO</a></p><p><a href=https://ricardochin.com/docs/code/bin-packing/#5-ending-thoughts>Comparison between GA and PSO</a></p></blockquote></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/roaked/roaked.github.io/commit/89198c5e7f9e2ca8bcb793e07ff578427e3247f1 title='Last modified by roaked | February 16, 2024' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>February 16, 2024</span></a></div><div><a class="flex align-center" href=https://github.com/roaked/roaked.github.io/edit/main/content/content/docs/code/bin-packing/genetic-algorithm.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Ricardo Chin</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#1-theoretical-remarks>1 Theoretical Remarks</a></li><li><a href=#2-code-implementation>2 Code Implementation</a><ul><li><a href=#21-cost-function-and-stopping-criteria>2.1. Cost Function and Stopping Criteria</a></li><li><a href=#22-initialization-crossing-and-mutation>2.2. Initialization, Crossing and Mutation</a></li></ul></li><li><a href=#3-results>3 Results</a><ul><li><a href=#31-first-benchmark>3.1. First Benchmark</a></li><li><a href=#32-second-benchmark>3.2. Second Benchmark</a></li></ul></li></ul></nav></div></aside></main></body></html>