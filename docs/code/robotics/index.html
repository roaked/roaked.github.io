<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  KUKA: From Kinematics to Motion Planning
  #



  
    
      
        
      warning
    
Tweaks: safe reinforcement learning -> incl. optimistic exploration instead of specifying a trajectory


  


  1 Abstract
  #

This research centers on the kinematic analysis of the KUKA KR6 R700 robot, which is installed on a linear KL100 axis. The KUKA KR6 R700 is an industrial robot designed for tasks such as tool and fixture handling, as well as processing or transferring components or products."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://xsleaks.dev/docs/code/robotics/"><meta property="og:site_name" content="Ricardo Chin"><meta property="og:title" content="Robotics: Kin, Dynamics & Control"><meta property="og:description" content="KUKA: From Kinematics to Motion Planning # warning
Tweaks: safe reinforcement learning -> incl. optimistic exploration instead of specifying a trajectory 1 Abstract # This research centers on the kinematic analysis of the KUKA KR6 R700 robot, which is installed on a linear KL100 axis. The KUKA KR6 R700 is an industrial robot designed for tasks such as tool and fixture handling, as well as processing or transferring components or products."><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><title>Robotics: Kin, Dynamics & Control | Ricardo Chin</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.b74e85bd7803de00c09a320dcf09ae0d7e37702a9918995f5fe9d1c71c55a223.css integrity="sha256-t06FvXgD3gDAmjINzwmuDX43cCqZGJlfX+nRxxxVoiM=" crossorigin=anonymous><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><link rel=alternate type=application/rss+xml href=https://xsleaks.dev/docs/code/robotics/index.xml title="Ricardo Chin"></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Ricardo Chin</span></a></h2><ul><li class=book-section-flat><a href=/docs/design/>Engineering Repository</a><ul><li><a href=/docs/design/fea-beam-simulation/>FEA Beam Instability Modes</a><ul></ul></li><li><a href=/docs/design/finite-element-method-development/>FEM Package Development</a><ul></ul></li></ul></li><li class=book-section-flat><a href=/docs/code/>System Repository</a><ul><li><a href=/docs/code/agv/>AGV: Stochastic Identification</a><ul></ul></li><li><a href=/docs/code/uav/>UAV: Red Bull Air Racing</a><ul><li><a href=/docs/code/uav/dynamics/>Drone System Dynamics</a></li><li><a href=/docs/code/uav/continuous-controller-design/>Continuous Controller</a></li><li><a href=/docs/code/uav/discrete-controller-design/>Discrete Controller</a></li><li><a href=/docs/code/uav/computer-vision/>Gate Sense: Computer Vision</a></li></ul></li><li><a href=/docs/code/robotics/ class=active>Robotics: Kin, Dynamics & Control</a><ul></ul></li><li><a href=/docs/code/deep-learning-fake-news/>Fake News: Inference & Clusters</a><ul></ul></li><li><a href=/docs/code/bin-packing/>EC Optimization: Space & Time</a><ul><li><a href=/docs/code/bin-packing/genetic-algorithm/>Genetic Algorithm</a></li><li><a href=/docs/code/bin-packing/particle-swarm-optimization/>Particle Swarm Optimization</a></li></ul></li><li><a href=/docs/code/snake-game/>Snake: Reinforcement Learning</a><ul><li><a href=/docs/code/snake-game/deepqnetwork/>Off Policy RL & Neuroevolution</a></li><li><a href=/docs/code/snake-game/adversarial/>Adversarial Multi-Agent RL</a></li></ul></li></ul></li><li class=book-section-flat><a href=/docs/lectures/>My Notes and Lectures</a><ul><li><a href=/docs/lectures/bayesian-machine-learning/bayes/>Bayesian Inference</a></li><li><a href=/docs/lectures/bayesian-optimization/bayesopt/>Bayesian Optimization</a></li><li><a href=/docs/lectures/nonlinear-pro/nonlinear/>Nonlinear Programming</a></li></ul></li><li class=book-section-flat><a href=/docs/competitions/>Academic Competitions</a><ul><li><a href=/docs/competitions/fst/>Formula Student Lisbon</a></li><li><a href=/docs/competitions/thermocup/>ThermoCup</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Robotics: Kin, Dynamics & Control</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#1-abstract>1 Abstract</a></li><li><a href=#2-kinematics>2 Kinematics</a></li><li><a href=#3-direct-kinematics>3 Direct Kinematics</a><ul><li><a href=#31-validation>3.1. Validation</a></li><li><a href=#32-joint-trajectories>3.2. Joint Trajectories</a></li></ul></li><li><a href=#4-inverse-kinematics>4 Inverse Kinematics</a><ul><li><a href=#41-validation>4.1. Validation</a></li></ul></li><li><a href=#5-geometric-jacobian>5 Geometric Jacobian</a><ul><li><a href=#51-position-validation>5.1. Position Validation</a></li><li><a href=#52-orientation-validation>5.2. Orientation Validation</a></li><li><a href=#53-kinematic-singularities>5.3. Kinematic Singularities</a></li></ul></li><li><a href=#6-closed-loop-inverse-kinematics-clik>6 Closed Loop Inverse Kinematics (CLIK)</a></li><li><a href=#7-link-properties>7 Link Properties</a></li><li><a href=#8-newton-euler-formulation>8 Newton-Euler Formulation</a><ul><li><a href=#81-validation>8.1. Validation</a></li></ul></li><li><a href=#9-decentralized-pid-joint-controllers>9 Decentralized PID Joint Controllers</a><ul><li><a href=#91-stiffness-and-damping-gains>9.1. Stiffness and Damping Gains</a></li><li><a href=#92-worst-case-inertia>9.2. Worst Case Inertia</a></li><li><a href=#93-controller-gains-tuning>9.3. Controller Gains Tuning</a></li></ul></li><li><a href=#10-centralized-controller>10 Centralized Controller</a><ul><li><a href=#101-controller-gains-tuning>10.1. Controller Gains Tuning</a></li></ul></li><li><a href=#11-trajectory-planning>11 Trajectory Planning</a><ul><li><a href=#111-trajectory-with-decentralized-controller>11.1. Trajectory with Decentralized Controller</a></li><li><a href=#112-trajectory-with-centralized-controller>11.2. Trajectory with Centralized Controller</a></li></ul></li><li><a href=#12-final-remarks>12 Final Remarks</a></li></ul></nav></aside></header><article class=markdown><h1 id=kuka-from-kinematics-to-motion-planning>KUKA: From Kinematics to Motion Planning
<a class=anchor href=#kuka-from-kinematics-to-motion-planning>#</a></h1><p><img src=https://blogs.mathworks.com/images/seth/2009Q2/Robot.gif alt=soakd></p><blockquote class="book-hint2 warning"><p class="hint-title warning"><svg class="book-icon"><use href="/svg/hint-icons.svg#warning-notice"/></svg><span>warning</span></p><ul><li><strong>Tweaks:</strong> safe reinforcement learning -> incl. optimistic exploration instead of specifying a trajectory</li></ul></blockquote><h2 id=1-abstract>1 Abstract
<a class=anchor href=#1-abstract>#</a></h2><p>This research centers on the kinematic analysis of the KUKA KR6 R700 robot, which is installed on a linear KL100 axis. The KUKA KR6 R700 is an industrial robot designed for tasks such as tool and fixture handling, as well as processing or transferring components or products.</p><p>The initial phase of studying the robot involves analyzing and constructing its kinematic model based on the Denavit-Hartenberg convention, with a focus on selecting the link reference frames.</p><p>Presented and validated through various Simulink models, it is intended to ease the extraction of the robot&rsquo;s direct kinematics, inverse kinematics, geometric Jacobian, and Closed Loop Inverse Kinematics (CLIK).</p><h2 id=2-kinematics>2 Kinematics
<a class=anchor href=#2-kinematics>#</a></h2><p>The robot consists on the presence of 6 revolute joints. Additionally, there is a single prismatic joint that facilitates horizontal movement of the robot. Consequently, the overall configuration of the robot comprises a total of 7 links.</p><p><img src=https://live.staticflickr.com/65535/53469950810_c67521134d.jpg alt=1></p><p><img src=https://live.staticflickr.com/65535/53469851949_b3914f719c.jpg alt=2></p><p>Utilizing the convention of <a href=https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters>Denavit-Hartenberg (DH)</a>, reference frames for each link can be drawn.</p><p><img src=https://live.staticflickr.com/65535/53469851939_221cf7f814.jpg alt=3></p><p>The dimensions <code>a2</code>, <code>a3</code>, <code>a4</code>, <code>d5</code> and <code>d7</code> are known. Hence, the table of DH can be built.</p><table><thead><tr><th>Link</th><th>di [ m]</th><th>ùúói [ rad]</th><th>ai [ m]</th><th>Œ± [ rad]</th><th>offset [ rad]</th></tr></thead><tbody><tr><td>1</td><td>d1</td><td>0</td><td>0</td><td>-œÄ/2</td><td>0</td></tr><tr><td>2</td><td>0</td><td>ùúó2</td><td>0.025</td><td>œÄ/2</td><td>0</td></tr><tr><td>3</td><td>0</td><td>ùúó3</td><td>0.315</td><td>0</td><td>0</td></tr><tr><td>4</td><td>0</td><td>ùúó4</td><td>0.035</td><td>œÄ/2</td><td>0</td></tr><tr><td>5</td><td>-0.365</td><td>ùúó5</td><td>0</td><td>-œÄ/2</td><td>0</td></tr><tr><td>6</td><td>0</td><td>ùúó6</td><td>0</td><td>œÄ/2</td><td>0</td></tr><tr><td>7</td><td>-0.080</td><td>ùúó7</td><td>0</td><td>œÄ</td><td>0</td></tr></tbody></table><p>For this robot, the vector of joint variables <code>q</code> can be expressed as:</p><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><span>\[q = [ d1 \hspace{.2cm} \vartheta_2 \hspace{.2cm} \vartheta_3 \hspace{.2cm} \vartheta_4 \hspace{.2cm} \vartheta_5 \hspace{.2cm} \vartheta_6 \hspace{.2cm} \vartheta_7 ]^T\]</span><h2 id=3-direct-kinematics>3 Direct Kinematics
<a class=anchor href=#3-direct-kinematics>#</a></h2><p>Through the direct kinematics analysis, one can compute the position and orientation of the end effector by considering the values of the joint variables within the vector <code>q</code>.</p><span>\[A_{i}^{i-1} = \begin{bmatrix}
R_{i}^{i-1} & r_{i-1, i}^{i-1} \\
0^T & 1
\end{bmatrix}\]</span><p><code>R</code> being the rotation matrix from link <code>i-1</code> to <code>i</code> and <code>r</code> the position vector from link <code>i-1</code> to <code>i</code>. Generalizing for a joint variable <span>\(\vartheta_i\)
</span>:</p><span>\[A_{i-1}^{i}(\theta_i) = \begin{bmatrix}
c_i & -s_i c_i & s_i c_i & a_i c_i \\
s_i & c_i c_i & -c_i s_i & a_i s_i \\
0 & s_i & c_i & d_i \\
0 & 0 & 0 & 1
\end{bmatrix}\]</span><p>The transformation matrix for 7 links:</p><span>\[T_7^0 = A_1^0 A_2^1 A_3^2 A_4^3 A_4^5 A_6^5 A_7^6\]</span><p>In MATLAB, the calculations described are executed using the functions <a href=https://github.com/roaked/robotics-kinematics-dynamics-and-control/blob/main/DKin.m>DKin.m</a> and <a href=https://github.com/roaked/robotics-kinematics-dynamics-and-control/blob/main/DHTransf.m>DHTransf.m</a>. These functions were initially provided as a toolbox, and <a href=https://github.com/roaked/robotics-kinematics-dynamics-and-control/blob/main/DKin.m>DKin.m</a> was modified to include the computation of the Jacobian matrix for future use. A MATLAB Function Block was then crafted from these functions, integrated into the Simulink model. This block takes the <code>q</code> vector as inputs and outputs the rotation matrix, position vector, and Jacobian matrix.</p><p>Another essential function, <a href=https://github.com/roaked/robotics-kinematics-dynamics-and-control/blob/main/vrrobot.m>vrrobot.m</a>, is employed to create a virtual representation of the robot within a simulated environment. By adding meshes to the links, the robot gains a tangible form beyond just reference frames.</p><p>The resulting Simulink model incorporates two input options for the <code>q</code> vector: sliders or trajectory. The <code>q</code> vector is fed into both the direct kinematics block and the animation block (VR sink), providing a comprehensive visualization of the robot&rsquo;s movements.</p><p><img src=https://live.staticflickr.com/65535/53469950785_90a2919709_c.jpg alt=4></p><h3 id=31-validation>3.1. Validation
<a class=anchor href=#31-validation>#</a></h3><h4 id=311-pose-one>3.1.1. Pose One
<a class=anchor href=#311-pose-one>#</a></h4><p>The initial validation involves inputting a set of known coordinates, denoted as <code>q</code>, and verifying if the resulting rotation matrix and position vector of the end effector align with the anticipated outcomes. During this validation process, certain adjustments to the offsets were necessary. Specifically, a -90¬∫ offset was applied to joint <code>q4</code>, and a +180¬∫ offset was applied to joint <code>q7</code>, with these values determined through the validation process. To define the <code>q</code> vector, sliders were employed.</p><p>A significant consideration is that the base reference frame used for validation differs from the zeroth frame defined in the kinematic model (frame 0). This distinction is illustrated when observing the robot in the virtual world. To enhance representation, the x-axis is depicted in red, the y-axis in green, and the z-axis in blue. Additionally, a distance d1 was set to separate the robot from frame 0, ensuring accurate validation.</p><p><img src=https://live.staticflickr.com/65535/53469533961_844a2cbdc2_z.jpg alt=5></p><p>Thus, a transformation from the base reference frame to frame 0 becomes necessary, encompassing both rotation and translation. The rotational aspect is characterized by:</p><span>\[R_{0}^b = \begin{bmatrix}
0 & 0 & -1 \\
1 & 0 & 0 \\
0 & -1 & 0
\end{bmatrix}\]</span><p>Therefore the rotation matrix from base to end effector is defined as:</p><span>\[R_7^b = R_0^b R_7^0\]</span><p>Simultaneously, the translation using the position vector:</p><span>\[r_{b,0}^b = [0 \hspace{.2cm} 0 \hspace{.2cm} 0.756 ]^T\]</span><p>The position vector from base to end effector is defined as:</p><span>\[r_{b,7}^b = r_{b,0}^b + r_{0,7}^b = r_{b,0}^b + R_{0}^b r_{0,7}^0\]</span><p>Analytical results are:</p><span>\[R_{7}^b = \begin{bmatrix}
0 & -1 & 0 \\
0 & 0 & 1 \\
-1 & 0 & 0
\end{bmatrix}\]
</span><span>\[r_{b,7}^b = [0 \hspace{.2cm} 0.470 \hspace{.2cm} 1.106]^T (m)\]</span><p>Simulink results given by:</p><p><img src=https://live.staticflickr.com/65535/53469851914_780545e45b_z.jpg alt=6></p><p><img src=https://live.staticflickr.com/65535/53468628947_f0e300b867_c.jpg alt=7></p><h4 id=312-pose-two>3.1.2. Pose Two
<a class=anchor href=#312-pose-two>#</a></h4><p>Analytical results are:</p><span>\[R_{7}^b = \begin{bmatrix}
0.249 & -0.457 & 0.854 \\
-0.957 & -0.251 & 0.145 \\
0.148 & -0.853 & -0.500
\end{bmatrix}\]
</span><span>\[r_{b,7}^b = [0.20163 \hspace{.2cm} 0.44482 \hspace{.2cm} 0.97382]^T (m)\]</span><p>Simulink results given by:</p><p><img src=https://live.staticflickr.com/65535/53469533951_c423d1b57f_z.jpg alt=8></p><p><img src=https://live.staticflickr.com/65535/53469533956_5b76d48ea0_c.jpg alt=9></p><h3 id=32-joint-trajectories>3.2. Joint Trajectories
<a class=anchor href=#32-joint-trajectories>#</a></h3><p>To conduct further testing of the direct kinematics, a series of joint trajectories was incorporated into the Simulink model, selectable by manipulating a manual switch. Initially, a set of ramps was chosen for the inputs, with the exception of joint <code>q1</code>, where a sine input was employed. This decision was made to avoid impractical robot movement away from the base, given the nature of a ramp input. Each ramp trajectory was individually examined to ensure that the robot&rsquo;s motion aligned with the anticipated behaviour.</p><p>For instance, a specific scenario involved fixing all joints except for <code>q2</code>, which theoretically should result in the robot spinning around itself. To validate this trajectory, an XY plot was generated from the base reference frame to visually confirm the expected movement.</p><p><img src=https://live.staticflickr.com/65535/53469851894_5d06d7bd7d_b.jpg alt=10></p><p>Another test involved applying sinusoidal inputs to all joints simultaneously. This particular test proved valuable as it enabled the movement of all joints concurrently without the risk of robot links intersecting or colliding with each other, a scenario not feasible in a physical robot.</p><p><img src=https://live.staticflickr.com/65535/53469533946_d84d6bd8d9.jpg alt=11></p><h2 id=4-inverse-kinematics>4 Inverse Kinematics
<a class=anchor href=#4-inverse-kinematics>#</a></h2><p>Inverse kinematics involves determining the values of the joint variables <code>q</code>, given the position and orientation of the end effector. It&rsquo;s important to note that solving such problems may yield multiple solutions.</p><p>In the case of the KR6, the end effector&rsquo;s position and orientation are described by 6 parameters: three displacements (<code>x</code>, <code>y</code>, <code>z</code>) and three Euler angles (<span>
\(\phi\)
</span>, <span>\(\theta\)
</span>, <span>\(\psi\)
</span>). However, the robot has 7 links, indicating it possesses 7 degrees of freedom. This redundancy implies that, to solve the inverse kinematics problem, one of the joint variables must be specified initially. In this scenario, <code>q1</code>, corresponding to the prismatic joint, was chosen to be fixed, leaving 6 degrees of freedom to be determined.</p><p>To address this, a kinematic decoupling approach was adopted. This involves separating the arm and wrist, solving the arm joints first and then addressing the wrist joints. This strategy simplifies the inverse kinematics problem and facilitates a systematic solution to determine the joint variables.</p><p><img src=https://live.staticflickr.com/65535/53469672968_55e4fe8b0c_c.jpg alt=12></p><p>The wrist&rsquo;s position serves as a reference point for calculating the initial four parameters of the robot. Beginning with the end effector&rsquo;s position, the wrist&rsquo;s position can be computed.</p><span>\[p_w = p_{07} - d_7 \times z_7^0 - [\begin{bmatrix} 0 \\ 0 \\ q_1 \end{bmatrix}]\]</span><p>It&rsquo;s crucial to note that all subsequent calculations utilize reference frame 0&rsquo;, which corresponds to reference frame 0 translated with <code>q1</code>. Additionally, in these equations, <code>d5</code> and <code>d7</code> are assumed to be positive values. Furthermore, the equations provided are applicable for a shoulder-up configuration.</p><p><img src=https://live.staticflickr.com/65535/53468628917_1d8779ccb6_z.jpg alt=13></p><p><img src=https://live.staticflickr.com/65535/53469851864_32e835bddb_z.jpg alt=14></p><p>After extensive trigonometric algebra, <span>\(\alpha\)
</span>and <span>\(\beta\)
</span>are computed:</p><span>\[\alpha = atan2 (- p_{wy}, \sqrt{p_{wx}^2 + p_{wz}^2} - a_2)\]
</span><span>\[\beta = atan2 (a_w \sqrt{1-c_w^2}, a_3 + a_w c_w)\]</span><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p>After computing <code>q1</code>, <code>q2</code>, <code>q3</code> and <code>q4</code> only the wrist parameters are left to find. Hence, using rotation matrix 4 -> 7, it is possible to compute <code>q5</code>, <code>q6</code> and <code>q7</code>.</blockquote><p><img src=https://live.staticflickr.com/65535/53469851869_a78896bf27_c.jpg alt=15></p><p>The system offers two input options for <code>pd</code> and <code>Rd</code>:</p><ul><li><p>Option 1: Users can specify the end effector position and orientation using parameters <code>x</code>, <code>y</code>, <code>z</code> (combined to form <code>pd</code>) and the Euler angles <span>\(\phi\)
</span>, <span>\(\theta\)
</span>, <span>\(\psi\)
</span>. The rotation matrix <code>Rd</code> is derived from these Euler angles.</p></li><li><p>Option 2: Users can input joint variables <code>q</code>, which are then processed and transformed into <code>pd</code> and <code>Rd</code> through direct kinematics. This option is particularly useful for validation purposes.</p></li></ul><p>To select either Option 1 or Option 2, two manual switches are provided. Both switches should be consistently either up (Option 1) or down (Option 2). Once the option is chosen, <code>pd</code> and <code>Rd</code> are transformed into <code>p07</code> and <code>R07</code>.</p><p>The inverse kinematics block accepts four inputs: <code>p07</code>, <code>R07</code>, <code>q1</code>, and a vector defining the robot&rsquo;s configuration. The configuration vector should consist of integers 0 or 1, representing:</p><ol><li>The elbow&rsquo;s orientation (1 for up, 0 for down).</li><li>The wrist&rsquo;s s6 value (1 for positive, 0 for negative).</li><li>The robot&rsquo;s orientation (1 for facing forwards, 0 for facing backward).</li><li>An additional number to address out-of-boundary positions when <code>q1</code> is fixed. Setting this value to 1 allows <code>q1</code> to take the inputted value, while 0 aligns <code>q1</code> with <code>xb</code> from the end effector position relative to the base reference frame ‚Äî a &ldquo;free range&rdquo; configuration for <code>q1</code>.</li></ol><p>The output of the inverse kinematics block is the joints vector <code>q</code>, which feeds into the animation block (VR sink) and a direct kinematics block that outputs the obtained <code>R</code> and <code>p</code>. <code>q</code> is also displayed in a block labeled &ldquo;vector <code>q</code>&rdquo;. For validation purposes, a comparison is made between <code>pd</code> and <code>Rd</code> (desired) and <code>p</code> and <code>R</code> (obtained).</p><p>A switch at the bottom-left corner can be activated to halt the simulation when the robot encounters a singularity.</p><h3 id=41-validation>4.1. Validation
<a class=anchor href=#41-validation>#</a></h3><blockquote class="book-hint2 warning"><p class="hint-title warning"><svg class="book-icon"><use href="/svg/hint-icons.svg#warning-notice"/></svg><span>warning</span></p>To add later&mldr;</blockquote><h2 id=5-geometric-jacobian>5 Geometric Jacobian
<a class=anchor href=#5-geometric-jacobian>#</a></h2><p>The geometric Jacobian is a matrix that represents the relationship between joint velocities and the linear and angular velocities of the end effector in a robotic system. It is a crucial tool in robotics for understanding how changes in joint positions contribute to the overall motion of the robot&rsquo;s end effector.</p><span>\[J = \begin{bmatrix} J_P \\ J_O \end{bmatrix}\]</span><p>Here,</p><ul><li><span>\(J_P\)
</span>is a (3 √ó n) matrix that relates joint velocities to end effector linear velocities.</li><li><span>\(J_O\)
</span>is a (3 √ó n) matrix that relates joint velocities to end effector angular velocities.</li></ul><span>\[
\begin{bmatrix} \dot{p}_e \\
w_e
\end{bmatrix}
= \begin{bmatrix}
JP \\
JO
\end{bmatrix}
q\]</span><p>The best approach to compute the Jacobian is to separate the linear and angular velocities.</p><span>\[\dot{p_e} = \sum_{i=1}^{n} \frac{\partial p_e}{\partial q_i} \dot{q_i} = \sum_{i=1}^{n} J_{P_i} \dot{q}_i\]
</span><span>\[w_e = \sum_{i=1}^{n} w_{i-1,i} = \sum_{i=1}^{n} J_{O_i} \dot{q}_i\]</span><p>Every term in the Jacobian matrix signifies the velocity contribution of an individual joint <code>i</code> to the end effector when all other joints are held stationary.</p><ol><li><strong>Prismatic Joints</strong>:</li></ol><span>\[J_{P_i} = z_{i-1} \\
J_{O_i} = 0\]</span><ol start=2><li><strong>Revolute Joints</strong>:</li></ol><span>\[J_{P_i} = z_{i-1} (p_e - p_{i-1}) \\
J_{O_i} = z_{i-1}\]</span><p>As mentioned earlier, the computation of the Jacobian is encapsulated within the function <a href=https://github.com/roaked/robotics-kinematics-dynamics-and-control/blob/main/DKin.m>DKin.m</a>. This design proves beneficial as, in the process of calculating direct kinematics, the transformation matrix <span>\(T_0^i\)
</span>is computed for each link. To validate the Jacobian matrix, it is essential to compare the velocities obtained through the differentiation of the end effector position with the velocities obtained by multiplying the Jacobian matrix by the derivative of the joints vector, <span>\(\dot{q}\)
</span>. In essence, the following conditions need verification:</p><span>\[\dot{p_e} - \sum_{i=1}^{n} J_{P_i} \dot{q}_i = 0\]
</span><span>\[w_e - \sum_{i=1}^{n} J_{O_i} \dot{q}_i = 0\]</span><p>Having the following Simulink model:</p><p><img src=https://live.staticflickr.com/65535/53469950705_3cbb296754_c.jpg alt=23></p><p><img src=https://live.staticflickr.com/65535/53469950655_04a460ef38_b.jpg alt=24></p><p>In the first figure (the left side of the Simulink model), two types of inputs for <code>q</code> are available: sliders or trajectory. <code>q</code> enters the direct kinematics block and also the animation block <code>vrsink</code>. The second figure represents the validation process. For the validation process, sine wave functions were employed as inputs for <code>q</code>. This choice ensured that all joints would be moving simultaneously.</p><h3 id=51-position-validation>5.1. Position Validation
<a class=anchor href=#51-position-validation>#</a></h3><p><img src=https://live.staticflickr.com/65535/53469950660_4cb4f03c74_z.jpg alt=25></p><p>The values on the extreme right side represent the difference between velocities. Since the largest absolute number is on the order of <span>\(10^{-8} \)
</span>, it can be concluded that <span>\(J_P \)
</span>is validated, as these values can be considered approximately zero.</p><h3 id=52-orientation-validation>5.2. Orientation Validation
<a class=anchor href=#52-orientation-validation>#</a></h3><p>Following a similar approach, to obtain <span>\(w_e \)
</span>, matrix S is computed:</p><span>\[S = \dot{R}(t) \times R^T = \begin{bmatrix} 0 & -\omega_z & \omega_y \\ \omega_z & 0 & -\omega_x \\ -\omega_y & \omega_x & 0 \end{bmatrix}\]</span><p>R(t) represents the rotation matrix R in this case. S is a skew-symmetric operator, and its symmetric elements represent the components of the angular velocity vector <span>\(w_e\)
</span>. Note:</p><span>\[w_e = \begin{bmatrix} w_x w_y w_z \end{bmatrix}^T = \begin{bmatrix} S(3, 2) S(1, 3) S(2, 1) \end{bmatrix}^T\]</span><p>To validate <span>\(J_O\)
</span>, the difference between the angular velocity vector obtained from <code>S</code> and the angular velocity obtained from <span>\(J_O\)
</span>times <span>\(\dot{q}\)
</span>must tend to zero. Results in Simulink are shown below, having used the sine waves as inputs for vector <code>q</code>:</p><p><img src=https://live.staticflickr.com/65535/53469950650_509204d65c_z.jpg alt=27></p><h3 id=53-kinematic-singularities>5.3. Kinematic Singularities
<a class=anchor href=#53-kinematic-singularities>#</a></h3><h2 id=6-closed-loop-inverse-kinematics-clik>6 Closed Loop Inverse Kinematics (CLIK)
<a class=anchor href=#6-closed-loop-inverse-kinematics-clik>#</a></h2><p>CLIK allows to solve the inverse kinematics problem with a closed loop control, as the name implies.</p><p><img src=https://live.staticflickr.com/65535/53469672813_aacb08df0d_z.jpg alt=34></p><p>Given the redundancy of the manipulator, there is flexibility in how <span>\(\dot{q}\)
</span>and <span>\(J^{-1}(q)\)
</span>are computed. Initially, the inverse Jacobian <span>\(J^{-1}(q)\)
</span>can be substituted with the damped least squares inverse:</p><span>\[J^* = J^T(JJ^T + k^2I)^{-1}\]</span><p>The computation of <span>\(\dot{q}\)
</span>is modified to include the stabilization of the null-space:</p><span>\[\dot{q} = J^* v_e + (I_n - J^*J)\dot{q}_0\]</span><p><span>\(\dot{q}_0\)
</span>is given by:</p><span>\[\dot{q}_0 = k_0 \left(\frac{\partial w(q)}{\partial q}\right)^T\]</span><p><span>\(\omega\)
</span>(q) allows to maximize the distance from mechanical joint limits and is computed as:</p><span>\[w(q) = -\frac{1}{2n} \sum_{i=1}^{n} \left(\frac{q_i - \overline{q_i}}{q_{iM} + q_{im}}\right)^2\]</span><p>Hence, there are four distinct gains to consider: <span>\(K_P\)
</span>for position, <span>\(K_O\)
</span>for orientation, <code>k</code> for the damped least squares inverse and <span>\(k_0\)
</span>for null-space stabilization. It is imperative to fine-tune each of these gains to achieve the desired system behaviour.</p><p>Each gain exerts different influences on the system dynamics. For <code>k</code>, a low (or zero) value diminishes the damping effect on the damped least squares inverse, potentially leading to elevated initial velocities <span>\(\dot{q}\)
</span>. Conversely, a high gain results in excessive damping, causing the system to take more time to reach the desired position.</p><p>Regarding the null-space stabilization gain <span>\(k_0\)
</span>, a low value prolongs the system&rsquo;s convergence time to the desired solution. Conversely, a high value may introduce slight instability, causing the joints to continue moving even after the robot reaches the desired position as it attempts to minimize the distance from the joint limits <span>\(\omega\)
</span>(q). If <span>\(k_0\)
</span>is excessively high, the computational load also becomes extensive.</p><p><span>\(K_P\)
</span>and <span>\(K_O\)
</span>are straightforward. A higher <span>\(K_P\)
</span>facilitates the robot in reaching the desired position more swiftly, while an increased <span>\(K_O\)
</span>enables to reach the desired orientation faster. Lower values result in sluggish robot movement, whereas higher values may induce excessive speed, with the potential of burdening computations.</p><p>The robot imposes constraints on joint velocities <span>\(\dot{q}\)
</span>. For <span>\(\dot{q}_1\)
</span>, the prismatic joint, the maximum attainable speed is 2.5 m/s. Revolute joints, on the other hand, have a maximum speed of around 360¬∫/s, equivalent to 6.28 rad/s.</p><p>Another constraint pertains to the range of motion for each joint, encompassing the maximum and minimum angles for revolute joints and the maximum and minimum distances for the prismatic joint. These values were extracted from the robot manual and incorporated into our model during the symbolic expression calculations for <span>\(\dot{q}_0\)
</span>.</p><p><img src=https://live.staticflickr.com/65535/53469950615_3fffa19de1_b.jpg alt=35></p><p><img src=https://live.staticflickr.com/65535/53469533791_de4c0eaf20.jpg alt=36></p><h2 id=7-link-properties>7 Link Properties
<a class=anchor href=#7-link-properties>#</a></h2><p>To incorporate the dynamics of the robot, it&rsquo;s essential to determine approximate values for the mechanical properties of the links. Solidworks, with its available CAD models, was employed for this purpose. Assigning a material in Solidworks is a crucial step, and since the CAD models represented solid bodies instead of hollow structures, it was necessary to adjust the density.</p><p>Given that the robot&rsquo;s manual specified a weight of 50 kilograms for the KR6 robot without the carriage and KL beam, a uniform density of 1680 kg/m¬≥ was applied in Solidworks. This density adjustment resulted in the KR6 parts weighing approximately 50.4 kilograms, providing a satisfactory approximation. It&rsquo;s noteworthy that link 1 comprises two parts: the base of KR6 and a carriage supporting KR6. In the manual, the carriage weight is not included in the KR6&rsquo;s weight specification.</p><table><thead><tr><th>Link</th><th>Mass [ kg]</th><th>x</th><th>y</th><th>z</th><th>Ixx</th><th>Iyy</th><th>Izz</th><th>Ixy</th><th>Ixz</th><th>Iyz</th></tr></thead><tbody><tr><td>1</td><td>54.153</td><td>0.0004</td><td>-0.0005</td><td>0.4416</td><td>1.2211</td><td>1.3092</td><td>1.0273</td><td>-0.0033</td><td>-0.1784</td><td>0.0012</td></tr><tr><td>2</td><td>10.526</td><td>-0.0170</td><td>0.0674</td><td>0.0020</td><td>0.1277</td><td>0.0943</td><td>0.0840</td><td>0.0089</td><td>0</td><td>0.0009</td></tr><tr><td>3</td><td>12.299</td><td>-0.1840</td><td>-0.0053</td><td>-0.0058</td><td>0.0639</td><td>0.2515</td><td>0.2255</td><td>0.0015</td><td>0.0028</td><td>0</td></tr><tr><td>4</td><td>4.810</td><td>-0.0246</td><td>0</td><td>-0.0161</td><td>0.0164</td><td>0.0186</td><td>0.0136</td><td>0</td><td>0.0023</td><td>0</td></tr><tr><td>5</td><td>4.582</td><td>0.0001</td><td>-0.1341</td><td>0.0036</td><td>0.0287</td><td>0.0096</td><td>0.0259</td><td>0</td><td>0</td><td>-0.0003</td></tr><tr><td>6</td><td>0.747</td><td>0</td><td>0.0019</td><td>-0.0168</td><td>0.0010</td><td>0.0009</td><td>0.0005</td><td>0</td><td>0</td><td>0</td></tr><tr><td>7</td><td>0.023</td><td>0</td><td>0</td><td>-0.0075</td><td>3E-6</td><td>3E-6</td><td>5E-6</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>The inclusion of motors within the robot&rsquo;s links was modeled by representing them as cylinders with a diameter of 1 cm and a height of 10 cm, constructed from steel. The resulting inertia of the motors around their z-axis (Im) was determined to be 0.00021 kg m¬≤. Additionally, gear reduction ratios (<code>kr</code>) were set at a value of 100.</p><h2 id=8-newton-euler-formulation>8 Newton-Euler Formulation
<a class=anchor href=#8-newton-euler-formulation>#</a></h2><p>The Newton-Euler formulation relies on the equilibrium of forces acting on the manipulator&rsquo;s links. This formulation enables a recursive solution, divided into two sets of recursion:</p><ul><li><ol><li><strong>Forward Recursion</strong>: This phase propagates and computes link velocities and accelerations, commencing from link 1 and concluding at the end-effector.</li></ol></li><li><ol start=2><li><strong>Backward Recursion</strong>: In this phase, forces for prismatic joints and moments for revolute joints are propagated and calculated. The recursion begins at the end-effector and concludes at link 1.</li></ol></li></ul><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p>A key advantage of the Newton-Euler formulation lies in its simplicity of implementation, facilitating an efficient computation of the dynamics solution.</blockquote><p>The underlying concept of the Newton-Euler formulation is as follows: the forward recursion helps calculate velocities and accelerations, enabling the determination of end-effector forces and moments. Subsequently, by proceeding backward, each force and moment for the link preceding the end-effector is computed. This approach allows for the determination of all forces and moments acting on the links. With this information, the behaviour of torque joints for any trajectory can be calculated. Utilizing the torque joints, and assuming no external forces at the end-effector, the joint space dynamic model can be established.</p><span>\[B(q)\ddot{q} + C(q, \dot{q})\dot{q} + g(q) = \tau\]</span><p>In order to calculate the torques, the manipulator equation can be decomposed into three main components: the mass matrix <code>B</code>, the Coriolis/Centrifugal matrix <code>C</code> and a given gravity vector <code>g</code>. The term <span>\( C(q, \dot{q})\dot{q} \)
</span>can be expressed as a vector <span>\( \phi (q, \dot{q}) \)
</span>.</p><p>Implementing these calculations in real-time requires a dynamics block in Simulink. <a href=https://github.com/roaked/robotics-kinematics-dynamics-and-control/tree/main/DynamicsV1>A general Newton-Euler equation was developed in MATLAB</a>, capable of <a href=https://github.com/roaked/robotics-kinematics-dynamics-and-control/blob/main/DynamicsV1/Newton_Euler.m>solving the Newton-Euler formulation</a> for any robot with both revolute and prismatic joints. This equation takes the Denavit-Hartenberg (DH) table, along with the necessary properties of links and motors, and outputs the torques.</p><p>Using the function, it is possible to obtain <code>B</code>, <span>\(\phi\)
</span>, and <code>g</code>. The gravity vector is the simplest to obtain: <span>\(g = \tau (q, \dot{q}, q\ddot{q}) = \tau (q, 0, 0)\)
</span>. Imposing the joints velocities and accelerations to zero, <code>B</code> and <code>C</code> are erased from the equation.</p><p>To obtain the mass matrix, since it doesn‚Äôt depend on the velocity, <span>\(\dot{q}\)
</span>can be set to zero. The acceleration of gravity is also turned to zero, leaving the equation as <span>\(B(q\dot{q})\ddot{q} = \tau \)
</span>. Deriving the expressions by the vector <span>\(\ddot{q}\)
</span>, <code>B</code> is finally obtained.</p><p><span>\(\phi = C(q, \dot{q})\dot{q}\)
</span>is obtained by setting <span>\(\ddot{q}\)
</span>and the gravity acceleration to zero.</p><p>Regarding <code>B</code> and <span>\(\phi\)
</span>, another separation can be made. Both parameters can be divided by the contributions of the augmented links, <span>\(B_l\)
</span>and <span>\(\phi_l\)
</span>, and contributions of the motors, <span>\(B_m\)
</span>and <span>\(\phi_m\)
</span>. To obtain the contributions of the links, the mechanical properties of the motors <span>\(k_r\)
</span>and <span>\(I_m\)
</span>can be set to zero, while to obtain the motors&rsquo; contributions the masses of the links <code>m</code> and their inertia tensors <code>I</code> can be set to zero. This separation can be useful to visualize the influence of the motors on these parameters.</p><h3 id=81-validation>8.1. Validation
<a class=anchor href=#81-validation>#</a></h3><p><img src=https://live.staticflickr.com/65535/53468756072_f11d1ac5a6_b.jpg alt=50></p><p>The dynamics block takes the position and velocity vectors, q and <span>\(\dot{q}\)
</span>, as inputs and produces <code>B</code> and <span>\(\phi\)
</span>(with separated terms for contributions from links and motors) along with <code>g</code> as outputs. Accelerations are computed and then integrated to derive velocities, which are subsequently integrated to obtain positions.</p><span>\[\ddot{q} = B^{-1}(\tau - \phi - g)\]</span><p>By setting the torques to zero, the robot undergoes motion solely due to the influence of gravity. The nature of this movement is contingent upon the initial conditions of the robot. For instance, with initial conditions <span>\(q_0 = [ 0,0,0, ‚àí\frac{\pi}{2}, 0,0,0 ]\)
</span>, the robot exhibits pendulum-like behavior, with the arm fully extended. Absent viscous forces, mechanical energy is conserved, leading to sustained oscillations. Alternatively, setting the initial conditions to <span>\(q_0 = [ 0,\frac{\pi}{2},0,0 0,0,0 ]\)
</span>results in the arm behaving akin to a double pendulum as subsequently shown.</p><p><img src=https://live.staticflickr.com/65535/53469800668_6e985fb8b5.jpg alt=51></p><h2 id=9-decentralized-pid-joint-controllers>9 Decentralized PID Joint Controllers
<a class=anchor href=#9-decentralized-pid-joint-controllers>#</a></h2><p>The central concept behind the decentralized controller involves breaking down the manipulator into <code>n</code> independent systems, where <code>n</code> represents the number of joints. Each joint is then controlled independently. The proposed solution entails the creation of a closed-loop PID (Proportional-Integral-Derivative) controller for each joint. In this setup, the input is the desired joint value <code>qd</code> and the output is the <code>q</code> values, which the KR6 Robot uses for computation. This approach relies on the equation:</p><span>\[\tau = -K_d \dot{q} + K_p(q - q_d) - K_i \int (q - q_d) \, dt\]</span><p>The integral action in the PID controller serves to eliminate the persistent error induced by the simulated gravity. Consequently, instead of using the integral gain, replace it by directly incorporating the manipulator&rsquo;s gravity compensation outputs for each joint. This adjustment helps counteract the influence of simulated gravity and contributes to improved control performance.</p><span>\[\tau = -K_d \dot{q} + K_p(q - q_d) + g(q)\]</span><p>Opting for a PD (Proportional-Derivative) controller without an integral gain is beneficial as it avoids introducing a pole at the origin, which could otherwise slow down the system response. The chosen approach involves creating a PD controller and incorporating gravity compensation. In this setup, the dynamics manipulator receives an initial condition and produces the joint velocities <span>\( `\dot{q}` \)
</span>, joint values <code>q</code> and gravity compensation. These outputs feed into the controller, which computes a new torque <span>\( `\tau` \)
</span>. This torque is then fed back into the dynamics manipulator, resulting in updated joint values <code>q</code> that are subsequently utilized in the actual robot. This iterative process helps refine the control of the system.</p><p><img src=https://live.staticflickr.com/65535/53468756057_84d50fd68c_z.jpg alt=52></p><h3 id=91-stiffness-and-damping-gains>9.1. Stiffness and Damping Gains
<a class=anchor href=#91-stiffness-and-damping-gains>#</a></h3><p>To determine the values for the Stiffness <code>Kp</code> and Damping <code>Kd</code> gains:</p><span>\[B(q)\ddot{q} + C(q, \dot{q})\dot{q} + g(q) = -K_d\dot{q} + K_p(q - q_d) + g(q)\]</span><p>By removing the gravity compensation from both sides and making the assumption that in the decentralized controller, the joints are decoupled and the model is completely linearized ‚Äî thus <span>\( \dot{q}^2 \approx 0 \)
</span>and the Coriolis effect <span>\( C(q, \dot{q})\dot{q} \)
</span>infered to be null.</p><span>\[B(q)\ddot{q} = -K_d\dot{q} + K_p(q - q_d)\]</span><p>Obtaining the transfer function of second order using Laplace transform:</p><span>\[\frac{q(s)}{q_d(s)} = \frac{\frac{K_p}{B}}{s^2 + \frac{K_d}{B}s + \frac{K_p}{B}}\]</span><p>Comparing the second-order system without dampening and natural frequency with a second-order system with dampening and natural frequency, it is safe to conclude:</p><span>\[\frac{\omega_n^2}{s^2 + 2 \xi \omega_n s + \omega_n^2} = \frac{\frac{K_p}{B}}{s^2 + \frac{K_d}{B}s + \frac{K_p}{B}}\]
</span><span>\[K_p = \omega_n^2 B\]
</span><span>\[K_d = 2 \xi \omega_n^2 B\]</span><p>Hence, <code>B</code> will be represented by the maximum values of the mass matrix <code>B</code> diagonal. Given that each joint will be controlled separately, each joint will have its respective <code>Kd</code>, <code>Kp</code> and <code>B</code>.</p><h3 id=92-worst-case-inertia>9.2. Worst Case Inertia
<a class=anchor href=#92-worst-case-inertia>#</a></h3><p>To identify the worst-case inertia, represented by the maximum values along the diagonal of the <code>B</code> matrix, a trial-and-error method was employed by searching for joint values <code>q</code>. The obtained values and the corresponding robot configurations for each inertia are shown in the subsequent table. Notably, for joints <code>q1</code>, <code>q2</code> and <code>q3</code> the changes in inertia values were negligible, suggesting that any configuration of <code>q</code> would yield the maximum inertia value for these joints.</p><table><thead><tr><th>Joint</th><th>Maximum Inertia [Kg ‚ãÖ m^2]</th><th>q1</th><th>q2</th><th>q3</th><th>q4</th><th>q5</th><th>q6</th><th>q7</th></tr></thead><tbody><tr><td>q1</td><td>89.24</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>q2</td><td>5.319</td><td>-</td><td>-</td><td>0</td><td>10</td><td>-145</td><td>0</td><td>-</td></tr><tr><td>q3</td><td>4.876</td><td>-</td><td>-</td><td>-</td><td>10</td><td>-90</td><td>0</td><td>-</td></tr><tr><td>q4</td><td>2.516</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-90</td><td>0</td><td>-</td></tr><tr><td>q5</td><td>2.111</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td><td>- [ -140,-45] and [ 45,140]</td><td>-</td></tr><tr><td>q6</td><td>2.101</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>q7</td><td>2.1</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h3 id=93-controller-gains-tuning>9.3. Controller Gains Tuning
<a class=anchor href=#93-controller-gains-tuning>#</a></h3><p>Considering the trial-and-error approach, it was decided to incorporate a simple oval trajectory for the end-effector. The objective is to assess the robot&rsquo;s response to this trajectory and analyze the errors across all joints. The oval trajectory involves the end-effector completing two revolutions. These experiments are conducted over a 20-second duration, enabling the exploration of various natural frequencies and damping ratios.</p><p><img src=https://live.staticflickr.com/65535/53469978149_31d94f96f1_w.jpg alt=56></p><p>To initiate the process, it was determined to employ identical <span>\(\omega_n\)
</span>(natural frequency) and <span>\(\xi\)
</span>(damping ratio) values for all joints.</p><table><thead><tr><th></th><th>q1</th><th>q2</th><th>q3</th><th>q4</th><th>q5</th><th>q6</th><th>q7</th></tr></thead><tbody><tr><td>wn [ rad/s]</td><td>10</td><td>10</td><td>10</td><td>10</td><td>10</td><td>10</td><td>10</td></tr><tr><td>Œæ</td><td>0.707</td><td>0.707</td><td>0.707</td><td>0.707</td><td>0.707</td><td>0.707</td><td>0.707</td></tr><tr><td>Kp</td><td>8924</td><td>531.9</td><td>487.6</td><td>251.6</td><td>211.1</td><td>210.1</td><td>254.1</td></tr><tr><td>Kd</td><td>1262</td><td>75.2</td><td>69.0</td><td>35.6</td><td>29.9</td><td>29.7</td><td>32.7</td></tr><tr><td>Maximum Tracking Error</td><td>0.0614</td><td>0.0953</td><td>0.1240</td><td>0.1605</td><td>0.1805</td><td>0.1722</td><td>0.1814</td></tr></tbody></table><p><img src=https://live.staticflickr.com/65535/53469658291_68abcfbcfd_z.jpg alt=57></p><p>Observing the error values, it is evident that they are quite high, with the largest error observed in <code>q7</code> at 18 cm. This level of error, even if the robot eventually converges to the final position, is deemed substantial. To address this, the natural frequency of the joints will be increased. This adjustment aims to expedite the robot&rsquo;s response and convergence to the desired values for each joint during the trajectory. Additionally, considering the larger error, a more significant increase in the natural frequency, especially for the last joints, has been decided upon.</p><table><thead><tr><th></th><th>q1</th><th>q2</th><th>q3</th><th>q4</th><th>q5</th><th>q6</th><th>q7</th></tr></thead><tbody><tr><td>wn [ rad/s]</td><td>20</td><td>20</td><td>20</td><td>20</td><td>40</td><td>40</td><td>40</td></tr><tr><td>Œæ</td><td>0.707</td><td>0.707</td><td>0.707</td><td>0.707</td><td>0.707</td><td>0.707</td><td>0.707</td></tr><tr><td>Kp</td><td>35696</td><td>2128</td><td>1950</td><td>1006</td><td>3378</td><td>3362</td><td>3360</td></tr><tr><td>Kd</td><td>2524.1</td><td>150.4</td><td>137.9</td><td>71.2</td><td>119.4</td><td>118.9</td><td>118.8</td></tr><tr><td>Maximum Tracking Error</td><td>0.0316</td><td>0.0520</td><td>0.0678</td><td>0.0820</td><td>0.0499</td><td>0.0468</td><td>0.0498</td></tr></tbody></table><p><img src=https://live.staticflickr.com/65535/53468756027_2abc8daa83_c.jpg alt=58></p><p>As observed, the errors have become significantly smaller, indicating that the increase in natural frequency has accelerated the system&rsquo;s response. It&rsquo;s essential to note that this increase has its limits, as excessively high natural frequencies can render the system unstable. Additionally, with the inertias being relatively small, the stiffness and damping gains become increasingly larger in response.</p><table><thead><tr><th></th><th>q1</th><th>q2</th><th>q3</th><th>q4</th><th>q5</th><th>q6</th><th>q7</th></tr></thead><tbody><tr><td>wn [ rad/s]</td><td>25</td><td>30</td><td>40</td><td>40</td><td>60</td><td>60</td><td>60</td></tr><tr><td>Œæ</td><td>0.707</td><td>0.707</td><td>0.707</td><td>0.707</td><td>0.707</td><td>0.707</td><td>0.707</td></tr><tr><td>Kp</td><td>55775</td><td>4787</td><td>7802</td><td>4026</td><td>7600</td><td>7564</td><td>7560</td></tr><tr><td>Kd</td><td>3155.1</td><td>225.7</td><td>275.8</td><td>142.3</td><td>179.1</td><td>178.3</td><td>178.2</td></tr><tr><td>Maximum Tracking Error</td><td>0.0257</td><td>0.0363</td><td>0.0416</td><td>0.0435</td><td>0.0353</td><td>0.0331</td><td>0.0353</td></tr></tbody></table><p><img src=https://live.staticflickr.com/65535/53469800638_8fc7d282db_c.jpg alt=59></p><p>Now, testing for different damping rations:</p><table><thead><tr><th>Œæ \ Error</th><th>q1</th><th>q2</th><th>q3</th><th>q4</th><th>q5</th><th>q6</th><th>q7</th></tr></thead><tbody><tr><td>0.4</td><td>0.0147</td><td>0.0186</td><td>0.0324</td><td>0.0257</td><td>0.0165</td><td>0.0155</td><td>0.0259</td></tr><tr><td>0.707</td><td>0.0257</td><td>0.0363</td><td>0.0416</td><td>0.0435</td><td>0.0353</td><td>0.0331</td><td>0.0353</td></tr><tr><td>0.9</td><td>0.0320</td><td>0.0449</td><td>0.0462</td><td>0.0537</td><td>0.0432</td><td>0.0405</td><td>0.0432</td></tr></tbody></table><p>As evident, a damping ratio of 0.4 results in lower error values, but it introduces more noticeable oscillating behaviour. Further reduction of this value can lead to system instability. Additionally, for values above 0.707, the error tends to increase, and surpassing 1, it causes the system to go unstable. Therefore, a damping ratio of 0.707 will be utilized for the trajectory planning, striking a balance between minimizing error and avoiding excessive oscillations or instability. The finalized parameters for the Stiffness and Damping Gains.</p><p><img src=https://live.staticflickr.com/65535/53469658271_2014107e63_c.jpg alt=60>
<img src=https://live.staticflickr.com/65535/53468756007_c776831f02_c.jpg alt=61></p><p>The final objective is to demonstrate the tracking performance of each joint <code>q</code> during the oval trajectory. This will serve to affirm that the decentralized control effectively ensures accurate following of the desired <code>q</code> values for each joint.</p><p><img src=https://live.staticflickr.com/65535/53469658281_ed341505cc_z.jpg alt=62></p><p><img src=https://live.staticflickr.com/65535/53469658246_e472495fe9_c.jpg alt=63></p><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p>It&rsquo;s crucial to highlight that the selection of natural frequency and damping ratios depends on the trajectory. Lower values for these parameters may generally function, but they might not be sufficient to minimize the tracking error effectively. Adjusting these values based on the characteristics of the specific trajectory is essential for achieving optimal control performance.</blockquote><h2 id=10-centralized-controller>10 Centralized Controller
<a class=anchor href=#10-centralized-controller>#</a></h2><p>To better manage high velocities with non-linear compensation, a centralized controller has been developed. The centralized controller facilitates joint space inverse dynamics control, enhancing the system&rsquo;s ability to handle complex dynamics and achieve precise control over high-velocity movements.</p><p><img src=https://live.staticflickr.com/65535/53470076220_b43ef67e60_c.jpg alt=64></p><p>The controller dynamics are:</p><span>\[\tau = B(q)\ddot{q} + n(q, \dot{q}) \\
n(q, \dot{q}) = \phi(q, \dot{q}) + g(q)\]</span><p>The block diagram illustrates that the system can be divided into two main components: <em>stabilizing control</em> and <em>non-linear compensation and decoupling</em>. Within the non-linear part, it is established that:</p><span>\[y = K_P \tilde{q} + K_D \dot{\tilde{q}} + \ddot{q}_d\]</span><p>Considering that <span>\( \ddot{\tilde{q}} = \ddot{q} - \ddot{q}_d \)
</span>, replacing y with <span>\(\ddot{q}_d\)
</span>:</p><span>\[\ddot{\tilde{q}} = K_D \dot{\tilde{q}} + K_P \tilde{q} = 0\]</span><p>This equation represents a second-order differential equation. The values for Kp (proportional gain) and Kd (derivative gain) are defined from the characteristic equation as follows:</p><span>\[K_P = \text{diag}\{\omega_{n1}^2, \ldots, \omega_{nn}^2\} \\
K_D = \text{diag}\{2\xi_1\omega_{n1}, \ldots, 2\xi_n\omega_{nn}\}\]</span><p><strong>Simulink design:</strong></p><p><img src=https://live.staticflickr.com/65535/53469658241_da2c684048_c.jpg alt=65></p><p>For the centralized controller, the parameters <code>B</code> and <code>n</code> are estimated. In order to thoroughly test the controller and simulate a real-life scenario where the manipulator dynamics may not precisely match the modeled dynamics (due to simplifications and neglecting factors such as viscous forces), a different dynamics block was introduced. This new dynamics block incorporates a 10% error in the masses of the links. While this adjustment might lead to a slightly less optimal controller performance, it enhances the realism of the simulation. Essentially, it is assumed that the positions and velocities of the manipulator joints can be measured, but directly extracting the <code>B</code> and <code>n</code> parameters requires an estimator due to potential uncertainties in the dynamics.</p><h3 id=101-controller-gains-tuning>10.1. Controller Gains Tuning
<a class=anchor href=#101-controller-gains-tuning>#</a></h3><p>For the centralized controller, the natural frequencies and damping coefficient ratios were initially uniform across all joints. The initial test involved a step response with <span>\(\omega_n = 10, \xi = \frac{\sqrt{2}}{2} \approx\)
</span>0.707. However, it was observed that the system was underdamped, with some oscillations appearing in the response. To address this, <span>\(\xi\)
</span>was adjusted to 1.</p><p><img src=https://live.staticflickr.com/65535/53470076215_fc43a60a45_c.jpg alt=66></p><p>Further increasing <span>\(\xi\)
</span>would result in an overdamped system, thereby slowing down the response. Thus, <span>\(\xi\)
</span>was maintained. It is observed that, for both responses, the steady-state error is zero.</p><p>Regarding <span>\(\omega_n\)
</span>, since the centralized controller receives desired velocities and accelerations, it doesn&rsquo;t necessitate as high a <span>\(\omega_n\)
</span>as in decentralized control. Elevating <span>\(\omega_n\)
</span>would accelerate the response, potentially leading to motor saturation, while reducing it could slow down the response, increasing the tracking error. To enhance the response speed without causing saturation, <span>\(\omega_n\)
</span>was increased to 15.</p><p><img src=https://live.staticflickr.com/65535/53469800598_2905dedb8c_c.jpg alt=67></p><p>This image illustrates that the response is rapid, with no overshoot and no steady-state error for all joints. With these parameters, the gains of the controller are <span>\(K_p\)
</span>= <span>\(\omega_n^2 = 225\)
</span>and <span>\(2 \xi \omega_n = 30\)
</span>. Another conducted test involved a ramp response, where imposing a ramp with a slope of 1 yielded the following tracking errors:</p><p><img src=https://live.staticflickr.com/65535/53469978089_4640e1ca09_z.jpg alt=68></p><p>From the figure above, it is evident that the system rapidly converges to a tracking error of zero. This rapid convergence is attributed to the fact that desired velocities of the joints are provided. To further validate the centralized controller, it was tested with a simple oval trajectory, yielding the following results:</p><p><img src=https://live.staticflickr.com/65535/53469800593_1892f9b62a_c.jpg alt=69>
<img src=https://live.staticflickr.com/65535/53469658226_1e46402deb.jpg alt=70></p><h2 id=11-trajectory-planning>11 Trajectory Planning
<a class=anchor href=#11-trajectory-planning>#</a></h2><p>For trajectory planning, the decision was made to have the KR6 end-effector trace the <a href=https://tecnico.ulisboa.pt/>&ldquo;IST&rdquo;</a> university logo. Achieving this required the development of a method for the robot to follow the designated trajectory. To implement the trajectory, a time-law was formulated, allowing for the specification of the time duration of a trajectory and establishing boundary conditions for the movement.</p><p>The chosen time-law is based on a cubic polynomial. The selected constraints include initial and final times to coincide with the initial and final position of the trajectory, and initial and final accelerations set to zero. These conditions contribute to a seamless and smooth movement of the robot. The resulting time-law is:</p><span>\[s = s_0 + 3(sf - s_0)(\frac{t}{t_f})^2 - 2(sf - s_0)(\frac{t}{t_f})^3\]
</span><span>\[\frac{ds}{dt} = \frac{6}{t_f^2}(s_f - s_0)t - \frac{6}{t_f^3}(s_f - s_0)t^2\]</span><p>The trajectory was implemented using the parameterization of the length as a function of time, denoted as s = s(t). The trajectory was carefully designed to enable the robot to write the letters without abrupt changes in velocities, aiming to avoid generating very large accelerations. Specifically, the goal was to eliminate discontinuities in velocities. For instance, when forming the letter &lsquo;T&rsquo;, at some point, the end-effector would need to reverse its direction. Instead of an abrupt reversal from positive to negative velocity, the robot first slows down until it reaches zero velocity and then begins moving backward. Similarly, sharp 90¬∫ turns were avoided.</p><p>The trajectory was integrated into the Closed Loop Inverse Kinematics from the initial part of the project. The Simulink subsystem for the trajectory is depicted below:</p><p><img src=https://live.staticflickr.com/65535/53468755942_111edcf19b_c.jpg alt=71></p><p>After executing CLIK, the obtained results for the position of the end-effector were visualized by plotting the data in Matlab.</p><p><img src=https://live.staticflickr.com/65535/53469978084_8b2e5dd09b_w.jpg alt=72></p><p>Since CLIK had already been validated in the previous report, the successful implementation of the trajectory demonstrates that the system is performing as intended. The trajectory was designed to last for 20 seconds, featuring letters with dimensions of 0.4 x 0.4 meters. The corners in the letters &lsquo;I&rsquo; and &lsquo;T&rsquo; were intentionally rounded to achieve a smoother movement.</p><p>When executing CLIK to obtain the desired positions, velocities, and accelerations, it is crucial to adjust the solver settings. By default, the solver has a variable step. Switching to a fixed step, with a step size of 0.01 seconds, allows for a more precise sampling of data from CLIK.</p><h3 id=111-trajectory-with-decentralized-controller>11.1. Trajectory with Decentralized Controller
<a class=anchor href=#111-trajectory-with-decentralized-controller>#</a></h3><p>After attempting to use the previously determined gain values for the new trajectory, an unstable behavior was observed in the error values for joint <code>q1</code>. Consequently, the natural frequency for q1(<span>
\(\omega_{n1}\)
</span>) was reduced by 5 rad/s to <span>\(\omega_{n1} = 20\)
</span>. This adjustment yielded the following error values for the &ldquo;IST&rdquo; trajectory.</p><table><thead><tr><th></th><th>q1</th><th>q2</th><th>q3</th><th>q4</th><th>q5</th><th>q6</th><th>q7</th></tr></thead><tbody><tr><td>Maximum Error</td><td>0.0556</td><td>0.0408</td><td>0.0339</td><td>0.0183</td><td>0.0574</td><td>0.0214</td><td>0.1417</td></tr></tbody></table><p><img src=https://live.staticflickr.com/65535/53469658201_1b666e68dc_z.jpg alt=73></p><p>The elevated error value for joint <code>q7</code> can be attributed primarily to the controller relying solely on joint position. Since the end-effector exhibits varying velocities along the path, especially during curves where velocities are higher, it leads to the controller &ldquo;losing track&rdquo; of the position, resulting in larger errors. However, the animation remains satisfactory as the robot remains stable throughout, and the error converges to the final value. Another evaluation approach is to examine the different end-effector positions throughout the trajectory.</p><p><img src=https://live.staticflickr.com/65535/53469800553_e16e234471_w.jpg alt=74></p><p>From this plot, as mentioned earlier, it is evident that the robot encounters difficulty in accurately following the curves of the trajectory, particularly in the contours of the &ldquo;I&rdquo; and &ldquo;T&rdquo; where velocities are higher. The most significant tracking error occurs during the &ldquo;S&rdquo; trajectory, characterized by two consecutive curves. The following figures will illustrate the desired positions, current positions of the robot, and the error between them.</p><p><img src=https://live.staticflickr.com/65535/53470076170_ffa5b4255b_c.jpg alt=75></p><p><img src=https://live.staticflickr.com/65535/53469978069_ac9cc8824c_c.jpg alt=76></p><p>From the last two images, it may appear that the values on the y-axis in the first figure exhibit the most disparity, but this is solely due to the scale of the Scope. The highest difference error in this axis is approximately 0.00037 meters.</p><p>Given that the trajectory primarily occurs in the &ldquo;x&rdquo; and &ldquo;z&rdquo; axes, these are the dimensions that display the highest peaks in error. From the right subplot of the last image, five prominent spikes are observed in the x-axis, corresponding to the five main curves of the trajectory (two for &ldquo;I,&rdquo; two for &ldquo;S,&rdquo; and one for &ldquo;T&rdquo;). The maximum error values obtained for x, y, and z are <span>\(e_x = 0.0429, e_y = 0.0011 \text{and} e_z = 0.0119 \)</span></p><p><img src=https://live.staticflickr.com/65535/53469800528_e09e68643b_z.jpg alt=77></p><p>The plots illustrate that the joint values <code>q</code> exhibit capacity of following the trajectory throughout its course, showcasing the effectiveness of the decentralized controller as a capable tool for controlling robot trajectories.</p><h3 id=112-trajectory-with-centralized-controller>11.2. Trajectory with Centralized Controller
<a class=anchor href=#112-trajectory-with-centralized-controller>#</a></h3><p>When using <span>\(\xi = 1 \text{and} \omega_n = 15\)
</span>, the following results were obtained after executing the &ldquo;IST&rdquo; trajectory:</p><table><thead><tr><th></th><th>q1</th><th>q2</th><th>q3</th><th>q4</th><th>q5</th><th>q6</th><th>q7</th></tr></thead><tbody><tr><td>Maximum Error</td><td>0.0024</td><td>0.0110</td><td>0.0061</td><td>0.0027</td><td>0.0379</td><td>0.0019</td><td>0.0966</td></tr></tbody></table><p><img src=https://live.staticflickr.com/65535/53469978034_0994d50615.jpg alt=78></p><p>Similar to the Decentralized controller, the most significant error occurs with joint <code>q7</code>. The results are not significantly different from the decentralized control, with small errors. The end-effector position plot yielded the following result:</p><p><img src=https://live.staticflickr.com/65535/53469978039_a2c83d9bea_w.jpg alt=79></p><p>The most substantial errors emerge in the tight turns of the &ldquo;I&rdquo; and &ldquo;T,&rdquo; as well as the large curves during the &ldquo;S.&rdquo; However, these errors are not overly significant, as the plots closely resemble each other, and the letters can still be distinctly recognized. As for the errors in the end-effector position:</p><p><img src=https://live.staticflickr.com/65535/53469800513_817f2c893b_z.jpg alt=80></p><p>The maximum values of error obtained for x, y, and z are <span>\(e_x = 0.0045, e_y = 0.0017 \text{and} e_z = 0.0030 \)
</span>. As for evolution of the joints‚Äô positions:</p><p><img src=https://live.staticflickr.com/65535/53469978019_0556179347_c.jpg alt=81></p><p>The plots of <code>q</code> and <code>qd</code> are nearly overlaid, indicating good tracking. The most noticeable errors are observed in <code>q5</code> and <code>q7</code>, as expected from the table of maximum errors presented.</p><p>As a final experiment, we decided to increase the values of <span>\(\omega_n\)
</span>to observe their impact on the tracking errors. The chosen values were <span>\(\omega_n = [ 20,20,20,20,20,30,20,50]\)
</span>. <span>\(\omega_{n5}\)
</span>and <span>\(\omega_{n7}\)
</span>were selected to have higher values than the rest due to having the largest errors. The results were:</p><table><thead><tr><th></th><th>q1</th><th>q2</th><th>q3</th><th>q4</th><th>q5</th><th>q6</th><th>q7</th></tr></thead><tbody><tr><td>Maximum Error</td><td>0.0024</td><td>0.0081</td><td>0.0035</td><td>0.0018</td><td>0.0222</td><td>0.0020</td><td>0.0286</td></tr></tbody></table><p><img src=https://live.staticflickr.com/65535/53469978009_ec14068be9_c.jpg alt=82></p><p>The errors are smaller, and the &ldquo;spikes&rdquo; persist for a shorter duration than before (indicating a faster rise and fall). Upon closer inspection of a zoomed-in section, it appears that the system remains stable, with no significant oscillations:</p><p><img src=https://live.staticflickr.com/65535/53469658161_31bd7c8b44_c.jpg alt=83></p><p>These values produced slightly better results than those used before, but they are more tuned to this specific trajectory. The previous values also yielded good results and may be more appropriate for a broader range of trajectories, with less risk of causing instability in the system.</p><h2 id=12-final-remarks>12 Final Remarks
<a class=anchor href=#12-final-remarks>#</a></h2><p>At the first chapters, the direct kinematics and inverse kinematics were implemented. Although direct kinematics where the joint coordinates are given to determine the end effector&rsquo;s position and orientation, were successfully implemented and validated, the inverse kinematics posed a challenge and a geometric approach was employed, involving drawings to enhance understanding of joint relationships. It was found that <code>q1</code> needed to be initially prescribed as a solution.</p><p>The CLIK model overcame the redundancy in the robot, providing solutions without prescribing q1. However, it introduced complexities with four different gains, requiring tuning for optimal performance. While CLIK simplified the algebraic work compared to the non-closed-loop form, the gain tuning process was not trivial, and finding an optimal solution required adjusting multiple parameters.</p><p>Despite the complexities, CLIK offered a more straightforward approach to inverse kinematics, especially for robots with different architectures. The ability to handle redundancy was a significant advantage. After tuning the gains to optimal values, CLIK demonstrated reliable results.</p><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p>It&rsquo;s important to note that, while a geometric approach was chosen for the inverse kinematics, other analytical approaches utilizing transformation matrices for each joint are possible. The geometric approach, driven by its intuitiveness, was selected for this project.</blockquote><p>As for the dynamics and control: starting with the extraction of masses and inertias of the links, SolidWorks proved to be a successful tool. The choice of Newton-Euler formulation for dynamics computation was efficient due to its recursive nature and simple implementation, making it easier and more effective than Lagrange. The fall of the robot under gravity when no torques were applied aligned with expectations.</p><p>In terms of controllers, both the Decentralized and Centralized Controllers exhibited good performance in trajectory tracking. However, the Centralized Controller demonstrated superiority, utilizing not only joint positions <code>qd</code> but also joint velocities <code>qd/dt</code> and accelerations <code>q2d/dt2</code> for improved tracking. The Decentralized Controller, employing a P-D control with gravity compensation replacing the integrative part of PID, showed a slight deviation in the reference trajectory, especially during high-velocity movements.</p><p>The Centralized Controller, when appropriately tuned, showcased robust performance, even in the presence of disturbances in the estimation of dynamics. The trajectory planning using CLIK was successful, emphasizing its reliability for both kinematic analysis and task description.</p><p>The error analysis highlighted the Centralized Controller&rsquo;s superior results over the Decentralized Controller:</p><table><thead><tr><th></th><th>q1</th><th>q2</th><th>q3</th><th>q4</th><th>q5</th><th>q6</th><th>q7</th></tr></thead><tbody><tr><td>Decentralized Controller</td><td>0.0556</td><td>0.0408</td><td>0.0339</td><td>0.0183</td><td>0.0574</td><td>0.0214</td><td>0.1417</td></tr><tr><td>Centralized Controller</td><td>0.0024</td><td>0.0110</td><td>0.0061</td><td>0.0027</td><td>0.0379</td><td>0.0019</td><td>0.0966</td></tr></tbody></table><p>In summary, both controllers proved effective for the imposed trajectory, but for tasks involving high velocities, the Centralized Controller demonstrated greater reliability compared to the Decentralized Controller.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/roaked/roaked.github.io/commit/86267c56d91855bc6cb41c1f045272a84ecf68f1 title='Last modified by roaked | February 24, 2024' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>February 24, 2024</span></a></div><div><a class="flex align-center" href=https://github.com/roaked/roaked.github.io/edit/main/content/content/docs/code/robotics/_index.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Ricardo Chin</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#1-abstract>1 Abstract</a></li><li><a href=#2-kinematics>2 Kinematics</a></li><li><a href=#3-direct-kinematics>3 Direct Kinematics</a><ul><li><a href=#31-validation>3.1. Validation</a></li><li><a href=#32-joint-trajectories>3.2. Joint Trajectories</a></li></ul></li><li><a href=#4-inverse-kinematics>4 Inverse Kinematics</a><ul><li><a href=#41-validation>4.1. Validation</a></li></ul></li><li><a href=#5-geometric-jacobian>5 Geometric Jacobian</a><ul><li><a href=#51-position-validation>5.1. Position Validation</a></li><li><a href=#52-orientation-validation>5.2. Orientation Validation</a></li><li><a href=#53-kinematic-singularities>5.3. Kinematic Singularities</a></li></ul></li><li><a href=#6-closed-loop-inverse-kinematics-clik>6 Closed Loop Inverse Kinematics (CLIK)</a></li><li><a href=#7-link-properties>7 Link Properties</a></li><li><a href=#8-newton-euler-formulation>8 Newton-Euler Formulation</a><ul><li><a href=#81-validation>8.1. Validation</a></li></ul></li><li><a href=#9-decentralized-pid-joint-controllers>9 Decentralized PID Joint Controllers</a><ul><li><a href=#91-stiffness-and-damping-gains>9.1. Stiffness and Damping Gains</a></li><li><a href=#92-worst-case-inertia>9.2. Worst Case Inertia</a></li><li><a href=#93-controller-gains-tuning>9.3. Controller Gains Tuning</a></li></ul></li><li><a href=#10-centralized-controller>10 Centralized Controller</a><ul><li><a href=#101-controller-gains-tuning>10.1. Controller Gains Tuning</a></li></ul></li><li><a href=#11-trajectory-planning>11 Trajectory Planning</a><ul><li><a href=#111-trajectory-with-decentralized-controller>11.1. Trajectory with Decentralized Controller</a></li><li><a href=#112-trajectory-with-centralized-controller>11.2. Trajectory with Centralized Controller</a></li></ul></li><li><a href=#12-final-remarks>12 Final Remarks</a></li></ul></nav></div></aside></main></body></html>