<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="KUKA: From Kinematics to Motion Planning # To add report when I have time :)
important
I would at some point like to implement a safe reinforcement learning whilst heading for optimistic exploration within a large-scale manufacturing setting instead of defining a specific trajectory! I think it would turn out a very informative and interesting project!
1. Abstract # This research centers on the kinematic analysis of the KUKA KR6 R700 robot, which is installed on a linear KL100 axis."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="Robotics: Kin, Dynamics & Control"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://xsleaks.dev/docs/code/robotics/"><title>Robotics: Kin, Dynamics & Control | Ricardo Chin</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.b74e85bd7803de00c09a320dcf09ae0d7e37702a9918995f5fe9d1c71c55a223.css integrity="sha256-t06FvXgD3gDAmjINzwmuDX43cCqZGJlfX+nRxxxVoiM=" crossorigin=anonymous><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-10WQY47KS2"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-10WQY47KS2",{anonymize_ip:!1})}</script><link rel=alternate type=application/rss+xml href=https://xsleaks.dev/docs/code/robotics/index.xml title="Ricardo Chin"></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Ricardo Chin</span></a></h2><ul><li class=book-section-flat><a href=/docs/design/>Design Repository</a><ul><li><a href=/docs/design/fea-beam-simulation/>FEA Beam Instability Modes</a><ul></ul></li><li><a href=/docs/design/industrial-crane-design/>Industrial Girder Crane</a><ul></ul></li><li><a href=/docs/design/finite-element-method-development/>FEM Package Development</a><ul></ul></li><li><a href=/docs/design/manual-transmission-design/>Gear Train Transmission</a><ul></ul></li><li><a href=/docs/design/electron-beam-tech/>Electron Beam Technology</a><ul></ul></li></ul></li><li class=book-section-flat><a href=/docs/code/>Coding Repository</a><ul><li><a href=/docs/code/uav/>UAV Red Bull Air Racing</a><ul><li><a href=/docs/code/uav/dynamics/>Drone Dynamics</a></li><li><a href=/docs/code/uav/continuous-controller-design/>Drone Continuous Controller</a></li><li><a href=/docs/code/uav/discrete-controller-design/>Drone Discrete Controller</a></li><li><a href=/docs/code/uav/computer-vision/>Drone Computer Vision</a></li></ul></li><li><a href=/docs/code/agv/>AGV: System Identification</a><ul></ul></li><li><a href=/docs/code/deep-learning-fake-news/>Deep Learning on Fake News</a><ul></ul></li><li><a href=/docs/code/hamiltonian-graphs/hamiltonian/>Hamiltonian Paths: Linked Lists</a></li><li><a href=/docs/code/bin-packing/>EC Optimization: Space & Time</a><ul><li><a href=/docs/code/bin-packing/genetic-algorithm/>Genetic Algorithm</a></li><li><a href=/docs/code/bin-packing/particle-swarm-optimization/>Particle Swarm Optimization</a></li></ul></li><li><a href=/docs/code/robotics/ class=active>Robotics: Kin, Dynamics & Control</a><ul></ul></li><li><a href=/docs/code/snake-game/>Snake Game: Genetic RL-DQN</a><ul></ul></li><li><a href=/docs/code/micromouse/>Micromouse: Flood Fill to A*</a><ul></ul></li></ul></li><li class=book-section-flat><a href=/docs/competitions/>Academic Competitions</a><ul><li><a href=/docs/competitions/fst/>Formula Student Lisbon</a></li><li><a href=/docs/competitions/thermocup/>ThermoCup</a></li></ul></li><li class=book-section-flat><a href=/docs/leet/>My LeetCode Solutions</a><ul></ul></li><li class=book-section-flat><a href=/docs/mod/>Website Modifications</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Robotics: Kin, Dynamics & Control</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#1-abstract>1. Abstract</a></li><li><a href=#2-kinematics>2. Kinematics</a></li><li><a href=#3-direct-kinematics>3. Direct Kinematics</a><ul><li><a href=#31-validation>3.1. Validation</a></li><li><a href=#32-joint-trajectories>3.2. Joint Trajectories</a></li></ul></li><li><a href=#4-inverse-kinematics>4. Inverse Kinematics</a><ul><li><a href=#41-validation>4.1. Validation</a></li></ul></li><li><a href=#5-geometric-jacobian>5. Geometric Jacobian</a><ul><li><a href=#51-postion-validation>5.1. Postion Validation</a></li><li><a href=#52-orientation-validation>5.2. Orientation Validation</a></li><li><a href=#53-kinematic-singularities>5.3. Kinematic Singularities</a></li></ul></li><li><a href=#6-closed-loop-inverse-kinematics-clik>6. Closed Loop Inverse Kinematics (CLIK)</a><ul><li><a href=#61-validation>6.1. Validation</a></li></ul></li><li><a href=#7-link-properties>7. Link Properties</a></li><li><a href=#8-newton-euler-formulation>8. Newton-Euler Formulation</a><ul><li><a href=#81-validation>8.1. Validation</a></li></ul></li><li><a href=#9-decentralized-pid-joint-controllers>9. Decentralized PID Joint Controllers</a><ul><li><a href=#91-stifness-and-damping-gains>9.1. Stifness and Damping Gains</a></li><li><a href=#92-worst-case-inertia>9.2. Worst Case Inertia</a></li><li><a href=#93-controller-gains-tuning>9.3. Controller Gains Tuning</a></li></ul></li><li><a href=#10-centralized-controller>10. Centralized Controller</a></li><li><a href=#11-trajectory-planning>11. Trajectory Planning</a><ul><li><a href=#111-trajectory-with-decentralized-controller>11.1. Trajectory with Decentralized Controller</a></li><li><a href=#112-trajectory-with-centralized-controller>11.2. Trajectory with Centralized Controller</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=kuka-from-kinematics-to-motion-planning>KUKA: From Kinematics to Motion Planning
<a class=anchor href=#kuka-from-kinematics-to-motion-planning>#</a></h1><p><a href=https://github.com/roaked/robotics-kinematics-dynamics-and-control>To add report when I have time :)</a></p><p><img src=https://blogs.mathworks.com/images/seth/2009Q2/Robot.gif alt=soakd></p><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p><ul><li>I would at some point like to implement a safe reinforcement learning whilst heading for optimistic exploration within a large-scale manufacturing setting instead of defining a specific trajectory!</li></ul><p>I think it would turn out a very informative and interesting project!</p></blockquote><h2 id=1-abstract>1. Abstract
<a class=anchor href=#1-abstract>#</a></h2><p>This research centers on the kinematic analysis of the KUKA KR6 R700 robot, which is installed on a linear KL100 axis. The KUKA KR6 R700 is an industrial robot designed for tasks such as tool and fixture handling, as well as processing or transferring components or products.</p><p>The initial phase of studying the robot involves analyzing and constructing its kinematic model based on the Denavit-Hartenberg convention, with a focus on selecting the link reference frames.</p><p>Presented and validated through various Simulink models, it is intended to ease the extraction of the robot&rsquo;s direct kinematics, inverse kinematics, geometric Jacobian, and Closed Loop Inverse Kinematics (CLIK).</p><h2 id=2-kinematics>2. Kinematics
<a class=anchor href=#2-kinematics>#</a></h2><p>The robot consists on the presence of 6 revolute joints. Additionally, there is a single prismatic joint that facilitates horizontal movement of the robot. Consequently, the overall configuration of the robot comprises a total of 7 links.</p><p><img src=https://live.staticflickr.com/65535/53469950810_c67521134d.jpg alt=1></p><p><img src=https://live.staticflickr.com/65535/53469851949_b3914f719c.jpg alt=2></p><p>Utilizing the convention of <a href=https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters>Denavit-Hartenberg (DH)</a>, reference frames for each link can be drawn.</p><p><img src=https://live.staticflickr.com/65535/53469851939_221cf7f814.jpg alt=3></p><p>The dimensions <code>a2</code>, <code>a3</code>, <code>a4</code>, <code>d5</code> and <code>d7</code> are known. Hence, the table of DH can be built.</p><table><thead><tr><th>Link</th><th><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><span>\(d_i\)
</span>[\m]</th><th><span>\(\vartheta_i\)
</span>[\rad]</th><th><span>\(a_i\)
</span>[\m]</th><th><span>\(\alpha_i\)
</span>[\rad]</th><th>offset [\rad]</th></tr></thead><tbody><tr><td>1</td><td><span>\(d_1\)</span></td><td>0</td><td>0</td><td><span>\(-\frac{\pi}{2}\)</span></td><td>0</td></tr><tr><td>2</td><td>0</td><td><span>\(\vartheta_2\)</span></td><td>0.025</td><td><span>\(\frac{\pi}{2}\)</span></td><td>0</td></tr><tr><td>3</td><td>0</td><td><span>\(\vartheta_3\)</span></td><td>0.315</td><td>0</td><td>0</td></tr><tr><td>4</td><td>0</td><td><span>\(\vartheta_4\)</span></td><td>0.035</td><td><span>\(\frac{\pi}{2}\)</span></td><td>0</td></tr><tr><td>5</td><td>-0.365</td><td><span>\(\vartheta_5\)</span></td><td>0</td><td><span>\(-\frac{\pi}{2}\)</span></td><td>0</td></tr><tr><td>6</td><td>0</td><td><span>\(\vartheta_6\)</span></td><td>0</td><td><span>\(\frac{\pi}{2}\)</span></td><td>0</td></tr><tr><td>7</td><td>-0.080</td><td><span>\(\vartheta_7\)</span></td><td>0</td><td><span>\(\pi\)</span></td><td>0</td></tr></tbody></table><p>For this robot, the vector of joint variables <code>q</code> can be expressed as:</p><span>\[q = [d1 \hspace{.2cm} \vartheta_2 \hspace{.2cm} \vartheta_3 \hspace{.2cm} \vartheta_4 \hspace{.2cm} \vartheta_5 \hspace{.2cm} \vartheta_6 \hspace{.2cm} \vartheta_7 ]^T\]</span><h2 id=3-direct-kinematics>3. Direct Kinematics
<a class=anchor href=#3-direct-kinematics>#</a></h2><p>Through the direct kinematics analysis, one can compute the position and orientation of the end effector by considering the values of the joint variables within the vector <code>q</code>.</p><span>\[A_{i}^{i-1} = \begin{bmatrix}
R_{i}^{i-1} & r_{i-1, i}^{i-1} \\
0^T & 1
\end{bmatrix}\]</span><p><code>R</code> being the rotation matrix from link <code>i-1</code> to <code>i</code> and <code>r</code> the position vector from link <code>i-1</code> to <code>i</code>. Generalizing for a joint variable <span>\(\vartheta_i\)
</span>:</p><span>\[A_{i-1}^{i}(\theta_i) = \begin{bmatrix}
c_i & -s_i c_i & s_i c_i & a_i c_i \\
s_i & c_i c_i & -c_i s_i & a_i s_i \\
0 & s_i & c_i & d_i \\
0 & 0 & 0 & 1
\end{bmatrix}\]</span><p>The transformation matrix for 7 links:</p><span>\[T_7^0 = A_1^0 A_2^1 A_3^2 A_4^3 A_4^5 A_6^5 A_7^6\]</span><p>In MATLAB, the calculations described are executed using the functions <a href=https://github.com/roaked/robotics-kinematics-dynamics-and-control/blob/main/DKin.m>DKin.m</a> and <a href=https://github.com/roaked/robotics-kinematics-dynamics-and-control/blob/main/DHTransf.m>DHTransf.m</a>. These functions were initially provided as a toolbox, and <a href=https://github.com/roaked/robotics-kinematics-dynamics-and-control/blob/main/DKin.m>DKin.m</a> was modified to include the computation of the Jacobian matrix for future use. A MATLAB Function Block was then crafted from these functions, integrated into the Simulink model. This block takes the <code>q</code> vector as inputs and outputs the rotation matrix, position vector, and Jacobian matrix.</p><p>Another essential function, <a href=https://github.com/roaked/robotics-kinematics-dynamics-and-control/blob/main/vrrobot.m>vrrobot.m</a>, is employed to create a virtual representation of the robot within a simulated environment. By adding meshes to the links, the robot gains a tangible form beyond just reference frames.</p><p>The resulting Simulink model incorporates two input options for the <code>q</code> vector: sliders or trajectory. The <code>q</code> vector is fed into both the direct kinematics block and the animation block (VR sink), providing a comprehensive visualization of the robot&rsquo;s movements.</p><p><img src=https://live.staticflickr.com/65535/53469950785_90a2919709_c.jpg alt=4></p><h3 id=31-validation>3.1. Validation
<a class=anchor href=#31-validation>#</a></h3><h4 id=311-pose-one>3.1.1. Pose One
<a class=anchor href=#311-pose-one>#</a></h4><p>The initial validation involves inputting a set of known coordinates, denoted as <code>q</code>, and verifying if the resulting rotation matrix and position vector of the end effector align with the anticipated outcomes. During this validation process, certain adjustments to the offsets were necessary. Specifically, a -90º offset was applied to joint <code>q4</code>, and a +180º offset was applied to joint <code>q7</code>, with these values determined through the validation process. To define the <code>q</code> vector, sliders were employed.</p><p>A significant consideration is that the base reference frame used for validation differs from the zeroth frame defined in the kinematic model (frame 0). This distinction is illustrated when observing the robot in the virtual world. To enhance representation, the x-axis is depicted in red, the y-axis in green, and the z-axis in blue. Additionally, a distance d1 was set to separate the robot from frame 0, ensuring accurate validation.</p><p><img src=https://live.staticflickr.com/65535/53469533961_844a2cbdc2_z.jpg alt=5></p><p>Thus, a transformation from the base reference frame to frame 0 becomes necessary, encompassing both rotation and translation. The rotational aspect is characterized by:</p><span>\[R_{0}^b = \begin{bmatrix}
0 & 0 & -1 \\
1 & 0 & 0 \\
0 & -1 & 0
\end{bmatrix}\]</span><p>Therefore the rotation matrix from base to end effector is defined as:</p><span>\[R_7^b = R_0^b R_7^0\]</span><p>Simultaneously, the translation using the position vector:</p><span>\[r_{b,0}^b = [0 \hspace{.2cm} 0 \hscape{.2cm} 0.756 ]^T\]</span><p>The position vector from base to end effector is defined as:</p><span>\[r_{b,7}^b = r_{b,0}^b + r_{0,7}^b = r_{b,0}^b + R_{0}^b \hscape{.1cm} r_{0,7}^0\]</span><p>Analytical results are:</p><span>\[R_{7}^b = \begin{bmatrix}
0 & -1 & 0 \\
0 & 0 & 1 \\
-1 & 0 & 0
\end{bmatrix}\]
</span><span>\[r_{b,7}^b = [0 \hscape{.2cm} 0.470 \hscape{.2cm} 1.106]^T [\m] \]</span><p>Simulink results given by:</p><p><img src=https://live.staticflickr.com/65535/53469851914_780545e45b_z.jpg alt=6></p><p><img src=https://live.staticflickr.com/65535/53468628947_f0e300b867_c.jpg alt=7></p><h4 id=312-pose-two>3.1.2. Pose Two
<a class=anchor href=#312-pose-two>#</a></h4><p>Analytical results are:</p><span>\[R_{7}^b = \begin{bmatrix}
0.249 & -0.457 & 0.854 \\
-0.957 & -0.251 & 0.145 \\
0.148 & -0.853 & -0.500
\end{bmatrix}\]
</span><span>\[r_{b,7}^b = [0.20163 \hscape{.2cm} 0.44482 \hscape{.2cm} 0.97382]^T [\m] \]</span><p>Simulink results given by:</p><p><img src=https://live.staticflickr.com/65535/53469533951_c423d1b57f_z.jpg alt=8></p><p><img src=https://live.staticflickr.com/65535/53469533956_5b76d48ea0_c.jpg alt=9></p><h3 id=32-joint-trajectories>3.2. Joint Trajectories
<a class=anchor href=#32-joint-trajectories>#</a></h3><p>To conduct further testing of the direct kinematics, a series of joint trajectories was incorporated into the Simulink model, selectable by manipulating a manual switch. Initially, a set of ramps was chosen for the inputs, with the exception of joint <code>q1</code>, where a sine input was employed. This decision was made to avoid impractical robot movement away from the base, given the nature of a ramp input. Each ramp trajectory was individually examined to ensure that the robot&rsquo;s motion aligned with the anticipated behaviour.</p><p>For instance, a specific scenario involved fixing all joints except for <code>q2</code>, which theoretically should result in the robot spinning around itself. To validate this trajectory, an XY plot was generated from the base reference frame to visually confirm the expected movement.</p><p><img src=https://live.staticflickr.com/65535/53469851894_5d06d7bd7d_b.jpg alt=10></p><p>Another test involved applying sinusoidal inputs to all joints simultaneously. This particular test proved valuable as it enabled the movement of all joints concurrently without the risk of robot links intersecting or colliding with each other, a scenario not feasible in a physical robot.</p><p><img src=https://live.staticflickr.com/65535/53469533946_d84d6bd8d9.jpg alt=11></p><h2 id=4-inverse-kinematics>4. Inverse Kinematics
<a class=anchor href=#4-inverse-kinematics>#</a></h2><p>Inverse kinematics involves determining the values of the joint variables <code>q</code>, given the position and orientation of the end effector. It&rsquo;s important to note that solving such problems may yield multiple solutions.</p><p>In the case of the KR6, the end effector&rsquo;s position and orientation are described by 6 parameters: three displacements (<code>x</code>, <code>y</code>, <code>z</code>) and three Euler angles (<span>
\(\phi\)
</span>, <span>\(\theta\)
</span>, <span>\(\psi\)
</span>). However, the robot has 7 links, indicating it possesses 7 degrees of freedom. This redundancy implies that, to solve the inverse kinematics problem, one of the joint variables must be specified initially. In this scenario, <code>q1</code>, corresponding to the prismatic joint, was chosen to be fixed, leaving 6 degrees of freedom to be determined.</p><p>To address this, a kinematic decoupling approach was adopted. This involves separating the arm and wrist, solving the arm joints first and then addressing the wrist joints. This strategy simplifies the inverse kinematics problem and facilitates a systematic solution to determine the joint variables.</p><p><img src=https://live.staticflickr.com/65535/53469672968_55e4fe8b0c_c.jpg alt=12></p><p>The wrist&rsquo;s position serves as a reference point for calculating the initial four parameters of the robot. Beginning with the end effector&rsquo;s position, the wrist&rsquo;s position can be computed.</p><span>\[p_w = p_{07} - d_7 \times z_7^0 - [\begin{bmatrix} 0 \\ 0 \\ q_1 \end{bmatrix}]\]</span><p>It&rsquo;s crucial to note that all subsequent calculations utilize reference frame 0&rsquo;, which corresponds to reference frame 0 translated with <code>q1</code>. Additionally, in these equations, <code>d5</code> and <code>d7</code> are assumed to be positive values. Furthermore, the equations provided are applicable for a shoulder-up configuration.</p><p><img src=https://live.staticflickr.com/65535/53468628917_1d8779ccb6_z.jpg alt=13></p><p><img src=https://live.staticflickr.com/65535/53469851864_32e835bddb_z.jpg alt=14></p><p>After extensive trigonometric algebra, <span>\(\alpha\)
</span>and <span>\(\beta\)
</span>are computed:</p><span>\[\alpha = atan2 (- p_{wy}, \sqrt{p_{wx}^2 + p_{wz}^2} - a_2)\]
</span><span>\[\beta = atan2 (a_w \sqrt{1-c_w^2}, a_3 + a_w c_w)\]</span><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p>After computing <code>q1</code>, <code>q2</code>, <code>q3</code> and <code>q4</code> only the wrist parameters are left to find. Hence, using rotation matrix 4 -> 7, it is possible to compute <code>q5</code>, <code>q6</code> and <code>q7</code>.</blockquote><p><img src=https://live.staticflickr.com/65535/53469851869_a78896bf27_c.jpg alt=15></p><p>The system offers two input options for <code>pd</code> and <code>Rd</code>:</p><ul><li><p>Option 1: Users can specify the end effector position and orientation using parameters <code>x</code>, <code>y</code>, <code>z</code> (combined to form <code>pd</code>) and the Euler angles <span>\(\phi\)
</span>, <span>\(\theta\)
</span>, <span>\(\psi\)
</span>. The rotation matrix <code>Rd</code> is derived from these Euler angles.</p></li><li><p>Option 2: Users can input joint variables <code>q</code>, which are then processed and transformed into <code>pd</code> and <code>Rd</code> through direct kinematics. This option is particularly useful for validation purposes.</p></li></ul><p>To select either Option 1 or Option 2, two manual switches are provided. Both switches should be consistently either up (Option 1) or down (Option 2). Once the option is chosen, <code>pd</code> and <code>Rd</code> are transformed into <code>p07</code> and <code>R07</code>.</p><p>The inverse kinematics block accepts four inputs: <code>p07</code>, <code>R07</code>, <code>q1</code>, and a vector defining the robot&rsquo;s configuration. The configuration vector should consist of integers 0 or 1, representing:</p><ol><li>The elbow&rsquo;s orientation (1 for up, 0 for down).</li><li>The wrist&rsquo;s s6 value (1 for positive, 0 for negative).</li><li>The robot&rsquo;s orientation (1 for facing forwards, 0 for facing backward).</li><li>An additional number to address out-of-boundary positions when <code>q1</code> is fixed. Setting this value to 1 allows <code>q1</code> to take the inputted value, while 0 aligns <code>q1</code> with <code>xb</code> from the end effector position relative to the base reference frame — a &ldquo;free range&rdquo; configuration for <code>q1</code>.</li></ol><p>The output of the inverse kinematics block is the joints vector <code>q</code>, which feeds into the animation block (VR sink) and a direct kinematics block that outputs the obtained <code>R</code> and <code>p</code>. <code>q</code> is also displayed in a block labeled &ldquo;vector <code>q</code>&rdquo;. For validation purposes, a comparison is made between <code>pd</code> and <code>Rd</code> (desired) and <code>p</code> and <code>R</code> (obtained).</p><p>A switch at the bottom-left corner can be activated to halt the simulation when the robot encounters a singularity.</p><h3 id=41-validation>4.1. Validation
<a class=anchor href=#41-validation>#</a></h3><p>To add later&mldr;</p><h2 id=5-geometric-jacobian>5. Geometric Jacobian
<a class=anchor href=#5-geometric-jacobian>#</a></h2><h3 id=51-postion-validation>5.1. Postion Validation
<a class=anchor href=#51-postion-validation>#</a></h3><h3 id=52-orientation-validation>5.2. Orientation Validation
<a class=anchor href=#52-orientation-validation>#</a></h3><h3 id=53-kinematic-singularities>5.3. Kinematic Singularities
<a class=anchor href=#53-kinematic-singularities>#</a></h3><h2 id=6-closed-loop-inverse-kinematics-clik>6. Closed Loop Inverse Kinematics (CLIK)
<a class=anchor href=#6-closed-loop-inverse-kinematics-clik>#</a></h2><h3 id=61-validation>6.1. Validation
<a class=anchor href=#61-validation>#</a></h3><h2 id=7-link-properties>7. Link Properties
<a class=anchor href=#7-link-properties>#</a></h2><p>To incorporate the dynamics of the robot, it&rsquo;s essential to determine approximate values for the mechanical properties of the links. Solidworks, with its available CAD models, was employed for this purpose. Assigning a material in Solidworks is a crucial step, and since the CAD models represented solid bodies instead of hollow structures, it was necessary to adjust the density.</p><p>Given that the robot&rsquo;s manual specified a weight of 50 kilograms for the KR6 robot without the carriage and KL beam, a uniform density of 1680 kg/m³ was applied in Solidworks. This density adjustment resulted in the KR6 parts weighing approximately 50.4 kilograms, providing a satisfactory approximation. It&rsquo;s noteworthy that link 1 comprises two parts: the base of KR6 and a carriage supporting KR6. In the manual, the carriage weight is not included in the KR6&rsquo;s weight specification.</p><table><thead><tr><th>Link</th><th>Mass [\kg]</th><th>x</th><th>y</th><th>z</th><th>Ixx</th><th>Iyy</th><th>Izz</th><th>Ixy</th><th>Ixz</th><th>Iyz</th></tr></thead><tbody><tr><td>1</td><td>54.153</td><td>0.0004</td><td>-0.0005</td><td>0.4416</td><td>1.2211</td><td>1.3092</td><td>1.0273</td><td>-0.0033</td><td>-0.1784</td><td>0.0012</td></tr><tr><td>2</td><td>10.526</td><td>-0.0170</td><td>0.0674</td><td>0.0020</td><td>0.1277</td><td>0.0943</td><td>0.0840</td><td>0.0089</td><td>0</td><td>0.0009</td></tr><tr><td>3</td><td>12.299</td><td>-0.1840</td><td>-0.0053</td><td>-0.0058</td><td>0.0639</td><td>0.2515</td><td>0.2255</td><td>0.0015</td><td>0.0028</td><td>0</td></tr><tr><td>4</td><td>4.810</td><td>-0.0246</td><td>0</td><td>-0.0161</td><td>0.0164</td><td>0.0186</td><td>0.0136</td><td>0</td><td>0.0023</td><td>0</td></tr><tr><td>5</td><td>4.582</td><td>0.0001</td><td>-0.1341</td><td>0.0036</td><td>0.0287</td><td>0.0096</td><td>0.0259</td><td>0</td><td>0</td><td>-0.0003</td></tr><tr><td>6</td><td>0.747</td><td>0</td><td>0.0019</td><td>-0.0168</td><td>0.0010</td><td>0.0009</td><td>0.0005</td><td>0</td><td>0</td><td>0</td></tr><tr><td>7</td><td>0.023</td><td>0</td><td>0</td><td>-0.0075</td><td>3E-6</td><td>3E-6</td><td>5E-6</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>The inclusion of motors within the robot&rsquo;s links was modeled by representing them as cylinders with a diameter of 1 cm and a height of 10 cm, constructed from steel. The resulting inertia of the motors around their z-axis (Im) was determined to be 0.00021 kg m². Additionally, gear reduction ratios (<code>kr</code>) were set at a value of 100.</p><h2 id=8-newton-euler-formulation>8. Newton-Euler Formulation
<a class=anchor href=#8-newton-euler-formulation>#</a></h2><p>The Newton-Euler formulation relies on the equilibrium of forces acting on the manipulator&rsquo;s links. This formulation enables a recursive solution, divided into two sets of recursion:</p><ul><li><ol><li><strong>Forward Recursion</strong>: This phase propagates and computes link velocities and accelerations, commencing from link 1 and concluding at the end-effector.</li></ol></li><li><ol start=2><li><strong>Backward Recursion</strong>: In this phase, forces for prismatic joints and moments for revolute joints are propagated and calculated. The recursion begins at the end-effector and concludes at link 1.</li></ol></li></ul><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p>A key advantage of the Newton-Euler formulation lies in its simplicity of implementation, facilitating an efficient computation of the dynamics solution.</blockquote><p>The underlying concept of the Newton-Euler formulation is as follows: the forward recursion helps calculate velocities and accelerations, enabling the determination of end-effector forces and moments. Subsequently, by proceeding backward, each force and moment for the link preceding the end-effector is computed. This approach allows for the determination of all forces and moments acting on the links. With this information, the behaviour of torque joints for any trajectory can be calculated. Utilizing the torque joints, and assuming no external forces at the end-effector, the joint space dynamic model can be established.</p><span>\[B(q)\ddot{q} + C(q, \dot{q})\dot{q} + g(q) = \tau\]</span><p>In order to calculate the torques, the manipulator equation can be decomposed into three main components: the mass matrix <code>B</code>, the Coriolis/Centrifugal matrix <code>C</code> and a given gravity vector <code>g</code>. The term <span>\( C(q, \dot{q})\dot{q} \)
</span>can be expressed as a vector <span>\( \phi (q, \dot{q}) \)
</span>.</p><p>Implementing these calculations in real-time requires a dynamics block in Simulink. <a href=https://github.com/roaked/robotics-kinematics-dynamics-and-control/tree/main/DynamicsV1>A general Newton-Euler equation was developed in MATLAB</a>, capable of <a href=https://github.com/roaked/robotics-kinematics-dynamics-and-control/blob/main/DynamicsV1/Newton_Euler.m>solving the Newton-Euler formulation</a> for any robot with both revolute and prismatic joints. This equation takes the Denavit-Hartenberg (DH) table, along with the necessary properties of links and motors, and outputs the torques.</p><p>Using the function, it is possible to obtain <code>B</code>, <span>\(\phi\)
</span>, and <code>g</code>. The gravity vector is the simplest to obtain: <span>\(g = \tau (q, \dot{q}, q\ddot{q}) = \tau (q, 0, 0)\)
</span>. Imposing the joints velocities and accelerations to zero, <code>B</code> and <code>C</code> are erased from the equation.</p><p>To obtain the mass matrix, since it doesn’t depend on the velocity, <span>\(\dot{q}\)
</span>can be set to zero. The acceleration of gravity is also turned to zero, leaving the equation as <span>\(B(q\dot{q})\ddot{q} = \tau \)
</span>. Deriving the expressions by the vector <span>\(\ddot{q}\)
</span>, <code>B</code> is finally obtained.</p><p><span>\(\phi = C(q, \dot{q})\dot{q}\)
</span>is obtained by setting <span>\(\ddot{q}\)
</span>and the gravity acceleration to zero.</p><p>Regarding <code>B</code> and <span>\(\phi\)
</span>, another separation can be made. Both parameters can be divided by the contributions of the augmented links, <span>\(B_l\)
</span>and <span>\(\phi_l\)
</span>, and contributions of the motors, <span>\(B_m\)
</span>and <span>\(\phi_m\)
</span>. To obtain the contributions of the links, the mechanical properties of the motors <span>\(k_r\)
</span>and <span>\(I_m\)
</span>can be set to zero, while to obtain the motors&rsquo; contributions the masses of the links <code>m</code> and their inertia tensors <code>I</code> can be set to zero. This separation can be useful to visualize the influence of the motors on these parameters.</p><h3 id=81-validation>8.1. Validation
<a class=anchor href=#81-validation>#</a></h3><p><img src=https://live.staticflickr.com/65535/53468756072_f11d1ac5a6_b.jpg alt=50></p><p>The dynamics block takes the position and velocity vectors, q and <span>\(\dot{q}\)
</span>, as inputs and produces <code>B</code> and <span>\(\phi\)
</span>(with separated terms for contributions from links and motors) along with <code>g</code> as outputs. Accelerations are computed and then integrated to derive velocities, which are subsequently integrated to obtain positions.</p><span>\[\ddot{q} = B^{-1}(\tau - \phi - g)\]</span><p>By setting the torques to zero, the robot undergoes motion solely due to the influence of gravity. The nature of this movement is contingent upon the initial conditions of the robot. For instance, with initial conditions <span>\(q_0 = [ 0,0,0, −\frac{\pi}{2}, 0,0,0 ]\)
</span>, the robot exhibits pendulum-like behavior, with the arm fully extended. Absent viscous forces, mechanical energy is conserved, leading to sustained oscillations. Alternatively, setting the initial conditions to <span>\(q_0 = [ 0,\frac{\pi}{2},0,0 0,0,0 ]\)
</span>results in the arm behaving akin to a double pendulum as subsequently shown.</p><p><img src=https://live.staticflickr.com/65535/53469800668_6e985fb8b5.jpg alt=51></p><h2 id=9-decentralized-pid-joint-controllers>9. Decentralized PID Joint Controllers
<a class=anchor href=#9-decentralized-pid-joint-controllers>#</a></h2><p>The central concept behind the decentralized controller involves breaking down the manipulator into <code>n</code> independent systems, where <code>n</code> represents the number of joints. Each joint is then controlled independently. The proposed solution entails the creation of a closed-loop PID (Proportional-Integral-Derivative) controller for each joint. In this setup, the input is the desired joint value <code>qd</code> and the output is the <code>q</code> values, which the KR6 Robot uses for computation. This approach relies on the equation:</p><span>\[\tau = -K_d \dot{q} + K_p(q - q_d) - K_i \int (q - q_d) \, dt\]</span><p>The integral action in the PID controller serves to eliminate the persistent error induced by the simulated gravity. Consequently, instead of using the integral gain, replace it by directly incorporating the manipulator&rsquo;s gravity compensation outputs for each joint. This adjustment helps counteract the influence of simulated gravity and contributes to improved control performance.</p><span>\[\tau = -K_d \dot{q} + K_p(q - q_d) + g(q)\]</span><p>Opting for a PD (Proportional-Derivative) controller without an integral gain is beneficial as it avoids introducing a pole at the origin, which could otherwise slow down the system response. The chosen approach involves creating a PD controller and incorporating gravity compensation. In this setup, the dynamics manipulator receives an initial condition and produces the joint velocities <span>\( `\dot{q}` \)
</span>, joint values <code>q</code> and gravity compensation. These outputs feed into the controller, which computes a new torque <span>\( `\tau` \)
</span>. This torque is then fed back into the dynamics manipulator, resulting in updated joint values <code>q</code> that are subsequently utilized in the actual robot. This iterative process helps refine the control of the system.</p><p><img src=https://live.staticflickr.com/65535/53468756057_84d50fd68c_z.jpg alt=52></p><h3 id=91-stifness-and-damping-gains>9.1. Stifness and Damping Gains
<a class=anchor href=#91-stifness-and-damping-gains>#</a></h3><p>To determine the values for the Stiffness <code>Kp</code> and Damping <code>Kd</code> gains:</p><span>\[B(q)\ddot{q} + C(q, \dot{q})\dot{q} + g(q) = -K_d\dot{q} + K_p(q - q_d) + g(q)\]</span><p>By removing the gravity compensation from both sides and making the assumption that in the decentralized controller, the joints are decoupled and the model is completely linearized — thus <span>\( \dot{q}^2 \approx 0 \)
</span>and the Coriolis effect <span>\( C(q, \dot{q})\dot{q} \)
</span>infered to be null.</p><span>\[B(q)\ddot{q} = -K_d\dot{q} + K_p(q - q_d)\]</span><p>Obtaining the transfer function of second order using Laplace transform:</p><span>\[\frac{q(s)}{q_d(s)} = \frac{\frac{K_p}{B}}{s^2 + \frac{K_d}{B}s + \frac{K_p}{B}}\]</span><p>Comparing the second-order system without dampening and natural frequency with a second-order system with dampening and natural frequency, it is safe to conclude:</p><span>\[\frac{\omega_n^2}{s^2 + 2 \xi \omega_n s + \omega_n^2} = \frac{\frac{K_p}{B}}{s^2 + \frac{K_d}{B}s + \frac{K_p}{B}}\]
</span><span>\[K_p = \omega_n^2 B\]
</span><span>\[K_d = 2 \xi \omega_n^2 B\]</span><p>Hence, <code>B</code> will be represented by the maximum values of the mass matrix <code>B</code> diagonal. Given that each joint will be controlled separately, each joint will have its respective <code>Kd</code>, <code>Kp</code> and <code>B</code>.</p><h3 id=92-worst-case-inertia>9.2. Worst Case Inertia
<a class=anchor href=#92-worst-case-inertia>#</a></h3><p>To identify the worst-case inertia, represented by the maximum values along the diagonal of the <code>B</code> matrix, a trial-and-error method was employed by searching for joint values <code>q</code>. The obtained values and the corresponding robot configurations for each inertia are shown in the table. Notably, for joints <code>q1</code>, <code>q2</code> and <code>q3</code> the changes in inertia values were negligible, suggesting that any configuration of <code>q</code> would yield the maximum inertia value for these joints.</p><pre><code>  | Maximum Inertia  | Joint values [\º]  |
</code></pre><table><thead><tr><th>Joint</th><th>[Kg ⋅ m^2]</th><th>q1</th><th>q2</th><th>q3</th><th>q4</th><th>q5</th><th>q6</th><th>q7</th></tr></thead><tbody><tr><td>q1</td><td>89.24</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>q2</td><td>5.319</td><td>-</td><td>-</td><td>0</td><td>10</td><td>-145</td><td>0</td><td>-</td></tr><tr><td>q3</td><td>4.876</td><td>-</td><td>-</td><td>-</td><td>10</td><td>-90</td><td>0</td><td>-</td></tr><tr><td>q4</td><td>2.516</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-90</td><td>0</td><td>-</td></tr><tr><td>q5</td><td>2.111</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td><td>- [-140,-45] and [45,140]</td><td>-</td></tr><tr><td>q6</td><td>2.101</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>q7</td><td>2.1</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><details><summary><strong>Configurations:</strong> q2, q3 and q5 - (click to expand)</summary><div class=markdown-inner><p><code>q2</code> configuration:</p><p><img src=https://live.staticflickr.com/65535/53469658316_d7eab0a5b8_w.jpg alt=53></p><p><code>q3</code> configuration:</p><p><img src=https://live.staticflickr.com/65535/53469800663_f1ea4ae6a4.jpg alt=54></p><p><code>q5</code> configuration:</p><p><img src=https://live.staticflickr.com/65535/53469658306_13bc14c536.jpg alt=55></p></div></details><h3 id=93-controller-gains-tuning>9.3. Controller Gains Tuning
<a class=anchor href=#93-controller-gains-tuning>#</a></h3><h2 id=10-centralized-controller>10. Centralized Controller
<a class=anchor href=#10-centralized-controller>#</a></h2><h2 id=11-trajectory-planning>11. Trajectory Planning
<a class=anchor href=#11-trajectory-planning>#</a></h2><h3 id=111-trajectory-with-decentralized-controller>11.1. Trajectory with Decentralized Controller
<a class=anchor href=#111-trajectory-with-decentralized-controller>#</a></h3><h3 id=112-trajectory-with-centralized-controller>11.2. Trajectory with Centralized Controller
<a class=anchor href=#112-trajectory-with-centralized-controller>#</a></h3></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/roaked/roaked.github.io/commit/c5db43ce641bb05ba0db4cab75f76336c685c40c title='Last modified by roaked | January 17, 2024' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>January 17, 2024</span></a></div><div><a class="flex align-center" href=https://github.com/roaked/roaked.github.io/edit/main/content/content/docs/code/robotics/_index.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Ricardo Chin</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#1-abstract>1. Abstract</a></li><li><a href=#2-kinematics>2. Kinematics</a></li><li><a href=#3-direct-kinematics>3. Direct Kinematics</a><ul><li><a href=#31-validation>3.1. Validation</a></li><li><a href=#32-joint-trajectories>3.2. Joint Trajectories</a></li></ul></li><li><a href=#4-inverse-kinematics>4. Inverse Kinematics</a><ul><li><a href=#41-validation>4.1. Validation</a></li></ul></li><li><a href=#5-geometric-jacobian>5. Geometric Jacobian</a><ul><li><a href=#51-postion-validation>5.1. Postion Validation</a></li><li><a href=#52-orientation-validation>5.2. Orientation Validation</a></li><li><a href=#53-kinematic-singularities>5.3. Kinematic Singularities</a></li></ul></li><li><a href=#6-closed-loop-inverse-kinematics-clik>6. Closed Loop Inverse Kinematics (CLIK)</a><ul><li><a href=#61-validation>6.1. Validation</a></li></ul></li><li><a href=#7-link-properties>7. Link Properties</a></li><li><a href=#8-newton-euler-formulation>8. Newton-Euler Formulation</a><ul><li><a href=#81-validation>8.1. Validation</a></li></ul></li><li><a href=#9-decentralized-pid-joint-controllers>9. Decentralized PID Joint Controllers</a><ul><li><a href=#91-stifness-and-damping-gains>9.1. Stifness and Damping Gains</a></li><li><a href=#92-worst-case-inertia>9.2. Worst Case Inertia</a></li><li><a href=#93-controller-gains-tuning>9.3. Controller Gains Tuning</a></li></ul></li><li><a href=#10-centralized-controller>10. Centralized Controller</a></li><li><a href=#11-trajectory-planning>11. Trajectory Planning</a><ul><li><a href=#111-trajectory-with-decentralized-controller>11.1. Trajectory with Decentralized Controller</a></li><li><a href=#112-trajectory-with-centralized-controller>11.2. Trajectory with Centralized Controller</a></li></ul></li></ul></nav></div></aside></main></body></html>