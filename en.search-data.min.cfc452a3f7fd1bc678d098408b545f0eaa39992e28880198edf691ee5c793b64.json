[{"id":0,"href":"/docs/1design/","title":"Design Portfolio","section":"Docs","content":" Workflow # Hey hey! Welcome to my design project hangout — a mashup of my academic journey and awesome collaborations. This place is packed with my adventures in Computational Fluid Dynamics (CFD), Finite Element Analysis (FEA), and loads of cool 3D CAD projects.\nPicture this: late-night brainstorming, diving into simulations of fluid dynamics, thermal analysis, and structural mechanics, and then making those wild ideas real. It\u0026rsquo;s like a ride where design and simulation crash together in the coolest ways.\nI\u0026rsquo;m totally up for collaborating on any design projects — let\u0026rsquo;s create something new!\n"},{"id":1,"href":"/docs/1design/1mest/","title":"FEA Beam Instability","section":"Design Portfolio","content":" Beam Me Up, Scotty! # 1 Beams \u0026amp; Deformations # In this project, the process of modeling and simulating a beam with a thin-walled, constant cross-section in a C-profile along a length L will be described. Siemens NX 12 software, a commercial finite element program, was used to obtain the global and local instability modes of the beam under compression loading.\ninfo\nConsider the following values:\nThickness t = 2.25L Width B = 100 mm Height H = 189 mm Length L = 1445 mms Young\u0026rsquo;s Modulus E = 200 GPA Yield Stress σy = 700 MPa Poisson\u0026rsquo;s Ratio = 0.3 In addition, boundary conditions (fixed support at the left end and sliding support at the right end) are also shown as follows:\nLooking at the cross-section\u0026hellip;\nCentroid position: Cy = -26.55 mm, Cz = 94.5 mm Moment of inertia in y-axis: Iy = 5101270.5 mm^4 Moment of inertia in z-axis: Iz = 890980.8 mm^4 Cross-sectional area: A = 865.125 mm^2 To analyze the results obtained in NX, it will be necessary to calculate the analytical values. For the boundary conditions of the problem (fixed support at the left end and sliding support at the right end), the calculation of the critical load for a beam with Euler-Bernoulli elements is given by:\nWhere the inertia to be used is the smaller value, namely Iz. However, NX solves the problem with Timoshenko elements. The conversion of the load from Euler-Bernoulli elements to Timoshenko elements is given by:\n\\[P_{cr}^T = \\frac{P_{cr}^{EB}}{1\u0026#43;\\frac{P_{cr}^{EB}}{G \\times A_s}} = \\frac{P_{cr}^{EB}}{1\u0026#43;\\frac{P_{cr}^{EB}}{ \\frac{E \\times A \\times K_s}{2 (1\u0026#43;\\upsilon)} }}\\] G and As are given by:\n\\[G = \\frac{E}{2(1\u0026#43;\\upsilon)} \\quad \\, \\quad A_s = A \\times K_s\\] The value of Ks can be obtained in NX, within the properties of the section created in the fem file for 1D elements, and it is equal to 0.32592771.\n2 1D Elements # 2.1. Modeling \u0026amp; Meshing # In the NX software, the modeling begins with the creation of a part. To model the beam with 1D elements, simply draw a sketch composed of a line with a length of L = 1445 mm oriented along the X-axis direction. Afterwards, the FEM file is created. In this file, the finite element mesh is generated.\nTo obtain the mesh, a mesh collector is required, in this case, a Beam Collector of type PBEAML. Within the properties of the PBEAML, define the section type (CHAN) and its parameters (base, height, and section thickness). Once the section is defined, it\u0026rsquo;s possible to analyze its properties such as area, centroid, moments of inertia, shear correction factors, among others, calculated by the software. The material of the beam is also defined within the PBEAML. For this purpose, a material is created with the desired Young\u0026rsquo;s modulus, yield stress, and Poisson\u0026rsquo;s ratio.\nThe mesh elements are defined as CBeam elements (beam elements). Within the mesh properties, establish the orientation of the section and its position relative to the beam line. The aim is to ensure that the beam line coincides with the centroid of the section.\nFinally, the sim file is created. In this file, start by defining the solution type. To perform the linear stability analysis in order to obtain the instability modes, the SOL 105 Linear Buckling solution is used.\nWithin the sim file, the boundary conditions and the loads of the problem are applied. In this specific problem, the beam is fixed at the left end and has a sliding support, along with an applied load, at the right end.\nThese conditions are applied at the nodes. Hence, the node at the left end is fixed, preventing both rotations and translations, while the node at the right end is constrained to allow translation only along the X-axis (degree of freedom 1 in NX) and to permit rotation along the Y and Z axes (degrees of freedom 5 and 6 in NX). At the node on the right end, a reference load (1 kN) is applied, directed along the negative X-axis (compressive load).\nOnce the solution type, constraints, and applied loads are defined, the solution to the problem is obtained. This involves running the analysis within the software to calculate the response of the structure under the specified conditions. The software will then provide results such as critical loads, instability modes, deformations, stresses, or any other relevant outputs based on the defined parameters and boundary conditions.\n2.2. Linear Stability Analysis in 1D Beam # Executing the Solve command in NX yielded the following results for the first 10 instability modes.\nMode Instability Load (kN) 1 1631.13 2 4385.45 3 7710.4 4 11029.3 5 11361.5 6 13018.2 7 16547.2 8 18614.2 9 20274.7 10 21598.9 The critical instability load for the 1D model corresponds to the smallest instability load obtained in NX, which is 1631.13 kN (mode 1). The instability modes present in the 1D model\u0026rsquo;s solution correspond to global instability modes (beam mode - axis buckling).\nThe beam exhibits rotation about the Z-axis, which has the smallest moment of inertia. Subsequently, it is reasonable to calculate the analytical value.\nStarting with a beam consisting of Euler-Bernoulli elements:\n\\[P_{cr}^{EB} = 2.05 \\times \\frac{\\pi^2 \\times E \\times I}{L^2} = 2.05 \\times \\frac{\\pi^2 \\times 200 \\times 10^9 \\times 890980.8 \\times 10^{-12}}{1.445^2} = 1726.7 kN \\\\\\] Converting to Timoshenko elements\u0026hellip;\n\\[P_{cr}^T = \\frac{P_{cr}^{EB}}{1\u0026#43;\\frac{P_{cr}^{EB}}{ \\frac{E \\times A \\times K_s}{2(1\u0026#43;\\upsilon)} }} = \\frac{1726 \\times 10^3}{1\u0026#43;\\frac{1726 \\times 10^3}{ \\frac{200 \\times 865.125 \\times 0.3259 \\times 10^3}{2(1\u0026#43;0.3)} }} = 1682.3 kN\\] The relative error is given by:\n\\[e = \\frac{\\left| P_{cr}^T - P_{cr}^{NX} \\right|}{P_{cr}^T } \\times 100\\% = \\frac{1682.3 - 1631.13}{1682.3} = 3\\%\\] The critical instability load obtained in NX has an error of 3% compared to the analytical value.\n3 2D Elements # 3.1. Modeling \u0026amp; Meshing # In the part file, a sketch is created in the YZ plane depicting the mid-section thickness line. An extrusion of length L is made along the X-plane from this sketch.\nIn the fem file, the mesh is generated using a PSHELL-type mesh collector. Within the properties of the PSHELL, the material properties (desired Young\u0026rsquo;s modulus, yield stress, and Poisson\u0026rsquo;s coefficient) are defined, and the section thickness (t=2.25mm) is inserted. The 2D mesh elements are defined as CQUAD4 (quadrilateral elements).\nAfter obtaining the mesh, rigid elements need to be introduced at the ends. To do this, two nodes are created, one at each end of the beam, with Y and Z coordinates corresponding to the centroid of the section. Using the 1D connection command, a rigid element is created at each end, connecting the nodes present at each end.\nIn the sim file, the process is similar to what was described for 1D elements. Boundary conditions and constraints are applied to the nodes previously created at the ends passing through the centroid of the section.\nOnce the solution type, constraints, and applied loads are defined, the solution to the problem is obtained.\n3.2. Linear Stability Analysis in 2D Beam # "},{"id":2,"href":"/docs/2code/1drone/","title":"UAV Red Bull Air Racing","section":"Coding Portfolio","content":" An Autonomous Drone Racing Competition # 1 RedBull Racing # The world of Red Bull drone racing stands at the intersection of high-speed competition and very advanced technology. In this exhilarating arena, unmanned aerial vehicles (UAVs) navigate intricate courses filled with obstacles, pushing the limits of flight capabilities and piloting skills. To revolutionize this dynamic sport, I developped a model that aims to integrate advanced AI, computer vision, and simulated dynamics to elevate drone performance and safety within the competitive realm.\n2 Overview # This interesting concept revolves around the development of a comprehensive system that seamlessly combines state-of-the-art technologies to enhance Red Bull drone racing. It is desired to fuse AI-driven algorithms, computer vision systems, and simulated dynamics modeling to optimize drone navigation through complex racecourses.\ninfo\nTopics:\nComputer Vision or AI-Enabled Obstacle Detection and Avoidance: Implement sophisticated AI algorithms coupled with computer vision systems onboard the drones. These systems will enable real-time obstacle detection and swift maneuvering to avoid collisions during high-speed races.\nSimulated Dynamics Modeling: Develop intricate models that encapsulate the intricate dynamics of the drones, including aerodynamics, motor responses, and environmental interactions. This simulation will accurately predict drone behaviour in various scenarios, aiding in performance optimization.\nSimulink Integration via TCP/IP: Establish a robust connection between the simulated drone dynamics model in Simulink and the actual drones using TCP/IP. This connection facilitates real-time communication, enabling testing and refinement of control algorithms in a virtual environment. This will be done by accessing an external library.\nAs previously mentioned, this approach enhances drone maneuverability and agility when navigating intricate racecourses, elevates safety by detecting and avoiding obstacles in real time, and fine-tunes control algorithms for high-speed racing situations.\n3 Work Division # Given how complex this project turned out to be, I have decided to structure it into distinct sections to comprehensively cover various aspects of the system design:\ninfo\nDrone System Dynamics Modeling and Controller Design: This section will focus on developing and analyzing models for the drone\u0026rsquo;s dynamics. It will delve into understanding how the drone behaves under different conditions and designing an appropriate controller to optimize its performance. The foundation of this section of the work draws heavily from the theoretical knowledge acquired from an external MOOC (Massive Open Online Course), developed by Prof. Alexandra Moutinho and Prof. José Azinheira, accessible by clicking here.\nDrone Computer Vision for Obstacle Detection: This part will concentrate on integrating computer vision techniques into the drone system. It aims to enable real-time obstacle detection and avoidance strategies, enhancing the drone\u0026rsquo;s ability to navigate complex environments.\nIntegration of AI with System Components: This section aims to unify AI algorithms with the previously developed system dynamics model, controller, and computer vision capabilities. It seeks to leverage AI to further enhance overall performance, responsiveness, and decision-making of the drone during Red Bull racing scenarios.\nBy splitting the report into these segments, it is expected to inspect each aspect thoroughly while maintaining a clear focus on how these components can synergize to enhance the capabilities of Red Bull racing drones.\n4 Reading Guide # tip\nThe sections are pretty extensive, containing descriptive explaination of the work done, but I have inserted an hyperlink at the beginning of each section redirecting to the last chapter containing summarized findings. tip\nThat said: Advance to UAV System Dynamics Design Here ✌️ 5 Drone Characteristics # Drone Physical Properties: - (click to expand) Parameter Value Unit Mass M 0.475 kg Moment of inertia J_{xx} 2.2 x 10^{-3} kg.m^2 Moment of inertia J_{yy} 2.5 x 10^{-3} kg.m^2 Moment of inertia J_{zz} 4.5 x 10^{-3} kg.m^2 Arm length b 0.177 m Gravity g 9.81 m/s^2 Force (thrust) constant K_t 9.2 x 10^{-6} N(rad/s)^{-2} Momentum constant K_q 0.32 x 10^{-6} Nm(rad/s)^{-2} Voltage constant K_Ω 0.002 (rad/s)^{-1} Motor dynamics approximated by static gain : δi ~ KΩ x Ωi 6 State Space Models (Later..) # 7 Simulink Linear Model (Later..) # 8 Simulink Nonlinear Model (Later..) # "},{"id":3,"href":"/docs/2code/2is/","title":"AGV: System Identification","section":"Coding Portfolio","content":" They See Me Rollin\u0026rsquo;, They Navigatin\u0026rsquo; # System Identification: AGV # I wanted to understand how a cool robot called \u0026ldquo;Rasteirinho\u0026rdquo; works when told to perform certain tasks, and how it reacted to certain commands. To achieve this, real-time simulations were executed using Matlab and relevant toolboxes such as the System Identification Toolbox and its reactions were studied. This helped understanding how the robot behaved when asked to do different things.\ninfo\nDeterministic Systems Analysis: The preliminary focus was on deterministic systems, where a consistent input produced a predictable output. This phase provided foundational insights into the system\u0026rsquo;s response under controlled and repeatable conditions. Transition to Stochastic Systems: The investigation then progressed to stochastic systems, encompassing both continuous and discrete models. Contrary to deterministic systems, stochastic processes introduced unpredictability. Notably, experiments employing filtered white noise as input demonstrated varying reactions across iterations, emphasizing the inherent stochastic nature of the system. Data Collection and Analysis: Data collected from these experiments formed the basis for analysis, leveraging a spectrum of methodologies and tools available in Matlab. The diverse approaches facilitated a comprehensive examination of the system\u0026rsquo;s behavior under stochastic conditions. The discussions and conclusions drawn stem from the outcomes obtained through multiple analytical methods. The variability observed in stochastic systems prompted insightful considerations regarding the \u0026ldquo;Rasteirinho\u0026rdquo; system\u0026rsquo;s behaviour and characteristics. How this variability impacts the overall understanding and analysis of the system becomes a pivotal point for consideration and further exploration.\ntip\nFurther investigation into the implications of stochastic behaviour on control mechanisms within the \u0026ldquo;Rasteirinho\u0026rdquo; system could deepen our understanding. Exploring advanced analytical techniques and expanding the scope of experiments might offer more nuanced insights into the system\u0026rsquo;s behaviour. 1 System Model # 1.1. Rasteirinho # The primary function of the \u0026ldquo;Rasteirinho\u0026rdquo; system is autonomous navigation along a predefined path delineated by the black line on the floor. Through the coordinated operation of its components, the system employs sensor data from the camera, interprets it using the path-following algorithm, and generates control signals to the motors for precise movement, ensuring the system stays aligned with the designated path. The \u0026ldquo;Rasteirinho\u0026rdquo; system comprises several interconnected components designed for path tracking. At its core, it features:\nLaptop with Camera: The system\u0026rsquo;s sensory input is facilitated by a laptop equipped with a camera. This camera serves as the primary sensor to capture visual data from the environment.\nBase with Wheels: A base structure provides support for the components and houses wheels essential for locomotion.\nMotors and Encoders: The system incorporates motors to drive the wheels, enabling controlled movement along the designated path. Encoders are utilized to measure and track wheel rotations, aiding in precise movement control and feedback.\nArduino Control: The Arduino platform serves as the control unit, orchestrating the interactions between the laptop, camera, motors, and encoders. It facilitates the integration of sensory information with control signals for effective navigation.\nPath Following Algorithm: The system is programmed with a path-following algorithm that interprets visual data captured by the camera to detect and follow the black line on the floor. This algorithm involves image processing techniques to analyze the captured images and determine the correct path for the system to follow.\nThe system\u0026rsquo;s purpose is rooted in exploring concepts of robotics, control systems, and computer vision. By combining hardware (motors, encoders, etc.) and software (path-following algorithms, image processing), it aims to demonstrate autonomous navigation capabilities and the integration of various technologies for a specific task—following a marked path.\n1.2. Non-linearities # The input signal provided to the system is derived from the deviation of the system from the center of the marked line on the floor. This deviation is likely quantified as a distance in pixels from the center of the line, considering the image captured by the camera, which has a resolution of 160 pixels width-wise. The assumed center is positioned at pixel 80.\nThe output signal corresponds to the distance from the system to a specific part of the line, presumably the portion furthest to the left in the captured image. This output signal\u0026rsquo;s measurement allows the system to gauge its position relative to this reference point along the line.\nDescription: Soft Non-linearities - (click to expand) Variations in lighting conditions, camera placement, angle, imperfections on the lab ground, and camera resolution introduce soft non-linearities to the system. These factors influence the system\u0026rsquo;s behaviour and response but were approximated in the model without significantly compromising its accuracy. Managing these non-linearities involved calibration and adjustment techniques to mitigate their effects on the system\u0026rsquo;s performance. Description: Hard Non-linearities - (click to expand) The system encounters two hard non-linearities — namely, a dead zone and a saturation zone. These non-linearities stem from constraints related to the input voltage, resulting in minimum and maximum values. The dead zone represents a region where the input signal remains unresponsive or exhibits minimal response. On the other hand, the saturation zone indicates a limit where the system\u0026rsquo;s response reaches its maximum capacity and remains constant despite further increases in the input signal. 1.3. Sampling Time # The chosen sampling time, Ts = 1/30 seconds (or approximately 33.33 milliseconds), aligns with the frame rate of 30 frames per second supported by the system\u0026rsquo;s camera.\nThis sampling frequency translates to a corresponding angular frequency of 190.4 radians per second (rad/s). This frequency is deemed adequate for the system\u0026rsquo;s dynamics, as it accommodates the characteristics and behaviour of the system, which likely doesn\u0026rsquo;t exhibit high-frequency responses.\nBy choosing an appropriate sampling time that aligns with the system\u0026rsquo;s dynamics, the collected data can adequately represent the system\u0026rsquo;s behaviour without introducing aliasing or missing high-frequency components that might not be relevant or present in the system\u0026rsquo;s response.\n2 Deterministic Identification # It is seen that in Simulink, the system received two distinct types of inputs: sinusoidal and square signals, each with different parameter settings. It is stated that by observing the resultant outputs corresponding to these inputs, multiple methods may be employed to derive the transfer function. The procedure, as conveyed, was visually represented through a diagram showcased within Simulink, outlining the step-by-step process involved in this analysis.\n2.1. Step Response Method # In the lab trials, data on input, output, and time were recorded. Various amplitudes of square waves were used to identify the step response with the least noise. The importance of obtaining high-quality data for analysis and system identification was emphasized, leading to the recording of multiple samples.\nSample 1: Square Input with Amplitude = 25, Frequency 0.5 vs System Output - (click to expand) Sample 2: Square Input with Amplitude = 10, Frequency 0.5 vs System Output - (click to expand) Sample 2: Square Input with Amplitude = 7.5, Frequency 0.3 vs System Output - (click to expand) In the plots, disturbances at the start and end are observed, originating from the initial placement and stopping of the Rasteirinho. The presence of overshoot indicates that it\u0026rsquo;s not a first-order system, as evident from the plots. Interestingly, in a linear system, signal amplitude typically doesn\u0026rsquo;t affect settling time, which contrasts with the observations, implying non-linearity. However, there\u0026rsquo;s a linear characteristic where response gain increases with input amplitude, suggesting a semblance of linearity. Despite its non-linear nature, the system exhibits behaviors aligning with the superposition principle, enabling its modeling as linear.\nThe System Identification Toolbox in MATLAB was utilized to estimate the system\u0026rsquo;s order and the count of zeros. This step is crucial for signal pre-processing, providing insights into the system\u0026rsquo;s order for subsequent analysis.\nThe upcoming equation describes the relationship between the input and output of your system, derived from the analysis performed using the System Identification Toolbox. It\u0026rsquo;s a 4th-order model with 4 poles and 3 zeros.\n\\[G_{\\text{ident}}(s) = \\frac{9.375s^3 \u0026#43; 448.9s^2 \u0026#43; 3793s \u0026#43; 6750}{17.03s^4 \u0026#43; 17.03s^3 \u0026#43; 435.1s^2 \u0026#43; 3263s \u0026#43; 7500}\\] 2.2. Deconvolution Method # The deconvolution method is being employed to derive the impulse response by deconvoluting the convolution integral. The input and output data from the step function are utilized to compute the impulse response, which is subsequently compared with the impulse response obtained from the transfer function using the System Identification Toolbox.\nNotably, while similarities are evident, discrepancies exist in the responses due to several reasons. The deconvolution method proves highly sensitive to measurement noise, encountering challenges with an ill-conditioned, unsymmetrical Toeplitz matrix \u0026lsquo;u.\u0026rsquo; Moreover, the impulse response, derived as the derivative of the step response, tends to amplify noise.\nFollowing this comparison, the \u0026lsquo;ir2dtf\u0026rsquo; function and \u0026lsquo;d2c\u0026rsquo; MATLAB function are employed to derive the step response of the system identified through deconvolution - code available. This process involves resampling the deconvolution data and carefully selecting the most representative points from the transient response. The choice of a 4th-order system proves optimal for achieving favourable outcomes. The resulting step response is subsequently obtained for further analysis.\nYielding:\n\\[G_{\\text{deterministicStep}}(s) = \\frac{309.8s^3 \u0026#43; 7682s^2 \u0026#43; 4.842 \\times 10^5s \u0026#43; 1.745 \\times 10^6}{18.84s^4 \u0026#43; 801.3s^3 \u0026#43; 991.6s^2 \u0026#43; 1.868 \\times 10^4s \u0026#43; 1.745 \\times 10^6}\\] Subsequently, comparing the impulse responses of the different methods and assess their validity:\nDespite the discrepancies evident in the graphs, a notable convergence emerges. Primarily, the significant deviation at the initial peak possibly arises from the amplified noise during the deconvolution process. However, upon a closer examination of the remaining parameters, notable similarities become apparent. The graphs demonstrate congruent peak times and settling times, signifying stability across all observations.\n2.3. Levy Method # The Levy Method, designed to minimize error between data and estimated model frequency responses, employs curve fitting in amplitude and phase within the numerical frequency domain - code available. This method\u0026rsquo;s utilization of Bode plots enables a comprehensive comparison of results as follows:\nPrior to applying the Levy function, a crucial step involved computing the Fourier transform of the deconvolution. This was achieved using a bespoke function that employs the discrete Fourier transform algorithm. This function determined the gain, phase, and associated frequencies from the acquired points, serving as inputs for the subsequent Levy function.\nUpon examination, it became apparent that higher frequency values within the Fourier Transform failed to accurately represent the system dynamics. Despite attempts to represent the initial 10 points, not all points aligned on the phase diagram due to disparities. In the magnitude plot, discrepancies were also notable for higher frequencies. These discrepancies stem from the Rasteirinho\u0026rsquo;s slower system response, where noise interference significantly impacts higher frequencies. Consequently, the initial few points of the Fourier Transform were selectively used to generate the Bode plot via the Levy method.\nFollowing the execution of the Levy function, the presence of unstable poles within the transfer function needed rectification. This requirement arose from occasional instability in the estimated function, a common occurrence within the numerical nature of the Levy method — an aspect encountered during analysis.\nThe comparative plot above offers a glimpse into step responses acquired via distinct methodologies (Levy, Matlab Sim toolbox and decovolution), unveiling a remarkable resemblance in their behaviour. However, notable distinctions arise, particularly in the deconvolution method, which exhibits a pronounced overshoot peak. This discrepancy suggests a heightened susceptibility to noise interference within the deconvolution process. Consequently, the resulting transfer function obtained from these analyses is as follows:\n\\[G_{\\text{LevyData1}}(s) = \\frac{3085s^2 \u0026#43; 3.098 \\times 10^5s \u0026#43; 5.176 \\times 10^6}{s^3 \u0026#43; 123s^2 \u0026#43; 2864s \u0026#43; 6.932 \\times 10^4}\\] 2.4. Data Analysis and Assessment # The prior findings stemmed from the analysis of a singular transient response, selected from the numerous step inputs showcased previously. Considering multiple available plots and simulated square functions, it becomes imperative to validate the conclusions drawn from the chosen transient response against the entirety of the responses.\nThese initial results, derived from the initial experiment, will now undergo comparison with the other two initially collected data samples. This comparative analysis aims to ascertain the continued validity of our conclusions across the spectrum of responses gathered, ensuring the robustness and generalizability of our findings.\n\\[G_{\\text{data2Deconv}}(s) = \\frac{368.5s^3 \u0026#43; 412.6s^2 \u0026#43; 1.288 \\times 10^5s \u0026#43; 4.188 \\times 10^5}{s^4 \u0026#43; 23.09s^3 \u0026#43; 512.3s^2 \u0026#43; 6501s \u0026#43; 2.957 \\times 10^4}\\] \\[G_{\\text{data3Deconv}}(s) = \\frac{161.6s^3 \u0026#43; 2236 \u0026#43; 1.804 \\times 10^5s \u0026#43; 1.508 \\times 10^5}{s^4 \u0026#43; 14.59s^3 \u0026#43; 723s^2 \u0026#43; 5760s \u0026#43; 6.186 \\times 10^4}\\] The comparison conducted via the Step Method using deconvolution and estimation via the System Identification Toolbox appears valid, despite a slight frequency offset observed in the step responses across different data samples. These discrepancies can be attributed to disturbances impacting the system dynamics, altering an array of variables in real-time. Consequently, achieving identical step responses from diverse data samples becomes entirely unattainable.\n3 Stochastic Identification # When conducting stochastic system identification, the input signal is inherently random, making it challenging to describe the system using conventional physical laws. Analyzing such a system requires a distinct methodology, employing specialized functions like the correlation function, distribution function, and density function. This approach hinges on assuming stationarity within the system, ensuring that both the mean and variance remain constant over time. Moreover, it relies on the assumption of ergodicity, implying that a single sample encapsulates all the statistical properties of the system.\n3.1. Data and Correlation Analysis # It was recorded data for tests with different noise power. Using a noise power of 3 the following data was recorded:\nFollowing the application of the \u0026ldquo;detrend\u0026rdquo; function in MATLAB to eliminate any offset, the subsequent use of the \u0026ldquo;cra\u0026rdquo; MATLAB function provided essential outcomes. This function facilitated the derivation of the covariance function, capturing the relationship between the input and output signals, along with the correlation from input to output. Additionally, it aided in estimating the impulse response, crucial for understanding system behavior and dynamics.\nAs anticipated, the correlation from input to output tends toward zero for negative lags, suggesting a unidirectional correlation wherein the output is related to the input, but not vice versa. Next, it\u0026rsquo;s valuable to compare the impulse response obtained from the stochastic system identification with the deterministic one derived from deconvolution. This comparison allows to discern and evaluate potential differences between the responses generated by these distinct methodologies.\nThe functions depicted in the plot exhibit a noticeable time delay, suggesting that the components within the system might respond after the initial occurrence of the disturbance. Apart from this delay, the graphs display similarities, aligning with initial expectations. This similarity indicates consistency between the responses generated, validating the anticipated behaviour of the system under analysis.\n3.2. Step Response # Now, following a procedure akin to the one employed in deterministic processes, it is possible to utilize the \u0026ldquo;ir2dtf\u0026rdquo; and \u0026ldquo;d2c\u0026rdquo; functions to derive the transfer function for the stochastic system. Utilizing \u0026ldquo;ir2dtf\u0026rdquo; involves selecting specific points that yield optimal outcomes, often through trial and error. Once these points are identified, the step response is extracted. This step response provides crucial insights into the dynamic behaviour of the system under stochastic conditions.\n\\[G_{\\text{StochasticStep}}(s) = \\frac{1.489s\u0026#43;442.7}{s^2\u0026#43;6.077\u0026#43;442.7}\\] 3.3. Levy Method # Likewise:\n\\[G_{\\text{StochasticLevy}}(s) = \\frac{-24.59s\u0026#43;295}{s^2\u0026#43;5.944s\u0026#43;210.8}\\] 4 Results Discussion - Deterministic and Stochastic # Step response comparison between deterministic and stochastic identification:\nThe Normalized Root Mean Squared was used to estimate the fitting of the showcased models.\n5 Stochastic Identification for Discrete Models # The project discussed the focus on discrete representations of stationary stochastic processes, emphasizing attributes up to the second order, like mean and variance. However, it acknowledged that in reality, many stochastic processes display nonstationarity in mean and variance over time.\nGiven the aforementioned, a shift in the approach was taken, recognizing that relying solely on white noise signals is inadequate for representing stochastic systems affected by external inputs. To address this limitation, it was recommended exploring models integrating both white noise and system dynamics using the System Identification Toolbox. The aim was to remove mean and trend values, employing statistical criteria like AIC or BIC to evaluate the accuracy of estimations. This method intended to capture the intricate relationship between stochastic elements and system dynamics in real-world scenarios.\nDiagram: Stochastic System Block Diagram - (click to expand) In the context provided, the output Y(t) is expressed as the product of x(t), representing the response of our system dynamics to the input u(t), and v(t), which constitutes a colored noise stemming from e(t), characterized as white noise. This formulation underscores the interplay between the system\u0026rsquo;s response to the input and the influence of colored noise, derived from a white noise source, in generating the overall output.\n5.1. Simulating through System Identification Toolbox # A dataset with a known square response was used as \u0026ldquo;training data,\u0026rdquo; with trends and mean values removed to create estimations. Validation was then conducted using three separate datasets, evaluating the accuracy of estimations through AIC and BIC criteria. This process assessed how well the model derived from the \u0026ldquo;training data\u0026rdquo; performed across different datasets.\nAlthough this system is extremely non-linear, an estimation that had a high order for simplicity was avoided.\n5.2. ARX - Autoregressive Model with Exogenous Input # Diagram: ARX Block Diagram - (click to expand) This model clearly indicates that both the system and noise dynamics are not entirely independent, sharing common poles represented by A(z^-1). Despite being the simplest among the models, it features an unrealistic connection between the system and noise dynamics. This coupling can be lessened in cases where the signal-to-noise ratio is sufficiently high, offering a potential way to mitigate this issue. Validation with a different experiment but also white noise and multiple powers for a square response:\nValidation: ARX Model for Data 1 - (click to expand) Additional statistics criterions for this dataset:\nDATA1 POWER3 BIC AIC Best Fit ARX122 1323.5 1305.6 29.64 ARX131 1332.5 1307.5 31.54 ARX231 1191.7 1163.1 52.9 ARX113 1314.0 1303.3 23.1 ARX331 1196.9 1164.7 53.5 ARX341 1190.3 1151.0 49.71 ARX322 1192.3 1163.7 53.66 ARX451 1197.2 1147.0 53.46 ARX551 1187.9 1134.2 50.89 ARX351 1194.3 1147.7 54.52 Validation: ARX Model for Data 2 - (click to expand) Additional statistics criterions for this dataset:\nDATA2 POWER5 BIC AIC Best Fit ARX122 1022.2 1005.7 22.35 ARX131 1030.2 1007.1 25.93 ARX231 906.5 880.1 50.81 ARX113 1013.1 1003.2 19.44 ARX331 911.7 882.0 51.14 ARX341 904.8 868.6 51.65 ARX322 907.3 880.9 50.61 ARX451 906.8 861.0 56.94 ARX551 894.9 845.4 59.93 ARX351 907.1 864.2 55.59 Validation: ARX Model for Data 3 - (click to expand) Additional statistics criterions for this dataset:\nDATA3 POWER2 BIC AIC Best Fit ARX122 1067.9 1051.4 16.46 ARX131 1076.5 1053.5 18.56 ARX231 951.7 925.3 40.89 ARX113 1059.1 1049.2 14.53 ARX331 950.6 921.0 41.41 ARX341 942.8 907.0 42.02 ARX322 945.5 919.1 41.39 ARX451 939.1 893.0 41.39 ARX551 932.5 883.0 51.56 ARX351 937.3 894.4 44.02 ARX551, ARX451 and ARX351 always had the best fit, lowest AIC and BIC. Thus, the best approximations. The higher the order of the poles/zeros the closer it gets to the real approximation. Hence, returning better results.\n5.3. ARMAX - Autoregressive Model with Exogenous Input # Diagram: ARMAX Block Diagram - (click to expand) Unlike the ARX model, this particular model accounts for the presence of a moving average component within the noise dynamics, in addition to its connection with the system\u0026rsquo;s dynamics. This model proves valuable in scenarios where dominant disturbances enter the system early in the process. Its consideration of both the system\u0026rsquo;s dynamics and the moving average component in noise dynamics allows for a more accurate representation, especially when early disturbances significantly impact the overall system behaviour. Using the same technology as before\u0026hellip;\nValidation: ARMAX Model for Data 1 - (click to expand) Additional statistics criterions for this dataset:\nDATA1 POWER3 NS BIC AIC Best Fit ARMX6260 934.69 868.7 46.55 ARMX5250 921.9 865.8 5.996 ARMX7321 919.7 857.1 48.30 ARMX5111 950.2 910.6 18.43 ARMX3251 934.8 885.3 45.46 ARMX3111 936.8 910.4 48.21 ARMX3241 928.4 885.5 45.34 ARMX2120 995.5 972.4 37.54 ARMX5321 906.2 856.7 48.20 ARMX4331 905.2 859.0 48.94 Validation: ARMAX Model for Data 2 - (click to expand) Additional statistics criterions for this dataset:\nDATA2 POWER5 BIC AIC Best Fit ARMX6260 978.3 912.4 62.43 ARMX5250 1068.9 1012.9 11.96 ARMX7321 894.4 831.7 64.99 ARMX5111 1063.7 1024.1 22.18 ARMX3251 999.9 950.4 55.18 ARMX3111 1051.3 1024.9 58.45 ARMX3241 1000.7 957.9 55.01 ARMX2120 1030.7 1007.6 49.49 ARMX5321 888.5 839.0 60.27 ARMX4331 908.4 862.2 59.24 Validation: ARMAX Model for Data 3 - (click to expand) Additional statistics criterions for this dataset:\nDATA3 POWER2 BIC AIC Best Fit ARMX6260 977.4 911.5 60.59 ARMX5250 966.8 910.7 36.92 ARMX7321 915.6 852.9 55.84 ARMX5111 979.0 939.4 43.46 ARMX3251 962.4 913.0 55.03 ARMX3111 951.5 925.1 56.08 ARMX3241 954.4 911.5 54.23 ARMX2120 954.1 931.0 57.90 ARMX5321 914.8 865.4 51.24 ARMX4331 930.8 884.6 50.04 Compared to the ARX model, there is a slight increase in the best fit which corresponds to a smaller value in the AIC and BIC criterions. The step response of 3 best approximations in data 2 are given by:\n5.4. BJ - Box-Jenkins Model # Diagram: Box-Jenkins Block Diagram - (click to expand) The Box-Jenkins model is useful when you have disturbances that enter later in the process, e.g. measurement noise on the output.\nValidation: Box-Jenkins Model for Data 1 - (click to expand) Validation: Box-Jenkins Model for Data 2 - (click to expand) Validation: Box-Jenkins Model for Data 3 - (click to expand) Best result was from data 2.\nBest Fit - Data 2: Statistical Results - (click to expand) DATA2 POWER2 BIC AIC Best Fit BJ22221 870.4 831.7 73.04 BJ23331 894.3 839.6 51.28 BJ23531 903.2 835.5 54.69 BJ24331 897.0 835.8 50.87 BJ24531 948.3 877.4 51.06 BJ24731 919.9 836.1 48.28 BJ33531 868.9 798.0 64.92 BJ33731 876.8 793.0 73.34 BJ35731 882.2 792.0 71.65 BJ45731 893.3 796.6 72.59 Step response:\n5.5. Output-Error Model # Diagram: Output-Error Block Diagram - (click to expand) System and noise dynamics are modelled separately, using zero parameters to model the disturbance. This disturbance can often be assumed to be white noise.\nValidation: Output-Error Model for Data 1 - (click to expand) Validation: Output-Error Model for Data 2 - (click to expand) Validation: Output-Error Model for Data 3 - (click to expand) Best result was from data 3.\nBest Fit - Data 3: Statistical Results - (click to expand) DATA3 POWER2 BIC AIC Best Fit OE592 1074.6 998.7 75.11 OE472 1063.6 1004.2 75.43 OE352 1077.0 1034.1 71.16 OE252 1032.6 993.1 77.03 OE341 1064.6 1028.3 72.29 OE262 1038.6 992.5 65.12 OE342 1110.6 1074.3 60.56 OE232 1652.6 1636.1 56.15 OE231 1199.1 1172.7 57.46 OE121 1257.6 1241.1 60.60 Step response:\n5.6. Stochastic Process Analysis # The simulation process involved a trial and error method, initially assuming the input of all stochastic data to be white noise, although this assumption isn\u0026rsquo;t entirely accurate in reality. Iterations were conducted until the expected results were achieved, with validation performed across three distinct data types. From this analysis, several conclusions emerged.\nBoth Box-Jenkins and Output-Error models exhibited the best fitting values, which was expected due to their higher complexity, allowing for greater precision. However, it\u0026rsquo;s noticeable that increased model complexity, indicated by higher numbers of poles and zeros, led to better fits but also increased overall complexity, which isn\u0026rsquo;t always advantageous.\nThe simpler ARX and ARMAX models showed fitting slightly above 60%, whereas the more complex models reached around 75%. Additionally, models with lower AIC and BIC values corresponded to fewer parameters needed for estimation, quicker convergence, and more accuracy due to lower residuals. Yet, these criteria are based on assumptions that often don\u0026rsquo;t hold in practical scenarios.\nThis notion was reinforced by examining the step response plots of the best fitting models. The ARX and ARMAX models exhibited overshoot and steady-state error, as expected due to their simplicity. On the other hand, the OE/BJ models showed some overshoot but minimal steady-state error, indicating their greater complexity allows for a more refined representation with improved performance characteristics. The stable continuous transfer function given by the best fitting model goes as follows:\n\\[G_{\\text{Output-Error}}(s) = \\frac{0.6447s^4 \u0026#43; 75.98s^3 \u0026#43; 4005s^2 \u0026#43; 8.577 \\times 10^4 s \u0026#43; 8.386 \\times 10^4}{s^5 \u0026#43; 21.95s^4 \u0026#43; 1039s^3 \u0026#43; 7891s^2 \u0026#43; 6.995 \\times 10^4 s \u0026#43; 7.87 \\times 10^4}\\] 6 Outcomes # For a final comparison: here is the fitting 3 transfer functions that were obtained for deterministic and stochastic systems.\n\\[G_{\\text{output-error}}(s) = \\frac{0.6447s^4 \u0026#43; 75.98s^3 \u0026#43; 4005s^2 \u0026#43; 8.577 \\times 10^4 s \u0026#43; 8.386 \\times 10^4}{s^5 \u0026#43; 21.95s^4 \u0026#43; 1039s^3 \u0026#43; 7891s^2 \u0026#43; 6.995 \\times 10^4 s \u0026#43; 7.87 \\times 10^4}\\] \\[G_{\\text{deterministicLevy}}(s) = \\frac{3085s^2 \u0026#43; 3.098 \\times 10^5 s \u0026#43; 5.176 \\times 10^6}{s^3 \u0026#43; 123s^2 \u0026#43; 2864s \u0026#43;6.932 \\times 10^4}\\] \\[G_{\\text{stochasticLevy}}(s) = \\frac{-24.59s \u0026#43; 295}{s^2 \u0026#43; 5.944s \u0026#43;210.8}\\] \\[G_{\\text{stochasticStep}}(s) = \\frac{0.1554s \u0026#43; 45.82}{s^2 \u0026#43; 6.077s \u0026#43;442.7}\\] \\[G_{\\text{deterministicStep}}(s) = \\frac{309.8 s^3 \u0026#43;7682s^2 \u0026#43; 4.842 \\times 10^5 s \u0026#43;1.745 \\times 10^6}{18.84s^4 \u0026#43; 801.3 s^3 \u0026#43; 991.6 s^2 \u0026#43; 1.868 \\times 10^4 s \u0026#43;1.745 \\times 10^6}\\] As for the step response for the best fitting of the estimated models for each dataset:\nModels Validation: Step response for Data1 - (click to expand) Models Validation: Step response for Data2 - (click to expand) Models Validation: Step response for Data3 - (click to expand) From the depicted graphs, it\u0026rsquo;s evident that the superior models tend to achieve a best fit of approximately 70%. This lower performance in stochastic models might be attributed to the relatively reduced complexity of the attained transfer functions.\n7 Recap # The methods applied successfully identified the Rasteirinho system, albeit encountering some challenges. For example, ncreasing model complexity often improves results but sacrifices simplicity.\nVarious factors affected data quality, including system noise, uncertainty, and nonlinearities. Errors in data were attributed to lab lighting, low camera frame rates, and Rasteirinho\u0026rsquo;s compliance, causing significant vibrations in the camera mounted with duct tape.\nDeterministic identification, especially in the time domain, yielded promising outcomes. However, the stochastic identification using continuous models, both in time and frequency domains, didn\u0026rsquo;t meet expectations during validation with diverse data. This discrepancy could be attributed to potential errors in function implementation. The anticipation that stochastic identification via correlation would be more accurate due to its noise-filtering nature wasn\u0026rsquo;t entirely realized, as the differences between impulse responses obtained from deconvolution and correlation were relatively minor.\nOn the other hand, stochastic identification using discrete models of varying complexity showed promising results.\n8 Future Work\u0026hellip; # example\nRefinement of Stochastic Identification: Addressing errors in function implementation and exploring alternative stochastic identification methods could enhance accuracy. Noise Mitigation Techniques: Exploring advanced filtering or noise reduction approaches could improve signal quality in stochastic identification. Enhanced Data Collection: Improving data acquisition methods, such as stabilizing the camera or optimizing lighting conditions, can minimize data errors. Model Optimization: Continuing to balance model complexity and accuracy to find the optimal trade-off between a model\u0026rsquo;s intricacy and its performance. "},{"id":4,"href":"/docs/2code/","title":"Coding Portfolio","section":"Docs","content":" Workflow # Hey hey! Welcome to my coding project hub — a spot where you\u0026rsquo;ll find the fruits of my academic hustle. These projects? They\u0026rsquo;re like little milestones in my coding journey, from cracking algorithmic puzzles to diving deep into data analysis.\nBut hey, it\u0026rsquo;s not just textbooks and lectures (though I have a soft spot for the math and logic behind it) — I\u0026rsquo;ve teamed up with some awesome friends from all corners of the globe. My playground has been a mix of deciphering data, diving into the realms of AI, tinkering with robotics, and optimizing systems using clever computational techniques.\nI\u0026rsquo;m a firm believer in code\u0026rsquo;s magic to bring ideas to life, and I\u0026rsquo;m stoked to give you a peek into my coding adventures. Take a tour through these projects; hope they spark as much joy in you as they did in me!\nShoot me a message if you are interested in more. 🤓✨\n"},{"id":5,"href":"/docs/2code/1drone/_index2/","title":"Drone Dynamics","section":"UAV Red Bull Air Racing","content":" Phase 1. Drone System Dynamics # tip\nIf you wish to skip the theoretical and implementation details, please click here to jump to the summarized findings Ch. 4 - The Moving UAV. I have cool images! ✌️ 1 System Dynamics Modeling # Breaking down the drone into subsystems helps manage its complexity. The quadrotor has three main parts:\nActuation System: This handles the rotors\u0026rsquo; model, the forces they generate ( \\(F_p\\) ), and the moments they create ( \\(M_p\\) ). Each rotor gets an input voltage ( \\(V_{m_i}\\) ) and produces an angular velocity ( \\(\\Omega_i\\) ).\nMovement System: This part deals with forces (not just from rotors but also external factors like wind) and moments that drive the drone\u0026rsquo;s movement. It uses physics laws, dynamics, and kinematics to determine the drone\u0026rsquo;s position and velocity.\nInstrumentation System: This part involves the sensor model. In this project phase, the sensors are simplified as ideal sensors, meaning they have a gain of one.\nBreaking it down this way helps in focusing on and understanding each aspect separately, making the overall understanding and development of the drone more manageable.\n1.1. Actuation Subsystem # The actuation subsystem involves individual DC motors powering propellers to generate lift forces in the drone\u0026rsquo;s four independently controlled motors (i=1,2,3,4). The values of I and \\(\\Omega\\) change over time based on the applied motor voltage, Vm, while constants like Lm, Rm, Ke, Kt, and Jm characterize the motor. This results in a second-order system for each drone motor, expressed as:\n\\[\\dot{\\tilde{x}} = A\\tilde{x} \u0026#43; B\\tilde{u} = \\begin{bmatrix} \\dot{\\tilde{I}}_i \\\\ \\dot{\\tilde{\\Omega}} \\end{bmatrix} = \\begin{bmatrix} a_{11} \u0026amp; a_{12} \\\\ a_{21} \u0026amp; a_{22} \\end{bmatrix} \\begin{bmatrix} \\tilde{I}_i \\\\ \\Omega \\end{bmatrix} \u0026#43; \\begin{bmatrix} b_2 \\\\ 0 \\end{bmatrix} \\tilde{V}_m\\] \\[\\tilde{y} = C\\tilde{x} \u0026#43; D\\tilde{u} = \\Omega, \\quad i = [0 \\, 1]\\] The parameters in matrices A and B are determined by the motor specifications and the chosen flight conditions for linearization.\n1.1.1. Model and Linearization # The actuation subsystem dynamics are defined by the following nonlinear equations:\n\\[\\dot{I}_i = \\frac{1}{L_m} (V_{mi} - R_{m}I_{i} - K_{e}\\Omega_{i})\\] \\[\\dot{\\Omega}_i = \\frac{1}{J_m} (K_t I_i - Q_i - B_m\\Omega_{i})\\] \\[\\text{Where: } Q_i = K_Q \\Omega_i^2\\] To linearize this model, a nominal point around which small deviations are considered for the variables I, Vm and Ω is selected, representing the hovering condition:\n\\[I_i = I_o \u0026#43; \\tilde{I}_i\\] \\[V_{mi} = V_{mo} \u0026#43; \\tilde{V}_{mi}\\] \\[\\Omega_i = \\Omega_{i_o} \u0026#43; \\tilde{\\Omega}_{i}\\] Using these relationships, the linearized dynamics are obtained as:\n\\[\\dot{\\tilde{I}}_i = \\frac{1}{L_m} (\\tilde{V}_{m_i} - R_m \\tilde{I}_i - K_e \\tilde{\\Omega}_i)\\] \\[\\dot{\\tilde{\\Omega}}_i = \\frac{1}{J_m} (K_t \\tilde{I}_{i} - 2 K_Q \\Omega_{i_o} \\tilde{\\Omega}_i - B_m \\tilde{\\Omega}_i)\\] The linearized state space model for each actuation subsystem, where the output is the motor angular speed, is given by:\n\\[\\begin{bmatrix} \\dot{I}_i \\\\ \\dot{\\Omega}_i \\end{bmatrix} = \\begin{bmatrix} -\\frac{R_m}{L_m} \u0026amp; -\\frac{K_e}{L_m} \\\\ \\frac{K_t}{J_m} \u0026amp; -\\frac{K_Q \\Omega_{i_o}\u0026#43;B_m}{J_m} \\end{bmatrix} \\begin{bmatrix} \\tilde{I_i} \\\\ \\tilde{\\Omega}_i \\end{bmatrix} \u0026#43; \\begin{bmatrix} \\frac{1}{L_m} \\\\ 0 \\\\ \\end{bmatrix} \\tilde{V}_{mi}\\] The state space variables are, therefore, \\( \\tilde{I}_i \\) and \\( \\tilde{\\Omega}_{i} \\) . The only input provided to each motor is the applied voltage \\( \\tilde{V}_{m_{i}} \\) . The state space model for the complete actuation subsystem can be obtained by combining the state space models for each motor into a single state space model:\n\\[ \\begin{bmatrix} \\dot{\\tilde{I}}_1 \\\\ \\dot{\\tilde{\\Omega}}_1 \\\\ \\dot{\\tilde{I}}_2 \\\\ \\dot{\\tilde{\\Omega}}_2 \\\\ \\dot{\\tilde{I}}_3 \\\\ \\dot{\\tilde{\\Omega}}_3 \\\\ \\dot{\\tilde{I}}_4 \\\\ \\dot{\\tilde{\\Omega}}_4 \\\\ \\end{bmatrix} = \\begin{bmatrix} A_1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; A_2 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; A_3 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; A_4 \\\\ \\end{bmatrix} \\begin{bmatrix} \\tilde{I}_1 \\\\ \\tilde{\\Omega}_1 \\\\ \\tilde{I}_2 \\\\ \\tilde{\\Omega}_2 \\\\ \\tilde{I}_3 \\\\ \\tilde{\\Omega}_3 \\\\ \\tilde{I}_4 \\\\ \\tilde{\\Omega}_4 \\\\ \\end{bmatrix} \u0026#43; \\begin{bmatrix} B_1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; B_2 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; B_3 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; B_4 \\\\ \\end{bmatrix} \\begin{bmatrix} \\dot{\\tilde{V}}_{m1} \\\\ 0 \\\\ \\dot{\\tilde{V}}_{m2} \\\\ 0 \\\\ \\dot{\\tilde{V}}_{m3} \\\\ 0 \\\\ \\dot{\\tilde{V}}_{m4} \\\\ 0 \\\\ \\end{bmatrix} \\\\\\] \\[\\begin{bmatrix} \\tilde{\\Omega}_1 \\\\ \\tilde{\\Omega}_2 \\\\ \\tilde{\\Omega}_3 \\\\ \\tilde{\\Omega}_4 \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\\\ \\end{bmatrix} \\begin{bmatrix} \\tilde{I}_1 \\\\ \\tilde{\\Omega}_1 \\\\ \\tilde{I}_2 \\\\ \\tilde{\\Omega}_2 \\\\ \\tilde{I}_3 \\\\ \\tilde{\\Omega}_3 \\\\ \\tilde{I}_4 \\\\ \\tilde{\\Omega}_4 \\\\ \\end{bmatrix}\\] Each matrix Ai and Bi represent a 2 × 2 matrix. As all four motors share identical parameters, the matrices Ai and Bi exhibit identical properties. However, due to the independent dynamics of each motor, the subsystem analysis simplifies. Subsequent sections will confirm the motors\u0026rsquo; rapid response times, allowing an approximation using a static gain, as demonstrated:\n\\[\\delta_i = K_{\\Omega} \\Omega_i\\] With this outcome in consideration, the angular velocities \\(\\Omega_i\\) can be presented solely as a function of the voltage constant \\(K_{\\Omega}_i\\) and the actuations \\(\\delta_i\\) \\[\\begin{bmatrix} \\Omega_1 \\\\ \\Omega_2 \\\\ \\Omega_3 \\\\ \\Omega_4 \\\\ \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; K_{\\Omega} \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; K_{\\Omega} \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; K_{\\Omega} \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\\\ \\end{bmatrix} \\begin{bmatrix} \\delta_1 \\\\ \\delta_2 \\\\ \\delta_3 \\\\ \\delta_4 \\\\ \\end{bmatrix} \\\\\\] This process essentially proportionally adjusts the input variables​ \\(\\delta_i\\) . Labeling the diagonal matrix as \\(T_M\\) , this relationship can be expressed by considering the linear deviations around the nominal operating point.\n\\[\\tilde{\\Omega} = T_M \\tilde{\\delta}\\] 1.1.2. Transfer Function Model # With the state space model acquired for the actuation subsystem, it is possible to derive the transfer function.\n\\[G(s) = C(sI - A)^{-1}B \u0026#43; D\\] The relationship between the output (angular speed ​ \\(\\tilde{\\Omega}_i\\) ) and the input (applied voltage ​ \\(\\tilde{V}_{mi}\\) ) is expressed as the transfer function:\n\\[G(s) = \\frac{\\tilde{\\Omega}_i(s)}{\\tilde{V}_{mi}(s)} = \\begin{bmatrix} 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} s \u0026#43; \\frac{R_m}{L_m} \u0026amp; \\frac{K_e}{L_m} \\\\ -\\frac{K_t}{J_m} \u0026amp; s \u0026#43; \\frac{2K_Q \\Omega_{i_o} \u0026#43; B_m}{J_m} \\end{bmatrix}^{-1} \\begin{bmatrix} 1 \\\\ \\frac{1}{L_m} \\\\ 0 \\\\ \\end{bmatrix}\\] When the aforementioned parameters are replaced with typical values for a DC motor, the resulting transfer function model can be represented.\n\\[G(s) = \\frac{4.901 \\times 10^6}{s^2 \u0026#43; 576.3s \u0026#43; 1.687 \\times 10^5}\\] 1.1.3. Stability # To assess stability, the system poles need computation, achievable through two approaches. First, by determining the roots of the denominator the defined transfer function G(s), or second, by computing the eigenvalues of matrix A as depicted as follows:\n\\[\\text{det}(sI - A) = s^2 \u0026#43; 576.3s \u0026#43; 1.687 \\times 10^5 = 0 \\quad \\Leftrightarrow \\quad s = -288.13 \\pm 292.67i \\quad (21)\\] The poles, located in the left half-plane and forming complex conjugates, signify system stability. Expect an overshoot with a step input. The unit step response demonstrates a small overshoot ( \\(M_p\\) = 4.54%) and rapid system response ( \\(T_s\\) = 0.15s). Consequently, approximating the actuation subsystem as a static gain seems plausible. The root locus plot confirms system stability across various proportional controllers.\n1.1.4. Controllability # The controllability of a state space model implies the capability to transition any initial state to a final state through a finite control action within a finite duration. This assurance exists when the rank of matrix C matches the dimension of the previously defined state vector, represented as n. For the actuation subsystem, n = 2, and matrix \\(\\mathcal{C}\\) is thus expressed as follows. Upon observation, it\u0026rsquo;s evident that C holds a rank of 2, affirming the system\u0026rsquo;s controllability.\n\\[\\mathcal{C} = [B \\quad AB] = \\begin{bmatrix} \\frac{1}{Lm} \u0026amp; -\\frac{Rm}{L^2m} \\\\ 0 \u0026amp; \\frac{Kt}{Jm Lm} \\\\ \\end{bmatrix}\\] 1.1.5. Observability # Observability of a state space model implies the ability to deduce any initial state from the system output within a given time interval. This certainty prevails when the rank of the observability matrix \\(\\mathcal{O}\\) matches the dimension of the state vector.\nGiven the state vector\u0026rsquo;s dimension as n = 2, the observability matrix \\(\\mathcal{O}\\) is defined according to equation 23. Upon inspection, it\u0026rsquo;s evident that the resulting matrix has a rank of 2, affirming the system\u0026rsquo;s observability.\n\\[\\mathcal{O} = \\begin{bmatrix} C \\\\ CA \\end{bmatrix} = \\begin{bmatrix} 0 \u0026amp; 1 \\\\ \\frac{K_t}{J_m} \u0026amp; -\\frac{B_m \u0026#43; 2K_q \\Omega_o}{J_m} \\\\ \\end{bmatrix} \\] 1.2. Movement Subsytem # To understand the movement subsystem, it\u0026rsquo;s crucial to pinpoint the forces and moments within the system. The forces and moments are generated by the combined angular speeds of the rotors, as shown below:\n\\[T_i = K_T \\Omega_i^2 \\] \\[Q_i = K_Q \\Omega_i^2 \\] \\[F_p = \\begin{bmatrix} 0 \\\\ 0 \\\\ - \\sum_{i=1}^{4} T_i \\\\ \\end{bmatrix}\\] \\[M_p = \\begin{bmatrix} b \\cdot \\cos(\\pi/4) \\cdot (T_1 - T_2 - T_3 \u0026#43; T_4) \\\\ b \\cdot \\cos(\\pi/4) \\cdot (T_1 \u0026#43; T_2 - T_3 - T_4) \\\\ -Q_1 \u0026#43; Q_2 - Q_3 \u0026#43; Q_4 \\\\ \\end{bmatrix}\\] The equations for the dynamics and kinematics are the following:\n\\[m\\dot{v} = -\\omega \\times mv \u0026#43; F_p \u0026#43; F_a \u0026#43; F_g \\\\ J\\dot{\\omega} = -\\omega \\times J\\omega \u0026#43; M_p \\\\ \\dot{p} = Rv\\\\ \\dot{\\Phi} = S\\omega\\] Considering the four angular velocities from the motors as inputs \\(\\tilde{u} = \\tilde{\\Omega} = [\\tilde{\\Omega}_1, \\tilde{\\Omega}_2, \\tilde{\\Omega}_3, \\tilde{\\Omega}_4]\\) and the twelve variables denoting both the linear and angular positions and velocities as the state \\(X = [\\tilde{v}^T, \\tilde{\\omega}^T, \\tilde{p}^T, \\tilde{\\Phi}^T]^T\\) , the model is then represented:\n\\[\\begin{bmatrix} \\dot{\\tilde{v}} \\\\ \\dot{\\tilde{\\omega}} \\\\ \\dot{\\tilde{p}} \\\\ \\dot{\\tilde{\\Phi}} \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; A_V \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ I_3 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; I_3 \u0026amp; 0 \u0026amp; 0 \\\\ \\end{bmatrix} \\begin{bmatrix} \\tilde{v} \\\\ \\tilde{\\omega} \\\\ \\tilde{p} \\\\ \\tilde{\\Phi} \\\\ \\end{bmatrix} \u0026#43; \\begin{bmatrix} B_V \\\\ B_{\\omega} \\\\ 0 \\\\ 0 \\\\ \\end{bmatrix} \\tilde{\\Omega}\\] Where Av, Bv, Bω are given by:\n\\[A_V = \\begin{bmatrix} 0 \u0026amp; -g \u0026amp; 0 \\\\ g \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \\\\ \\end{bmatrix}, \\quad B_V = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ g \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ -b_z \u0026amp; -b_z \u0026amp; -b_z \u0026amp; -b_z \\\\ \\end{bmatrix}, \\quad B_{\\omega} = \\begin{bmatrix} 0 \u0026amp; -b_p \u0026amp; 0 \u0026amp; b_p \\\\ b_q \u0026amp; 0 \u0026amp; -b_q \u0026amp; 0 \\\\ -b_q \u0026amp; b_p \u0026amp; -b_p \u0026amp; b_p \\\\ \\end{bmatrix}\\] The coefficients for the matrix \\(B_V\\) and \\(B_{\\omega}\\) depend on the parameters of the quad rotor and flight conditions. But combining previous equations, it is obtained:\n\\[\\begin{bmatrix} \\dot{\\tilde{v}}_x \\\\ \\dot{\\tilde{v}}_y \\\\ \\dot{\\tilde{v}}_z \\\\ \\dot{\\tilde{\\omega}}_x \\\\ \\dot{\\tilde{\\omega}}_y \\\\ \\dot{\\tilde{\\omega}}_z \\\\ \\dot{\\tilde{p}}_x \\\\ \\dot{\\tilde{p}}_y \\\\ \\dot{\\tilde{p}}_z \\\\ \\dot{\\tilde{\\phi}} \\\\ \\dot{\\tilde{\\theta}} \\\\ \\dot{\\tilde{\\psi}} \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; -g \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; g \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ \\end{bmatrix} \\begin{bmatrix} \\tilde{v}_x \\\\ \\tilde{v}_y \\\\ \\tilde{v}_z \\\\ \\tilde{\\omega}_x \\\\ \\tilde{\\omega}_y \\\\ \\tilde{\\omega}_z \\\\ \\tilde{p}_x \\\\ \\tilde{p}_y \\\\ \\tilde{p}_z \\\\ \\tilde{\\phi} \\\\ \\tilde{\\theta} \\\\ \\tilde{\\psi} \\\\ \\end{bmatrix} \u0026#43; \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ g \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ -bz \u0026amp; -bz \u0026amp; -bz \u0026amp; -bz \\\\ 0 \u0026amp; -bp \u0026amp; 0 \u0026amp; bp \\\\ bq \u0026amp; 0 \u0026amp; -bq \u0026amp; 0 \\\\ -bq \u0026amp; bp \u0026amp; -bp \u0026amp; bp \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ \\end{bmatrix} \\begin{bmatrix} \\tilde{\\Omega}_1 \\\\ \\tilde{\\Omega}_2 \\\\ \\tilde{\\Omega}_3 \\\\ \\tilde{\\Omega}_4 \\\\ \\end{bmatrix}\\] It is revelant to note that another possibility would be to divide the quad rotor dynamics into six subsystems, instead of a big matrix. Following up the state equation, the output would translate to:\n\\[y = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; I_3 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; I_3 \\\\ \\end{bmatrix} \\begin{bmatrix} \\tilde{v} \\\\ \\tilde{\\omega} \\\\ \\tilde{p} \\\\ \\tilde{\\Phi} \\\\ \\end{bmatrix} = \\begin{bmatrix} \\tilde{p} \\\\ \\tilde{\\Phi} \\\\ \\end{bmatrix}\\] Which would expand to:\n\\[\\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\\\ \\end{bmatrix} \\begin{bmatrix} \\tilde{v}_x \\\\ \\tilde{v}_y \\\\ \\tilde{v}_z \\\\ \\tilde{\\omega}_x \\\\ \\tilde{\\omega}_y \\\\ \\tilde{\\omega}_z \\\\ \\tilde{p}_x \\\\ \\tilde{p}_y \\\\ \\tilde{p}_z \\\\ \\tilde{\\phi} \\\\ \\tilde{\\theta} \\\\ \\tilde{\\psi} \\\\ \\end{bmatrix} =\\begin{bmatrix} \\tilde{p}_x \\\\ \\tilde{p}_y \\\\ \\tilde{p}_z \\\\ \\tilde{\\phi} \\\\ \\tilde{\\theta} \\\\ \\tilde{\\psi} \\\\ \\end{bmatrix}\\] 1.2.1. Simplification and Analysis # The analysis of the movement subsystem can be simplified by approximating the motor dynamics by a static gain. This means it is possible to change the matrix B such that the actuation variables \\(\\delta_i\\) becomes the inputs instead of the motor angular speeds \\(\\Omega_i\\) . This transformation is expressed:\n\\[\\dot{X} = AX \u0026#43; B\\tilde{\\Omega} = AX \u0026#43; BT_M \\tilde{\\delta}\\] The matrix \\(T_M\\) represents the voltage constant ( \\(K\\Omega\\) ) as depicted previously. This adjustment does not alter the subsequent analysis; it merely scales the inputs. However, this transformation proves valuable for future use when implementing a controller.\n1.2.2. Stability # The stability assessment involves determining the system\u0026rsquo;s poles, achieved by computing the eigenvalues of matrix A derived previously, encompassing the entire movement subsystem. Upon computation in Matlab, it reveals that all 12 eigenvalues, corresponding to the poles, are zero, indicating system instability.\n1.2.3. Controllability # In order to assess the controllability of a state space model, it is necessary to compute its controllability matrix. When considering the entire movement subsystem, the controllability matrix \\(\\mathcal{C}\\) is defined:\n\\[\\mathcal{C} = \\begin{bmatrix} B \u0026amp; AB \u0026amp; A^2B \u0026amp; A^3B \u0026amp; A^4B \u0026amp; A^5B \u0026amp; A^6B \u0026amp; A^7B \u0026amp; A^8B \u0026amp; A^9B \u0026amp; A^{10}B \u0026amp; A^{11}B \\end{bmatrix}\\] Upon conducting a rank computation of this matrix in Matlab, it is established that it holds a rank of 12. Consequently, indicating the controllability of the system.\n1.2.3. Observability # When assessing observability, the rank of the observability matrix \\(\\mathcal{O}\\) is computed. Considering the entirety of the movement subsystem, the matrix \\(\\mathcal{O}\\) is represented as:\n\\[\\mathcal{O} = \\begin{bmatrix} C \\\\ CA \\\\ \\vdots \\\\ CA^{11} \\\\ \\end{bmatrix}\\] This matrix has also rank 12 and, therefore, the system is observable.\n2 State Feedback Control # Previously, it was derived a model for the UAV, enabling to create linear and nonlinear simulators in Simulink. The next step is to implement a state feedback control system that allows the UAV to both follow and maintain a specified reference trajectory.\nTo effectively control the UAV, I aim to manage its lateral movement ( \\(P_N\\) and \\(P_E\\) ), vertical movement ( \\(P_D\\) ), and yaw angle ( \\(\\psi\\) ). Thus, it is needed an adjustment of the matrix C to exclusively capture these controlled states in the output. Consequently, the updated matrix C will be tailored to reflect only these specific states, ensuring the control system targets the intended dynamics.\n\\[C =\\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\\\ \\end{bmatrix}\\] Upon computing the resulting observability matrix, it was verified that its rank remained at 12, indicating the system\u0026rsquo;s sustained observability. Given the interest in tracking a specific reference while ensuring resilience against disturbances, a servo feedback system emerges as a promising choice. To achieve this, it necessitates employing the entire state vector in feedback, thereby requiring the ability to measure all 12 variables within the state vector. This measurement can be achieved through physical sensors or, alternatively, using observer techniques. For the current phase, it is assumed that reliable measurements of all system states are available.\nA servo feedback control system exhibits the structure illustrated onwards. To actualize this closed-loop configuration, the values of K and \\(K_i\\) need computation. This process commences by deriving the augmented open-loop system.\n\\[\\begin{bmatrix} \\dot{x}(t) \\\\ \\dot{x}_i(t) \\\\ \\end{bmatrix} = \\begin{bmatrix} A \u0026amp; 0 \\\\ -C \u0026amp; 0 \\\\ \\end{bmatrix} \\begin{bmatrix} x(t) \\\\ x_i(t) \\\\ \\end{bmatrix} \u0026#43; \\begin{bmatrix} B \\\\ 0 \\\\ \\end{bmatrix} u(t) \u0026#43; \\begin{bmatrix} 0 \\\\ 1 \\\\ \\end{bmatrix} r\\] \\[y(t) = \\begin{bmatrix} C \u0026amp; 0 \\\\ \\end{bmatrix} \\begin{bmatrix} x(t) \\\\ x_i(t) \\\\ \\end{bmatrix} \\bar{A} = \\begin{bmatrix} A \u0026amp; 0 \\\\ -C \u0026amp; 0 \\\\ \\end{bmatrix} , \\bar{B} = \\begin{bmatrix} B \\\\ 0 \\\\ \\end{bmatrix} , \\bar{C} = [C 0] \\] Based on the previously obtained model, \\(\\bar{A}\\) is a 16x16 matrix, \\(\\bar{B}\\) is a 16x4 matrix and \\(\\bar{C}\\) is a 4x16 matrix. The next step involves determining the gains K and \\(k_i\\) to design a controller ensuring the asymptotic stability of the system.\n\\[u(t) = - \\begin{bmatrix} K \u0026amp; k_i \\\\ \\end{bmatrix} \\begin{bmatrix} x(t) \\\\ x_i(t) \\\\ \\end{bmatrix} \\begin{bmatrix} \\dot{x}(t) \\\\ \\dot{x}_i(t) \\\\ \\end{bmatrix} =\\begin{bmatrix} A - BK \u0026amp; Bk_i \\\\ -C \u0026amp; 0 \\\\ \\end{bmatrix} \\begin{bmatrix} x(t) \\\\ x_i(t) \\\\ \\end{bmatrix} \u0026#43; \\begin{bmatrix} 0 \\\\ 1 \\\\ \\end{bmatrix} r\\] To determine the entries of K and \\(K_i\\) , selecting the desired new pole locations was conducted through a trial-and-error approach. The aim was to achieve a rapid response while minimizing oscillations and conserving actuator energy. After identifying the new pole locations, the computation of K and \\(K_i\\) was performed using the MATLAB function \u0026lsquo;place\u0026rsquo;, which generates a 4x16 matrix \\(\\bar{K}\\) enmpassing all the entries, from which a 4x12 matrix \\(\\bar{K}\\) and a 4x4 matrix \\(\\bar{K}_i\\) were subsequently derived.\n\\[\\bar{K} = [K | K_i]\\] The upcoming section will involve testing the behaviour of both the linear and nonlinear models when employing the acquired controller.\n3 Simulation Results # To assess system performance, two Simulink models were developed. The linear model represents the state-space model derived from a linearization that assumes a hovering condition where the drone\u0026rsquo;s weight is offset by the four propulsion forces. On the other hand, the nonlinear model, implements dynamic and kinematic equations alltogether.\nFollowing an iterative process, desired poles were obtained through trial and error. These poles were crucial for computing the K and \\(K_i\\) matrices, enabling the construction of a controller for both models. This controller transformed them into servo systems with state feedback control. This section focuses on analyzing the performance of the servo feedback control in both simulators, along with evaluating the controller\u0026rsquo;s robustness against disturbances.\nMATLAB Simulink: Linear Model - (click to expand) MATLAB Simulink: Non-linear Model - (click to expand) 3.1. Linear Model Results # As previously stated, the linear model was linearized under the assumption of a hovering state. In the forthcoming simulations, the model will undergo two combined movements: a vertical and yaw movement, as well as a vertical and lateral movement. Each simulation will present data on position, yaw angle, and actuation for the UAV.\n3.1.1. Vertical and Yaw Movement # Combining the vertical climb with a yaw movement is equivalent to introducing a negative P \\(D_{ref}\\) alongside a specified final yaw angle value \\(\\Psi_{ref}\\) .\nVertical and Yaw Movement: Movement of Z and Yaw - (click to expand) It illustrates the drone adeptly tracking the given references without encountering any noticeable issues. However, the next figure indicates a minimal, yet inconsequential impact on the lateral position ( \\(P_N\\) and \\(P_E\\) ), noted as exceedingly small ( \\(10^{-4}\\) ).\nVertical and Yaw Movement: Movement of X and Y - (click to expand) As anticipated, the activation of all four motors caused the UAV to ascend vertically. Notably, motors 1 and 3, as well as motors 2 and 4, exhibited varying actuations, leading to a variation in the yaw angle.\nVertical and Yaw Movement: Actuations - (click to expand) 3.1.1. Vertical and Lateral Movement # For the second movement, a decision was made to combine forward and vertical positioning for the drone. The following figure illustrates the UAV\u0026rsquo;s stabilization on the specified reference, although initial oscillations in the vertical position are evident. As predicted, the system eventually reaches the final position dictated by the reference, affirming the seamless functionality of the servo controller.\nVertical and Lateral Movement: Movement of X and Z - (click to expand) Additionally, the next figure indicates a minimal PE movement ( \\(10^{-3}\\) ), aligning with expectations.\nVertical and Lateral Movement: Movement of Y - (click to expand) The resulting actuation of the four motors can also be seen:\nVertical and Lateral Movement: Actuations - (click to expand) 3.2. Non-linear Model Results # The nonlinear model exhibited increased instability during testing compared to the linear model. Some simulations encountered errors due to numerical overflow, caused by large pitch and roll angles attempting to track references.\nThis instability arose from significant pitch or roll angles inducing high speeds, leading to the loss of lift forces from the propellers and the drone\u0026rsquo;s descent. To focus on testing the servo controller, smaller references were used. Alternatively, employing ramp-like references or smaller steps instead of large singular steps may mitigate extreme responses in the nonlinear model.\n3.2.1. Vertical and Yaw Movement # In this simulation, the given reference involves ascending while simultaneously rotating on the yaw angle. The upcoming figure illustrates the successful tracking of the reference without any issues.\nVertical and Yaw Movement: Movement of Z and yaw - (click to expand) Similar to observations in the linear model, there was a minor impact on the lateral position, as depicted:\nLateral Movement: Movement of X and Y - (click to expand) As anticipated, all motors were activated to elevate the altitude, with motors 2 and 4 exhibiting substantial actuation to align the yaw angle with the provided reference.\nVertical and Lateral Movement: Motor Actuations - (click to expand) 3.2.2. Vertical and Lateral Movement # In this scenario, the reference entails ascending while moving forward. It is shown the drone adeptly tracking the lateral reference, albeit with slight oscillations. However, despite stabilizing approximately 7 seconds later, the oscillations around the final altitude exceed acceptable limits.\nVertical and Lateral Movement: Movement of Z and X - (click to expand) Lateral Movement: Movement of Y - (click to expand) Vertical and Lateral Movement: Motor Actuations - (click to expand) Upon reviewing the actuation of the four motors, it\u0026rsquo;s evident that the actuation exhibited chaotic behaviour. This suggests that the controller values require correction and fine-tuning to enable smoother tracking of the provided reference, eliminating substantial oscillations.\n3.3. Robustness to Disturbances # In this section, the focus lies on evaluating the system\u0026rsquo;s response to disturbances. Specifically, the goal is to test its resilience against input disturbances. These disturbances entail unexpected alterations in the control action for select motors. This situation compels the servo control system to adapt and uphold the designated reference position and yaw angle.\nYaw Compensation - Motors 2 and 4 Altitude Compensation - All Motors 4 The Moving UAV # This section aimed to derive and analyze a realistic quadcopter model. Initially, it involved establishing the dynamics of two subsystems: actuation (comprising four motors and propellers) and movement (relating actuation forces to drone dynamics and kinematics).\nOnce the complete model was obtained, it was initially simplified with a static gain assumption in the actuation subsystem. Subsequent analysis involved studying stability, observability, and controllability. The model, despite lacking stability, proved to be both observable and controllable, indicating feasibility for implementing a feedback control system.\nThe model\u0026rsquo;s characteristics indicated the need to control three coordinates and the yaw angle for movement regulation. Consequently, a servo feedback control system was developed and tested using both linear and nonlinear models. While the controller allowed the model to track given references, outcomes varied—excessive oscillations and slower response times were evident, notably in the nonlinear model.\nThe nonlinear simulation revealed challenges where large references risked crashing the simulator, emphasizing the criticality of refining reference signal design. Solutions might involve providing smaller sequential references or constraining maximum pitch and roll angles.\nThese observations underscored the need for controller fine-tuning to enhance reference tracking performance. Designing a controller capable of concurrently tracking all four references without excessive oscillations and with rapid response times emerged as a significant challenge.\nIn conclusion, the developed models exhibited accuracy and reliability in predicting real drone behaviour. Furthermore, they serve as a foundation for designing more effective controllers to optimize drone performance.\ntip\nAdvance to Controller Design Pt. 1 Here ✌️ "},{"id":6,"href":"/docs/2code/5od/_index2/","title":"Genetic Algorithm","section":"Evolutionary Computation","content":" Introduction # "},{"id":7,"href":"/docs/1design/2thermo/","title":"ThermoCup","section":"Design Portfolio","content":" ThermoCup # 1 What is the ThermoCup? # ThermoCup is a unique competition introduced initially at the Technical University of Lisbon during the MecanIST conferences in early 2016. Its primary objective is to challenge participants to conceive, design, and construct a steam boat. The competition covers a comprehensive spectrum of engineering aspects, incorporating various stages of the project lifecycle, from the initial conceptualization and design phase to the practical implementation, prototyping, and subsequent optimization processes.\n2 Transversal Disciplines # The challenges within ThermoCup likely encompass a range of engineering disciplines, including:\nMechanical Engineering: To design the physical structure of the steam boat, accounting for structural integrity and efficiency.\nThermal Engineering: Understanding and optimizing the heat transfer mechanisms involved in generating steam to power the boat.\nFluid Dynamics: Analyzing the flow of steam and water within the boat\u0026rsquo;s components to maximize propulsion and efficiency.\nComputational Modeling: Employing Ansys Fluent workbench for virtual simulations to predict and optimize the boat\u0026rsquo;s performance before physical construction.\n3 Initial Considerations # In the context of designing a steam boat for ThermoCup, the significance of defining boundary conditions and material selection cannot be overstated. These initial steps essentially set the groundwork for the entire project, exerting a profound influence on the boat\u0026rsquo;s performance and its eventual success in the competition.\nBoundary Conditions: Determining the environmental constraints, operational parameters, and physical limitations within which the steam boat will be mainly vital to perform CFD simulations. This includes factors such as the type of water body the boat will navigate, assumption of variations in temperature and pressure, and even limitations on the size and weight of the boat. In this case, it was intended to be an indoors competition - involving not so high velocities. Hence, mostly laminar flow, therefore a lot of simplifications were conducted to get a rough estimation of how each parameter would impact our results. However, accurately defining these boundary conditions allows participants to tailor their designs to suit real-world scenarios, ensuring the boat\u0026rsquo;s functionality under specific circumstances.\nMaterial Selection: The choice of materials for constructing the steam boat significantly impacts its structural integrity, weight, buoyancy, and overall performance. For instance, selecting lightweight yet durable materials for the boat\u0026rsquo;s structure can enhance its maneuverability and efficiency. Similarly, heat-resistant materials might be crucial for components exposed to high temperatures in the steam propulsion system.\nBut\u0026hellip;\nKeep in mind that the competition\u0026rsquo;s rules imposed caused certain constraints or guidelines regarding the materials that can be used, limitating creativity work to develop within those boundaries.\n4 Computational Fluid Dynamics # The utilization of Computational Fluid Dynamics (CFD) simulations with Ansys Fluent workbench within the ThermoCup competition marked a significant and intriguing facet of the event. Ansys Fluent is a robust software suite widely employed in engineering disciplines to simulate and analyze fluid flow, heat transfer, and associated phenomena in intricate detail.\nIn the context of ThermoCup, the incorporation of Ansys Fluent implied a multifaceted challenge for everyone beyond merely constructing a physical steam boat! It introduced a dimension where participants leverage advanced virtual simulations to iteratively refine their designs and optimize the performance of their boats via:\nVirtual Prototyping Performance Optimization Predictive Analysis Surely using machine learning tools this could have been more efficient, but for that moment it yielded good results!\n5 Solution # Attempts 1 Attempts 2 Attempts ALL After countless combinations of material and design, the choice of cork as the structural material for the steam boat in the ThermoCup competition seemed to have been a well-considered decision. Cork is known for its buoyant and lightweight properties (refer to previous Ch.2), and its higher density compared to materials like polystyrene likely provided the necessary weight and structural stability for the boat. This was especially important when simulating the boat\u0026rsquo;s performance under the natural conditions of flow, which can be challenging at higher speeds due to introduced turbulence flow and higher hydrodynamic forces, including drag and lift that can lead to steer off course as it interacts with the surrounding water.\n6 Outlook # \\[v_{\\text{km/h}} = \\frac{8}{18.9} \\times 3.6 \\approx 1.53\\text{ km/h}\\] Securing 3rd place in the competition, covering an 8-meter water lane in just 18.9 seconds, while achieving a average speed of 1.53 km/h, is a notable result. While it is not perfect, it compromised diverse engineering problem-solving skills between meticulous material selection and thoughtful design considerations by the team.\n"},{"id":8,"href":"/docs/2code/3si/","title":"Deep Learning on Fake News","section":"Coding Portfolio","content":" Language Features for Detection of Fake News # 1 A Growing Case # Fake news, a term emblematic of fabricated information intentionally disseminated across traditional news outlets or online social platforms, embodies deliberate disinformation strategies. These falsehoods aim to tarnish individuals, entities, or gain financial or political advantages, often employing misleading, attention-grabbing headlines. Some counterfeit news pieces disguise themselves as satirical content, sounding incredulous to the point of absurdity, yet managing to deceive unsuspecting audiences.\nThe proliferation of digital media and social networks has led to a rampant increase in fake news dissemination, presenting a contemporary societal challenge. Misinformation, with its potential to adversely impact lives, demands the crucial ability to differentiate between genuine and counterfeit news. This task is intricate; genuine news might appear implausible to the average reader, while fake news endeavours to appear credible.\nAddressing this contemporary issue involves the automatic identification and prevention of fake news dissemination. Efforts by digital corporations and journalistic agencies have attempted to combat fake news, but these solutions have shown imperfections. Academic research has delved into understanding the propagation of fake news, recognizing language usage as a vital parameter in these investigations.\nexample\nStudies such as those by Mahyoob in his paper titled \u0026ldquo;Linguistic-Based Detection of Fake News in Social Media\u0026rdquo; and by Preston \u0026ldquo;Detecting fake news on Facebook: The role of emotional intelligence\u0026rdquo; shed light on the analysis of language characteristics in detecting fake news, providing insights, particularly for this application within the context of Portuguese news.\nAdditionally, reports by Facebook and FactCheck.org detail the challenges and strategies in combatting misinformation, emphasizing the significance of linguistic analysis in verifying news authenticity.\nIn this project, drawing upon a meticulously curated corpus comprising 3600 true and 3600 fake Portuguese news samples, collected from January 2016 to January 2018, I aimed to automatically identify fake news using aforementioned language characteristics. This endeavour relied on analyzing 21 specific language traits meticulously classified by the corpus\u0026rsquo; authors to transform news articles into metadata, aligning with methodologies outlined by academic works and industry efforts in the field.\nThe goal of this project is to utilize established machine learning techniques, as previously outlined in research by Mahyoob and Preston, employing each language characteristic as a metadata feature, to effectively identify and mitigate the spread of fake news within Portuguese-language news sources.\n2 Approach Brainstorming # Following the problem description, there are 21 features to be analyzed:\nFeatures (click to expand) Number Feature 1 number of tokens 2 number of words without punctuation 3 number of types 4 number of links inside the news 5 number of words in upper case 6 number of verbs 7 number of subjunctive and imperative verbs 8 number of nouns 9 number of adjectives 10 number of adverbs 11 number of modal verbs (mainly auxiliary verbs) 12 number of singular first and second personal pronouns 13 number of plural first personal pronouns 14 number of pronouns 15 pausality 16 number of characters 17 average sentence length 18 average word length 19 percentage of news with spelling errors 20 emotiveness 21 diversity The initial step towards obtaining meaningful results involves preprocessing the available data. Determining which features to utilize for further division into training and testing sets was a crucial decision point, expanded upon in the following section. How were these features selected?\nA thorough study was conducted employing statistical methods to assess the variability within each feature\u0026rsquo;s dataset. Features demonstrating minimal variation, essentially stagnant in their values, were deemed non-contributory and subsequently excluded. Once these less informative features were removed, attention shifted to observing how these features varied between fake and true news samples. Four specific linguistic features were ultimately chosen, drawing from both statistical analysis and intuitive considerations.\nimportant\nTwo distinct datasets were created: one encompassing all 21 features and another featuring only the selected linguistic features. Throughout the project, these sets were compared, and the resultant differences were discussed. It was anticipated that utilizing a mere four features, compared to the full 21, might yield inferior outcomes due to the reduced dataset facilitating the differentiation between fake and genuine news. Consideration for computational resources remained pivotal. The project emphasized optimizing computational efficiency, recognizing that certain models, such as clustering or neural networks, could demand substantial computation power. Maintaining a balance between model complexity and computational demand was crucial. Efficiency was prioritized without compromising noticeable accuracy outcomes.\nFinally, acknowledging the variance in model results across simulations and the potential for parameter customization, efforts focused on identifying optimal parameter values for maximizing accuracy within each model. This iterative approach aimed to fine-tune model parameters for improved performance, considering the inherent variability in results across different simulations.\n3 Data Preprocessing # warning\nThe dataset utilized in this project originated from the \u0026ldquo;Fake.Br Corpus\u0026rdquo; directly available at Roney Santos\u0026rsquo; github page specifically curated to encompass both true and false news in Brazilian Portuguese. This corpus originally contained complete news articles. However, the focus narrowed down to extract the essential features embedded within each news piece. All data was initially formatted in .txt files, necessitating the development of a MATLAB script to convert it into a more manageable .mat format. Alternatively, the following python can be used:\n# Number of news N = list(range(1, 3603)) # Remove news that don\u0026#39;t exist for some reason N.remove(697) N.remove(1467) metaInputsTrue = [] metaInputsFake = [] metaTargetsTrue = [] metaTargetsFake = [] for i in N: # Assuming importfile function reads the data from a text file and returns a list or array # metaInputsTrue.append(importfile(f\u0026#39;{i}-meta.txt\u0026#39;)) metaInputsFake.append(importfile(f\u0026#39;{i}-meta.txt\u0026#39;)) # metaTargetsTrue.append([1, 0]) metaTargetsFake.append([0, 1]) # Load metaInputs and metaTargets from the .mat files metaInputs_data = scipy.io.loadmat(\u0026#39;metaInputs.mat\u0026#39;) metaTargets_data = scipy.io.loadmat(\u0026#39;metaTargets.mat\u0026#39;) # Access the loaded data metaInputs = metaInputs_data[\u0026#39;metaInputs\u0026#39;] metaTargets = metaTargets_data[\u0026#39;metaTargets\u0026#39;] # Combining the data metaInputs = np.column_stack((metaInputsTrue, metaInputsFake)) metaTargets = np.column_stack((metaTargetsTrue, metaTargetsFake)) # Convert lists to numpy arrays or Pandas DataFrames for further processing if needed metaInputs = np.array(metaInputs) metaTargets = np.array(metaTargets) As it is seen, this transformation yielded two primary files: \u0026lsquo;metaInputs.mat,\u0026rsquo; housing parameters for all news articles, and \u0026lsquo;metaTargets.mat,\u0026rsquo; distinguishing true news (indicated by a \u0026lsquo;1\u0026rsquo; in the first row) from false news (marked with a \u0026lsquo;0\u0026rsquo; in the second row). To simplify navigation, a structural layout was adopted: the first half of the parameter files consistently represented true news, while the subsequent half constituted false news. This deliberate arrangement facilitated easier comprehension through the interpretation of variables and generated plots.\nimportant\nThe dataset underwent a division into training and validation subsets. Employing a random selection method, 75% of the dataset was allocated for model training, while the remaining 25% served as a validation set. Analyzing the pivotal features responsible for differentiating between authentic and deceptive news involved employing various statistical methods such as \u0026lsquo;corrplot,\u0026rsquo; \u0026lsquo;matrixplot,\u0026rsquo; and \u0026lsquo;boxplot\u0026rsquo;. However, the outcomes indicated that many features exhibited high non-linearity, posing a challenge in extracting meaningful correlations and insights.\nThe only meaningful contribution came from the Boxplot.py Python function given its concise visualization using key statistics like the minimum, quartiles, median, and maximum values, providing insights into data distribution. It efficiently identifies outliers, assesses symmetry, measures data clustering, and detects potential skewness in the dataset.\n4 Methodology # Previously, all methods were initially applied to the entire set of features, followed by a re-execution using only the linguistic features for comparison. This approach aimed to gauge the potential trade-off between accuracy and computational efficiency, as eliminating numerous features could expedite processing time. Moreover, the objective shifted from merely identifying blatantly obvious fake news (e.g., those with poor punctuation or grammar) to developing a model adept at detecting less instances of misinformation, as indicated by the selected linguistic features.\n4.1. Clustering # The clustering classification method involves creating distinct clusters based on the available features and assigning each cluster a class label, distinguishing between true and fake news.\nTwo types of clustering techniques, fuzzy c-means and k-means clustering, were employed. Crisp clustering algorithms allocate each data point to a single cluster based on quantified similarity, while fuzzy clustering allows varying degrees of membership to multiple clusters, reflecting diverse similarities.\ntip\nDetermining the optimal number of clusters was an initial consideration. Initially, there was a belief that higher cluster counts might yield better results, supported by a MATLAB function \u0026rsquo;evalclusters\u0026rsquo;. However, a comprehensive study later revealed this wasn\u0026rsquo;t always the case. Commencing with K-Means clustering, an algorithm using centroids and distance metrics, data points are associated with the nearest centroid, often calculated using squared Euclidean distances.\nK-means clustering partitions observations into sets to minimize the within-cluster sum of squares. The objective function minimizes the variance by grouping observations into clusters.\n\\[\\text{Cost Function} = \\text{argmin}_S k \\sum_{i=1}^{k} \\sum_{x \\in S_i} \\| x - \\mu_i \\|_2^2 = \\text{argmin}_S k \\sum_{i=1}^{k} |S_i| \\text{Var}(S_i)\\] Variables Description for K-means clustering (click to expand) S denotes the set of clusters. k represents the number of clusters. x is a data point. \\mu_i signifies the centroid associated with cluster i. S_i indicates the i^{th} cluster. Var(S_i) represents the variance of cluster i. Identifying clusters containing fake news varied across simulations due to differing cluster numbering. To resolve this, the mode was employed to determine the cluster with the most data points, logically corresponding to fake news, given an equal split between true and fake data points.\nSubsequently, fuzzy c-means clustering was executed, allowing data points to belong to multiple clusters with varying degrees of membership. Parameters such as the initial number of clusters \u0026lsquo;c\u0026rsquo; and the exponent controlling fuzzy overlap \u0026rsquo;m\u0026rsquo; were fine-tuned to optimize accuracy.\nThe FCM algorithm partitions a collection of data into fuzzy clusters, returning cluster centers and a partition matrix indicating each data point\u0026rsquo;s degree of belonging to clusters.\n\\[\\text{Cost Function} = \\text{argmin}_C \\sum_{i=1}^{n} \\sum_{i=1}^{c} w_{ij}^m \\| x_i - c_j \\|_2^2\\] Variables Description for FCM clustering (click to expand) C signifies the collection of clusters. n represents the number of data elements. c denotes the number of fuzzy clusters. x_i represents a data point. c_j signifies the j^{th} cluster center. w_{ij} represents the degree to which x_i belongs to cluster j. m represents the fuzzifier controlling cluster fuzziness. Both FCM and k-means aim to minimize objective functions; however, the addition of membership values and the fuzzifier parameter in FCM allows for fuzzier clustering. The fuzzifier \u0026rsquo;m\u0026rsquo; determines the level of cluster fuzziness, with larger \u0026rsquo;m\u0026rsquo; values resulting in fuzzier clusters, while \u0026rsquo;m=1\u0026rsquo; implies crisp partitioning.\nStudy: Evaluation of exponent \u0026rsquo;m\u0026rsquo; for all features and linguistic features (click to expand) The observed trend indicates that the peak accuracy aligns with the lowest exponent value of \u0026rsquo;m,\u0026rsquo; typically slightly above one unit. Moreover, as the value of \u0026rsquo;m\u0026rsquo; increases, there is an observable exponential decrease in accuracy.\nApplying clustering to linguistic features followed a similar process. The analysis revealed a maximum accuracy of 87.51% concerning the exponent value.\n4.2. Fuzzy Modelling # Fuzzy modeling uses rules that are like \u0026ldquo;if-then\u0026rdquo; statements in everyday language. These rules connect input to output in systems that work with vague or uncertain information. There are two main types of rules: one that\u0026rsquo;s easier for people to understand and gives fuzzy (not exact) outputs, and another that\u0026rsquo;s more mathematical, precise, and better for complex systems.\nTo make a fuzzy system, you start by grouping similar data together, allowing for some overlap between the groups. There are different ways to do this grouping. The number of groups usually matches the number of rules used in the system.\nIn these systems, the choice of rules affects how well they work for different tasks. Considering these differences, one type of rule, the Takagi-Sugeno model, was chosen for a specific case because it\u0026rsquo;s better suited for complex systems and provides precise outputs.\nExample: Car\u0026rsquo;s adaptive cruise control system with fuzzy logic - (click to expand) If the distance to the car in front is relatively close and the speed is moderately high, then reduce acceleration slightly. If the distance to the car in front is quite far and the speed is low, then increase acceleration moderately. In this scenario, fuzzy logic allows the system to interpret vague terms like \u0026ldquo;relatively close\u0026rdquo; or \u0026ldquo;quite far\u0026rdquo; regarding the distance to the car ahead. If the system were based on the Takagi-Sugeno model, it would precisely adjust acceleration based on these conditions, ensuring smoother driving and safer distance management. In setting up the fuzzy model, the threshold for the membership function was carefully selected to prioritize minimizing false negatives over false positives. This choice aimed to err on the side of categorizing genuine news as potentially fake rather than labeling false news as true. To pinpoint the most effective threshold value, a dedicated function was designed to identify the optimal point that maximizes the model\u0026rsquo;s accuracy. Across various simulations, this optimal threshold typically fell between 0.45 and 0.55.\nLet\u0026rsquo;s assume an ideal threshold of 0.51: a visual representation illustrates this point. News pieces with a membership value above 0.51 were classified as true (shown above the black lines), while those below were categorized as fake.\nIt was previously mentioned that increasing the number of clusters might not always lead to higher accuracy in Fuzzy Modeling. To confirm this, a study was conducted to explore the relationship between accuracy and the number of clusters.\nStudy: Impact of numbers of clusters on the model\u0026rsquo;s accuracy - (click to expand) For all features:\nFor linguistic features:\nWhile an increase in clusters appears to enhance the overall consistency of average maximum accuracy, an interesting observation arises. In the simulation involving the highest number of clusters (represented as the last point), the resulting accuracy doesn\u0026rsquo;t perfectly align with the maximum accuracy achieved. Considering that all features were utilized to attain this result, and the accuracy was already quite satisfactory, the differences among the increasing clusters aren\u0026rsquo;t distinctly noticeable.\nFor in-depth study, extracting the membership functions for each features could be done by consulting Fuzzy Modeling and Identification Toolbox fm2tex function\n4.3. Artifficial Neural Networks # Background: What are Artifficial Neural Networks and how do they work? - (click to expand) Artificial Neural Networks (ANNs) were initially inspired by the human brain\u0026rsquo;s structure to handle tasks where traditional algorithms struggled. To implement an effective ANN, understanding how it predicts various inputs, its associated phases, and its adaptability to new, unknown inputs is crucial.\nA Multilayer Perceptron (MLP) is a type of feedforward ANN composed of an input layer, a hidden layer, and an output layer. The hidden and output layers consist of nonlinear activation function-equipped neurons. Unlike linear perceptrons, MLPs employ supervised learning, specifically the backpropagation technique, allowing them to handle non-linear data by adjusting node biases and connection weights.\nDuring training, the network adjusts biases and weights via backpropagation to compute output values using input weights and activation functions. To compute weight adjustments (δw_ij), the network calculates the gradient of the Mean Squared Error (MSE) cost function and multiplies it by a learning rate (α).\nValidation ensures the network\u0026rsquo;s performance by comparing computed and known outputs, detecting overfitting. Testing evaluates the fully trained network using a separate set of examples.\nThe pattern recognition neural network chosen aims to classify news as true or fake based on news parameters. Data partitioned for training (70%), validation (5%), and testing (25%) using dividerand function. Mean Squared Error as the cost function was preferred over Mean Absolute Error due to its suitability for situations where large errors are undesirable.\nVarious training methods exist, with factors like problem type, network size, and memory influencing selection. For this project, Levenberg-Marquardt (LM) algorithm was chosen due to its robustness and standard usage for pattern recognition problems.\nThe activation function \u0026rsquo;tansig\u0026rsquo; (hyperbolic tangent sigmoid) was utilized for neurons to ensure smooth activation, less computation demand, and easier weight learning, aligning well with the LM algorithm.\nThe number of neurons in the hidden layer was also left to the user’s choice, it was varied between 5, 10 and 15 neurons.\nLayers \u0026amp; Neurons All Features Linguistic Features [ 5 ] 96.7% 89.1% [ 10 ] 96.5% 89.1% [ 15 ] 96.5% 89.3% [2 2] 96.8% 88.7% [5 5] 96.6% 89.0% [10 10] 96.8% 89.0% [2 2 2] 96.7% 88.7% [4 4 4] 96.7% 88.6% [6 6 6] 96.6% 88.6% [2 2 2 2] 96.8% 88.8% [4 4 4 4] 96.8% 88.7% 5 Outcomes # Using the available function in MATLAB and the developed Python script (see below.) to retrieve the confusion matrices and the remaining metrics, it was possible to study certain parameters such as accuracy. For simplicity sake; I will just list down the results.\ndef confusionmatStats(group, grouphat=None): if grouphat is None: value1 = group else: value1 = np.array([[np.sum((group == i) \u0026amp; (grouphat == j)) for j in np.unique(grouphat)] for i in np.unique(group)]) numOfClasses = value1.shape[0] totalSamples = np.sum(value1) accuracy = (2 * np.trace(value1) + np.sum(2 * value1)) / (numOfClasses * totalSamples) - 1 TP = np.diag(value1) FP = np.sum(value1, axis=1) - TP FN = np.sum(value1, axis=0) - TP # Calculate TN without deletions TN = np.sum(value1) - (FP + FN + TP) sensitivity = TP / (TP + FN) specificity = TN / (FP + TN) precision = TP / (TP + FP) f_score = 2 * TP / (2 * TP + FP + FN) stats = { \u0026#39;confusionMat\u0026#39;: value1, \u0026#39;accuracy\u0026#39;: accuracy, \u0026#39;sensitivity\u0026#39;: sensitivity, \u0026#39;specificity\u0026#39;: specificity, \u0026#39;precision\u0026#39;: precision, \u0026#39;recall\u0026#39;: sensitivity, \u0026#39;Fscore\u0026#39;: f_score } return stats 5.1. Results Interpretation # After generating the confusion matrix plots, a comprehensive table was compiled to encompass all available accuracy metrics.\nModel Methods ANN T-S FIS FCM KM All Features Accuracy 97.3% 95.9% 94.1% 94.1% All Features True Positive 96.6% 93.8% 93.3% 93.3% All Features False Positive 2.9% 1.9% 5.2% 5.2% Linguistic Features Accuracy 89.0% 87.6% 87.1% 87.0% Linguistic Features True Positive 86.7% 85.8% 89.2% 89.1% Linguistic Features False Positive 8.8% 10.5% 15.1% 15.2% Upon reviewing the results from the testing set, the anticipated hierarchy of performance among models held true: neural networks outperformed fuzzy models, which, in turn, surpassed clustering methods. The accuracies obtained for all features were as follows: Artificial Neural Network (ANN) at 97.3%, Takagi-Sugeno Fuzzy Inference System (T-S FIS) at 95.9%, Fuzzy Clustering Means (FCM) at 94.1%, and K-Means (KM) also at 94.1%. As expected, the use of only linguistic features resulted in lower accuracies due to fewer comparison terms.\ntip\nObserving the performance on training versus testing sets revealed slight overfitting in the NN and T-S FIS models, showcasing approximately 1% higher accuracy in the training set. To address this issue, augmenting the dataset and employing regularization techniques could enhance model generalization, ensuring better learning of patterns from the training data. Interestingly, FCM and KM showed closely aligned results, especially with linguistic features where they were identical. Altering the exponent for the fuzzy partition matrix could prompt FCM to converge towards KM values.\nAll methods exhibited accuracies exceeding 94% when using all features, indicating proficient performance in categorizing news. This implies that out of 7200 news pieces, more than 6760 were accurately identified based on their features, with the highest accuracy of 97.3% signaling misclassification of only about 200 news articles.\nUsing solely linguistic features yielded satisfactory results, with all methods achieving accuracy equal to or greater than 87%. This indicates that, among 7200 news items, more than 6264 were correctly categorized based on their features. However, the highest accuracy of 89.1% suggested misidentification of 784 news articles.\nwarning\nIt\u0026rsquo;s noteworthy that employing a vast number of clusters significantly escalates computational demands. Balancing computational efficiency against marginal performance improvements is crucial, as extended computation time might not necessarily yield substantial enhancements in results. 5.2. My Thoughts on Applying Machine Learning for Fake News Detections # Wrapping things up, the ANN, T-S FIS, C-M, and K-M methods all delivered pretty solid outcomes, with the ANN standing out as the star performer here.\nSure, the accuracy obtained was good enough for the work performed, but in the real world, aiming for near-perfect accuracy—like nudging towards that 100% mark—holds serious weight. Think about it, labeling something as fake when it\u0026rsquo;s not, or the other way around, carries hefty ethical, legal, and economic implications.\nBoosting accuracy is a puzzle. Tweaking model parameters or even experimenting with more clusters might help, but there\u0026rsquo;s a catch—those simulations could drag on forever. Another trick is amping up the features, like diving into the writing style or digging into the website URL to suss out if the source is trustworthy. But beware, piling up features might lead to overfitting headaches.\nI could\u0026rsquo;ve explored different models too; who knows, they might\u0026rsquo;ve bumped up the accuracy. Or, here\u0026rsquo;s a thought: splitting news by their subject could\u0026rsquo;ve been a game-changer. I mean, the language in political news can be totally different from religious or society-related stuff.\nHere\u0026rsquo;s the kicker though: who\u0026rsquo;s the big shot deciding if an article\u0026rsquo;s legit or not? Right now, it\u0026rsquo;s mostly on the audience to figure that out. But can we really rely solely on them to spot the good from the bad? Food for thought, right?\n"},{"id":9,"href":"/docs/2code/1drone/_index3/","title":"Drone Controller Design Pt. 1","section":"UAV Red Bull Air Racing","content":" Phase 2. Controller Design Pt. 1 # tip\nIf you wish to skip the theoretical and implementation details, please click here to jump to the summarized findings Ch. 9 - Piloting in a Loop. I have cool images! ✌️ 1 Continuing from Section 1\u0026hellip; # Previously, I had addressed problem formulation and initial approaches. The primary tasks included studying the system and subsystems, creating a state-space model for the dynamical system, analyzing aspects like linearity, stability, controllability, and observability, developing Simulink models, proposing classical state feedback control, and validating the simulator for the developed models.\ninfo\nFollowing the delivery of Phase I, issues were identified in the drone controller. Although functional, some minor problems remained unresolved. The movement subsystem had initially been modeled as a 12th order system, established as linearizable, controllable, and observable. In the upcoming work, the decision was made to break down the movement system into four subsystems: vertical, lateral, longitudinal axis movement, and yaw subsystem. The primary objective is to formulate and address optimal control and estimation problems. It is intended to compare outcomes from the pole placement controller and the Luenberger observer with those achieved using the optimal controller (Linear Quadratic Regulator) and optimal observer (Kalman-Bucy observer).\n2 Actuation and Sensors # Before commencing the formulation and implementation of the required controllers and estimators, there are preliminary details that necessitate consideration.\nOne of the initial considerations revolves around the actuation, specifically the voltages applied to each motor. It was established during the project\u0026rsquo;s initial phase that the model was linearized under a hovering condition. From this state, the computation of the required equilibrium motor actuation was derived.\n\\[V_0 = 7.9V\\] In the context of the linear model, a null actuation maintains the system in a hovering state, implying no resultant motion. This characteristic arises from the actuation being a deviation from the nominal value rather than the actual voltage applied to the motors. To prevent motor saturation, it\u0026rsquo;s crucial to adhere to the following voltage deviation constraints:\n\\[\\Delta V_{\\text{max}} = V_{\\text{bat}} - V_0 = 11.1 - 7.9 = 3.2 \\, \\text{V}\\] \\[\\Delta V_{\\text{min}} = V_0 = 7.9 \\, \\text{V}\\] In the non-linear model, maintaining the hovering condition necessitates applying V0 to all motors. However, the controllers are formulated based on the linear model. Therefore, the voltage offset should only be added after the controllers compute the necessary actuation. As a result, the maximum and minimum voltage deviations align with those of the linear model. Another crucial aspect involves the design of observers. Understanding which state variables lack direct physical measurement is essential, as these variables demand estimation using an observer.\nFor the drone in question, only the position (Px, Py, and Pz) and orientation ( \\(\\phi, \\theta, \\text{and} \\psi\\) ) are directly measurable. Consequently, the estimation of linear velocity ( \\(\\dot{P}_x, \\dot{P}_y \\text{and} \\dot{P}_z \\) ) and angular velocity ( \\(\\dot{\\phi}, \\dot{\\theta} \\text{and} \\dot{\\psi} \\) ) becomes necessary.\nAdditionally, it was indicated that sensor noise would impact the measured signals, with the noise variance specified for each sensor.\nParameters - (click to expand) Parameter Value Inertial position x, px 7.3221 × 10^-4 Inertial position y, py 4.2829 × 10^-4 Inertial position z, pz 1.8000 × 10^-4 Roll, φ 3.4817 × 10^-4 Pitch, θ 2.6060 × 10^-4 Yaw, ψ 3.8313 × 10^-5 It was suggested that the noise issue could potentially be addressed by employing the Kalman-Bucy estimator in place of the Luenberger observer.\n3 Servo Feedback Control Via Pole Placement # The objective of stabilizing the system while enabling reference tracking necessitates the implementation of a servo feedback control system. This entails designing the matrices K and ki, as depicted:\nBefore computing the controller parameters, the selection of desired poles becomes crucial for modifying the system dynamics. As outlined previously, the model can be separated into four distinct subsystems, each with poles located at the origin. Furthermore, it was demonstrated that all these subsystems are controllable.\nSpecifically, the vertical axis and yaw subsystems are both represented as second-order systems and follow the structure defined in equation 4.\n\\[\\begin{bmatrix} \\dot{x}_1(t) \\\\ \\dot{x}_2(t) \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \\\\ \\end{bmatrix} \\begin{bmatrix} x_1(t) \\\\ x_2(t) \\\\ \\end{bmatrix} \u0026#43; \\begin{bmatrix} b \\\\ 0 \\\\ \\end{bmatrix} u(t) \\\\\\] \\[y(t) = x_2(t) = [0 \\, 1] \\begin{vmatrix} x_1(t) \\\\ x_2(t) \\\\ \\end{bmatrix}\\] The augmented system is, therefore, given by:\n\\[\\begin{bmatrix} \\dot{x}_1(t) \\\\ \\dot{x}_2(t) \\\\ \\dot{x}_i(t) \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \u0026amp; 0 \\\\ \\end{bmatrix} \\begin{bmatrix} x_1(t) \\\\ x_2(t) \\\\ x_i(t) \\\\ \\end{bmatrix} \u0026#43; \\begin{bmatrix} b \\\\ 0 \\\\ 0 \\\\ \\end{bmatrix} u(t) \\\\\\] \\[y(t) = x_2(t) = [0 \\, 1 \\, 0] \\begin{bmatrix} x_1(t) \\\\ x_2(t) \\\\ x_i(t) \\\\ \\end{bmatrix}\\] By employing Ackermann’s Formula through the MATLAB function \u0026ldquo;acker\u0026rdquo; and selecting all poles at -5, the controller gains for the vertical axis and yaw subsystems are provided by:\n\\[\\bar{K}_{\\text{vertical}} = [-24.16, -120.79, 201.32]\\] \\[\\bar{K}_{\\text{yaw}} = [6.58, 32.90, 54.83]\\] The remaining two subsystems, the lateral and longitudinal subsystems, are composed of two second-order systems each (roll and pitch, respectively). Consequently, these subsystems are both fourth-order systems and follow the structure defined:\n\\[\\begin{bmatrix} \\dot{x}_1(t) \\\\ \\dot{x}_2(t) \\\\ \\dot{x}_3(t) \\\\ \\dot{x}_4(t)\\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; Q_{32} \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ \\end{bmatrix} \\begin{bmatrix} x_1(t) \\\\ x_2(t) \\\\ x_3(t) \\\\ x_4(t) \\\\ \\end{bmatrix} \u0026#43; \\begin{bmatrix} b \\\\ 0 \\\\ 0 \\\\ 0 \\\\ \\end{bmatrix} u(t)\\] \\[y(t) = x_4(t) = [0 \\, 0 \\, 0 \\, 1] \\begin{bmatrix} x_1(t) \\\\ x_2(t) \\\\ x_3(t) \\\\ x_4(t)\\\\ \\end{bmatrix}\\] The resultant augmented system is: \\[\\begin{bmatrix} \\dot{x}_1(t) \\\\ \\dot{x}_2(t) \\\\ \\dot{x}_3(t) \\\\ \\dot{x}_4(t) \\\\ \\dot{x}_i(t) \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; Q_{32} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\\\ \\end{bmatrix} \\begin{bmatrix} x_1(t) \\\\ x_2(t) \\\\ x_3(t) \\\\ x_4(t) \\\\ x_i(t) \\\\ \\end{bmatrix} \u0026#43; \\begin{bmatrix} b \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ \\end{bmatrix} u(t)\\] \\[y(t) = x_4(t) = [0 \\, 0 \\, 0 \\, 1 \\, 0] \\begin{bmatrix} x_1(t) \\\\ x_2(t) \\\\ x_3(t) \\\\ x_4(t) \\\\ x_i(t) \\\\ \\end{bmatrix}\\] Through Ackermann’s Formula and after a trial-and-error process, selecting all poles at -5, the controller gains for the lateral axis and longitudinal axis subsystems are represented: \\[\\bar{K}_{\\text{lateral}} = [1.49, 14.90, 7.59, 18.99, -18.99]\\] \\[\\bar{K}_{\\text{longitudinal}} = [1.69, 16.93, -8.63, -21.57, 21.57]\\] 4 Luanberger Observer # As previously mentioned, the onboard sensors can only physically measure position and orientation. Consequently, the estimation of linear and angular velocities within the subsystems\u0026rsquo; state vectors becomes necessary.\nThe fundamental concept behind an estimator involves creating a numerical simulator of the physical system, receiving actuation as input, and producing the state space vector estimation as output. However, this approach alone isn\u0026rsquo;t sufficient. The estimation error can asymptotically vanish if the state is unstable, and the convergence velocity of the error is limited by the system\u0026rsquo;s velocity.\nTo address this, the implementation of a Luenberger observer is essential. As depicted in the following figure, the adjustment of observer performance can be achieved by tuning the parameters within matrix L.\nTo derive the Luenberger observer, it\u0026rsquo;s crucial to select the desired poles ensuring that the observer operates faster than the system dynamics without excessively amplifying modeling errors. In this scenario, for this system, a choice was made to position the poles 10 times faster than those of the controller, thus setting all poles at -50. Additionally, it\u0026rsquo;s pertinent to note that, as previously explained in the initial phase, the system is observable.\nUtilizing Ackermann’s formula, specifically via the MATLAB function \u0026ldquo;acker\u0026rdquo;, the matrix L for the designed Luenberger observer for the vertical, yaw, lateral, and longitudinal subsystems can be described in the following equations:\n\\[L_{\\text{vertical}} = \\begin{bmatrix} 2500 \\\\ 100 \\end{bmatrix}\\] \\[L_{\\text{yaw}} = \\begin{bmatrix} 2500 \\\\ 100 \\end{bmatrix}\\] \\[L_{\\text{lateral}} = \\begin{bmatrix} 6.371 \\\\ 0.510 \\\\ 0.150 \\\\ 0.002 \\end{bmatrix}\\] \\[L_{\\text{longitudinal}} = \\begin{bmatrix} -6.371 \\\\ -0.510 \\\\ 0.150 \\\\ 0.002 \\end{bmatrix}\\] 5 Linear Quadratic Regulator # The pole placement method demonstrated in the previous sections yielded satisfactory outcomes. However, it poses challenges in tuning the controller, becoming increasingly complex as the system\u0026rsquo;s order increases. Additionally, it complicates the task of finding a compromise between conflicting objectives when designing a controller.\nIn light of this, the focus now shifts to considering an optimal controller that takes into account conflicting goals and strategically places poles in an optimal manner. Specifically, the design will involve a linear quadratic regulator (LQR). In designing an optimal controller, the usual objective is to minimize energy consumption (represented by the control action) while maximizing the distance traveled—objectives that clearly conflict.\nThe initial step involves selecting a performance index J that reflects these conflicting objectives. In this case, the performance index specified by the following equation is utilized, aiming to be minimized.\n\\[J = \\int_{0}^{\\infty} (x^T(t) Q x(t) \u0026#43; u^T(t) R u(t)) \\, dt\\] Certainly, in a manner akin to PID controller parameters, the matrices Q (where Q ≥ 0) and R (where R \u0026gt; 0) play a pivotal role. They contribute to the behaviour of the system and need to be tuned to achieve the desired system response. Augmenting Q results in faster convergence of states toward the reference, while increasing R penalizes larger control inputs. The balance between performance and energy expended is thus represented by the relative values assigned to both matrices.\nIn an optimal controller, the controller gains aren\u0026rsquo;t constant over time. However, it\u0026rsquo;s more common to design a sub-optimal controller where K is a constant value. Adhering to this approach, the computation of matrix K is outlined:\n\\[K = R^{-1}B^T P\\] tip\nMatrix P is the solution of the algebraic Riccati equation. It was mentioned that, in pursuit of tracking a reference rather than merely maintaining states at zero, the MATLAB function \u0026ldquo;lqi\u0026rdquo; (linear quadratic integrator) becomes crucial as it computes both K and ki values.\nThe success in achieving desired performance largely hinges on the choice of relative values within Q and R matrices. Specifically, emphasis was placed on the need to tune diagonal values, allowing for certain values to be set to zero if controlling a particular state isn\u0026rsquo;t deemed necessary.\nRegarding the yaw angle and vertical axis subsystems, considering their augmented third-order nature, the prescribed values for Q and R were specified through equations:\n\\[Q_{\\text{yaw}} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 10 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 50 \\\\ \\end{bmatrix} ; \\quad R_{\\text{yaw}} = 1\\] \\[Q_{\\text{vertical}} = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 50 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 100 \\\\ \\end{bmatrix} ; \\quad R_{\\text{vertical}} = 1\\] In regard to the longitudinal axis and lateral axis subsystems, the augmented systems are identified as fifth-order. The designated values for Q and R are specifically detailed:\n\\[Q_{\\text{longitudinal}} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 10 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 10 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 50 \\\\ \\end{bmatrix} ; \\quad R_{\\text{longitudinal}} = 1\\] \\[Q_{\\text{longitudinal}} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 10 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 10 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 50 \\\\ \\end{bmatrix} ; \\quad R_{\\text{longitudinal}} = 1\\] 6 Kalman-Bucy Observer # It was highlighted earlier that the system\u0026rsquo;s onboard sensors aren\u0026rsquo;t ideal and will inevitably introduce noise into the measurements. This noise can significantly impact the system\u0026rsquo;s performance, potentially leading to errors when following a reference and even instability in the drone\u0026rsquo;s motion, particularly in the more sensitive nonlinear system, susceptible to actuation oscillations.\nThere are two distinct noise types—process noise (v(t)) and sensor noise (w(t)), both assumed to be zero-mean white noise with known variance.\nDue to the presence of noise in the measured values, the accuracy of the implemented Luenberger observer in estimating the state space variables diminishes. To counteract this, the Kalman-Bucy observer will be utilized.\nThe process of tuning the Kalman filter gains in matrix Lk involves adjusting Q0 and R0 values. The known variance values from the sensor noise were allocated to R0.\nQ0 values were determined via a trial-and-error approach until the noise impact was minimized. The resulting values for the yaw, vertical, longitudinal, and lateral subsystems are articulated in equations:\n\\[Q_0^\\text{yaw} = 10^{-6}\\] \\[Q_0^\\text{vertical} = 10^{-6}\\] \\[Q_0^\\text{longitudinal} = 10^{-10}\\] \\[Q_0^\\text{lateral} = 10^{-10}\\] Combining the developed LQR with the Kalman-Bucy observer results the Linear Quadratic Gaussian.\nIt\u0026rsquo;s crucial to note that, similar to the LQR, the relative values assigned to Q0 and R0 significantly impact the observer\u0026rsquo;s performance. Consequently, the small values in Q0 correspond to the small values of sensor noise variances present in R0.\nAdditionally, it\u0026rsquo;s important to acknowledge that despite my best effort, successfully eliminating the noise proved challenging. This difficulty persisted even after attempting various values for the Kalman filter parameters. The impact of these results, particularly evident in the nonlinear simulation, is thoroughly discussed in the simulation results.\n7 Simulation Results # I conducted comprehensive testing of the implemented controllers (via pole placement and LQR) and observers (Luenberger and Kalman-Bucy) using both the linear simulator developed in the initial phase and the full nonlinear simulator provided in the subsequent phase.\nwarning\nTwo primary tests were conducted to evaluate performance:\nStep Reference Test: This involved applying step changes to the four references (Px, Py, Pz, and ψ). The objective was to assess performance in a complex scenario where the controller needed to combine four actuations to track a four-degree-of-freedom motion. Ramp Reference Test: A series of ramps was utilized to create a simpler yet realistic trajectory for the drone to follow. Both tests were executed in both simulators, comparing results with and without noise injected into the sensors. The Simulink block \u0026ldquo;Band-Limited White Noise\u0026rdquo; was employed by the group to implement the noise. The aim was to comprehensively evaluate the controllers\u0026rsquo; and observers\u0026rsquo; performance under various scenarios and noise conditions using different trajectory types. This allowed for a robust assessment of their effectiveness and robustness in real-world scenarios.\n7.1. Linear Model # The used steps provide the following references to the system:\nReferences - (click to expand) Variable Value px 1m py 1m pz -1m ψ π/8 rad Using the pole placement controller and the Luenberger observer without noise in the measurements results:\nEnsuring that the roll and pitch angles remain within acceptable ranges is crucial, as discussed in the initial phase. Large values of these angles could potentially lead the drone to lose all vertical propulsion forces. In the nonlinear simulator, this scenario might cause the drone to descend rapidly and crash the simulation.\nObserving the following figure allowed verification that the roll and pitch angles were maintained at acceptable levels, preventing potential issues that could result in the loss of vertical propulsion forces and subsequent simulation crashes. This detail is particularly critical in maintaining stable flight conditions and avoiding adverse consequences due to extreme pitch and roll angles.\nPitch and Roll via using Pole placement Controller and Luenberger observer - (click to expand) Verifying that the actuation did not saturate:\nActuation of each motor using the Pole placement Controller and Luenberger observer - (click to expand) In the subsequent test, similar to the previous one, the LQR controller was employed instead of the pole placement controller. However, the observer used remained the Luenberger observer, as no noise was introduced to the measurements.\nResponse of the states following the step values with LQR and a Luenberger observer - (click to expand) Verifying again that the pitch and roll angles stay within reasonable values:\nPitch and Roll using the LQR formula and Luenberger observer - (click to expand) Actuation for the LQR and Luenberger observer - (click to expand) info\nObserving the actuation, it\u0026rsquo;s apparent that not only does the actuation avoid reaching saturation values, but it also remains lower compared to the values attained using the pole placement controller. This outcome was anticipated since the LQR operates as an optimal controller, balancing system performance with energy consumption. Moving forward, the analysis focuses on the system\u0026rsquo;s behaviour when noise affects the measurements provided by the sensors. As previously discussed, the Luenberger estimator generates estimations with errors and becomes impractical when noise corrupts the measurements. To address this challenge, the developed Kalman-Bucy observer is utilized. T\ninfo\nKalman filter effectively reduces most of the noise from all measured signals, while the Luenberger estimator follows the corrupted signal. This emphasizes the superiority of the Kalman-Bucy observer in mitigating noise-induced errors compared to the Luenberger estimator. The sensors and noise estimations can be evaluated:\nNow, performing the identical test where the four steps serve as references, yet employing the LQR with the Kalman-Bucy observer (Linear Quadratic Gaussian), the results depicted as follows confirm our expectations. The LQG successfully tracks the references even in the presence of noise in the measurements. This reaffirms the robustness and effectiveness of the LQG controller coupled with the Kalman-Bucy observer in handling noisy measurements while accurately following the given references.\nStep for LQG - (click to expand) Pitch and Roll for LQG - (click to expand) Actuation for LQG - (click to expand) 7.2. Nonlinear Model # Using the same steps of the previous section and using the pole placement controller with the Luenberger observer:\nActuation of each motor using the pole placemente controller and a Luenberger observer - (click to expand) Pitch and Roll using the pole placement controller and Luenberger observer - (click to expand) Roll and pitch angles are acceptable. Actuation of each motor using the pole placement controller and the Luenberger observer - (click to expand) Actuation did not saturate. Using now the LQR with the Luenberger estimator, the reference tracking results:\nPosition tracking with LQR and Luenberger observer - (click to expand) Pitch and Roll using the LQR and Luenberger observer - (click to expand) Roll and pitch angles are acceptable. Actuation of LQR and Luenberger observer - (click to expand) Actuation did not saturate. Having shown in the previous section that when noise is present, the Kalman-Bucy observer is used, the same test using the Linear Quadratic Gaussian will be assessed.\nStep with LQG - (click to expand) Pitch and Roll with LQG - (click to expand) Again, the roll and pitch angles are reasonable. Notice that the absolute maximum value for both pitch and roll is around 0.03 rad (1.71 degrees). Actuation with LQR and Kalman-Bucy - (click to expand) Actuation did not saturate. 7.3. Remarks # From the comprehensive results obtained from both linear and nonlinear models, it can be concluded that all controllers and observers were correctly implemented and exhibited their intended functionality.\nAn essential finding across both models was the significance of using the Kalman-Bucy observer when noise significantly impacts sensor readings. This observer proved crucial in handling noisy measurements effectively.\nCareful consideration of roll and pitch angles was emphasized due to their potential impact on causing rapid altitude loss in the nonlinear simulation. Numerous instability issues were encountered, especially when step values were too large, resulting in aggressive actuation and subsequent system instability. To mitigate these issues, alternative reference signals were introduced to reduce initial error and consequent motor actuation.\nnote\nAddressing actuation saturation and avoiding extreme pitch and roll angles can be achieved through various methods. One such solution involves implementing a saturation block on motors to ensure voltages stay within permissible limits. However, a straightforward saturation approach on individual motors may hinder the drone from following the desired trajectory. To resolve this, a strategy of limiting all actuations whenever one motor saturates allows the drone to continually attempt trajectory following without losing control or erratic behavior. This approach ensures a more controlled response in scenarios where actuation saturation or extreme angles could destabilize the system. 8 Trajectory Following # After successfully testing the system with step references, I implemented a trajectory using a series of ramps to guide the drone\u0026rsquo;s trajectory, aiming to minimize initial error. This trajectory, designed to trace a \u0026ldquo;8\u0026rdquo; shape with the drone landing at its initial take-off position, underwent testing in both the linear and nonlinear models.\nTo determine the maximum slope of the reference ramps, a trial-and-error process was conducted using the nonlinear model. By gradually increasing the slopes of the ramps (for the four references) until the drone became uncontrollable. Moreover, it was noted that the maximum pitch and roll angles remained below 0.6 radians (approximately 35 degrees).\nSimilar to the steps test, I was interested in evaluating trajectory tracking accuracy, assessing steep roll and pitch angles, and identifying any actuation saturation during the ramp trajectory test. Considering previous conclusions, I opted to use the Linear Quadratic Regulator without noise and the Linear Quadratic Gaussian when noise was introduced to the sensors. This choice allows for a comprehensive evaluation of trajectory tracking performance and system stability under different conditions, ensuring the suitability of the controllers and observers for both noise-free and noisy sensor scenarios.\n8.1. Linear Model # As it can be seen for the reference tracking of the drone, the results are satisfactory and the control system was able to follow the entire trajectory with no issues.\nReference and response along the trajectory - (click to expand) Actuation of each motor along the trajectory of the linear system - (click to expand) Actuation did not saturate. Response of the angles along the trajectory of the Linear system - (click to expand) The roll and pitch angles are reasonable. example\nI also created a 3D plot of the trajectory flown by the drone for the linear system. Plot is seen in the following figure: warning\nIt was previously established that when sensor noise is present, employing the Kalman-Bucy observer becomes essential. The next figure demonstrates that without the Kalman filter, the drone\u0026rsquo;s motion becomes erratic, showcasing evident actuation saturation issues. Logically, adding the Kalman filter to tackle the noise, the results improve.\nReference and response along the trajectory - (click to expand) Actuation of each motor along the trajectory - (click to expand) Actuation did not saturate. Pitch and roll along the trajectory - (click to expand) The roll and pitch angles are reasonable. example\nAside from the 3D plot of the trajectory, I showcase a zoomed section showcasing the bits of oscillation due to noise. 8.2. Nonlinear Model # Following a similar strategy as in ch. 8.1. Linear Model:\nReference and response along the trajectory - (click to expand) Actuation of each motor along the trajectory - (click to expand) Actuation did not saturate. Response of the angles along the trajectory - (click to expand) The roll and pitch angles are reasonable. example\nI also created a 3D plot of the trajectory flown by the drone for the nonlinear system. Plot is seen in the following figure: Adding noise to the sensor measurements and using the Kalman-Bucy observer, the following results are obtained:\nReference and response along the trajectory - (click to expand) Actuation of each motor along the trajectory - (click to expand) Pitch and roll along the trajectory - (click to expand) example\nAside from the 3D plot of the trajectory, I showcase a zoomed section showcasing the bits of oscillation due to noise. 9 Piloting in a Loop # This work section aimed to design and test controllers and observers crucial for drone control.\nInitially, by designing a controller using the pole placement method, employing Ackermann’s Formula. Simultaneously, a Luenberger observer was tailored to estimate variables unmeasurable by physical means, aligning its dynamics to be faster than the controller.\nSubsequently, an optimal controller and observer were developed, specifically the Linear Quadratic Regulator (LQR) and the Kalman-Bucy observer. The LQR demonstrated efficient reference tracking with reduced actuation, minimizing energy consumption. However, with the Kalman filter, despite attempts to tune it, complete noise removal wasn\u0026rsquo;t achieved, especially in the sensitive nonlinear simulator, affecting responses to step references.\nNonetheless, the Kalman filter proved beneficial in noise-affected sensor scenarios, although further tuning is intended to improve its performance.\nIn addition, it was also introduced a solution using refined reference signals, enhancing trajectory tracking and stability compared to step references.\ntip\nAdvance to Discrete Controller Design Here ✌️ "},{"id":10,"href":"/docs/1design/3pmec/","title":"Industrial Crane Design","section":"Design Portfolio","content":" How Much Can You Lift? # 1 Double Girder Crane for Industrial Application # 1.1. Description and Context # This project was carried out within the scope of the Mechanical Design Course, part of my M.Sc journey. It aims to dimension and study fundamental structural components of a double girder suspension crane. Bridge cranes are frequently used equipment in the industry, especially in metallurgy, playing a pivotal role and being deployable both indoors and outdoors. A bridge crane is a piece of equipment that, despite not being highly complex, encompasses all the elements that warrant study, allowing for the application of theoretical concepts applied to a real-world scenario.\n1.2. Goals # This project aims to conduct the dimensioning and study of fundamental structural components. The sizing will be executed in accordance with applicable standards and demonstrated through analytical calculations and finite element models. In addition to the structural elements of the equipment, fundamental mechanical components of the system, including welded and bolted connections, will also be sized. Coupled with the dimensioning aspect is the economic factor, aiming to minimize costs while ensuring the safety of the entire structure\n1.3. Functionalities # Bridge cranes are used for lifting and moving heavy loads. The structural and mechanical components to be sized are:\nResistant girders, consisting of a reinforced box profile; Trolley frame; Trolley shaft; Driving and driven wheels; The selected structural and mechanical components are:\nHoist trolley; Bearings; Gear motor. Main components:\nThe trolley frame is located at the ends of the resistant girders. Inside it, the mechanism for the crane\u0026rsquo;s movement is situated, powered by a gear motor. The wheels move along tracks, following well-defined paths. Resistant girders are crucial structural components in this type of equipment. They are the elements that endure the most stress caused by the weight of the load being transported. The hoist trolley has a translational motion along the resistant girders, allowing for the transport of the load perpendicular to the crane\u0026rsquo;s direction of movement. It facilitates the lifting of the load to be transported. In Portuguese: Main components of a double girder crane - (click to expand) 1.4. Design Specifications # 1.4.1. Design Requirements # The following requirements were considered for this project:\nNominal load of 8 tons; Span between wheels of 10 meters; Workshop environment; Operating temperatures between 0 and 40 degrees Celsius; 8 hours of operation per day; Maximum translation speed of 25 m/min. 1.4.2. Project Constraints # The decision was made to design a bridge crane for an enclosed environment. 1.5. Standards, Codes, and Regulations # In the completion of this work, the FEM Standards (European Federation of Materials Handling), particularly Chapter II, and Eurocode 3 were utilized. The FEM standards address specific issues related to structures and handling equipment, including cases such as bridge cranes and gantry cranes.\n1.6. Approach # A study was conducted on various existing construction solutions available in the market for this type of equipment. For the girders, a box-type section was chosen with a constant thickness of 10mm, made of AISI 1095 steel, and measuring 10m in length. These girders consist of 4 steel plates welded together with a 5mm thick welding bead. The rails are positioned on the girders, not aligned with the vertical plane passing through the girder\u0026rsquo;s centroid, as this alignment would create a high bending moment on the upper plate of the girder. The connection between the girders and the trolley frame is established using 6 bolts M36x4 CR 10.9 and welding with a 10mm thick bead.\nThe chosen hoist trolley is the STAHL - SH 5020, which has a wheelbase of 1m and a mass of 755 kg. The following data pertains to the assembly composed of the two girders, two trolley frames, and the hoist trolley:\nWeight: 1229.3 kg Maximum width: 3.4 m Maximum length: 10.14 m 1.7. Manufacturing and Assembly Processes # The steel plates are obtained through a cold rolling process. Their surface roughness with an arithmetic mean deviation is 4.8 micrometers. The geometric tolerance concerning the thickness of these components is \\(\\pm\\) 0.1 mm.\nFor the resistant girders:\nWelding of the two web plates to the bottom flange. Welding of the internal transverse reinforcements. The end reinforcements of the girder, which will function as covers, will be welded in a manner that the welding beads remain inside the girder. Welding of the top flange. Welding of the rail. Welding of the lateral reinforcements. Welding of the base fixing. The welding for the first, third, and fourth steps will be conducted using the Submerged Arc Welding process. This method is advantageous due to the substantial length of the welding bead, allowing for automation of the equipment carrying out the operation. The welding for the remaining steps will be executed using TIG (Tungsten Inert Gas) welding. The required equipment will be operated by a skilled worker.\n1.8. Costs # The price of AISI 1095 Q\u0026amp;T steel is approximately €1/kg. Considering the girders weigh around 346.6 kg, their cost will be approximately €346.6. The labor cost is around €9/m, and the analyzed structure totals 53.2m, amounting to approximately €478.8.\n1.9. General Simplifications # Only the main components were designed, namely the girders. The trolley frames and the remaining support structure were not designed. The studied overhead crane was interior, simplifying the analysis, as exterior conditions would introduce wind forces. For the sizing, it was considered that the hoist trolley was positioned in the middle of the girders (longitudinally), as this situation causes the greatest deformations.\n2 Calculations # 2.1. Material # Due to the high stresses to which the box girder of the overhead crane is subjected, it\u0026rsquo;s necessary to select a structural steel with considerable yield strength to ensure the component meets service conditions and to minimize stress concentration and fatigue issues. With this in mind, the following steel with a tempering and tempering treatment was chosen:\nS_u S_y E G \\nu 1210 MPa 772 MPa 210 GPa 81 GPa 0.3 2.2. Dimensioning Criteria # 2.2.1. Rigidity Criterion # The box girders, with a length of 10 m, must meet this criterion from EN 1993-6:2007, where the maximum allowable deflection is given by:\n\\[ \\delta_{z,max} = \\frac{L}{600} = 16.7 \\text{mm} \\] To meet this criterion, an initial H/L ratio of 2.2 was chosen.\n2.2.2. Mechanical Strength Criterion # The mechanical strength criterion was defined using the Pugsley criterion with the specified coefficients n = 2,08.\n2.3. Beam Sizing # 2.3.1. Static Verification # To size the beam, an analytical model was developed considering two vertical loads corresponding to the nominal load and the weight of the trolley. The value of each of these two forces was previously defined according to the FEM standards, already multiplied by the dynamic coefficient and the amplification coefficient. The value of each force is 26.7 kN and they are spaced 1 meter apart. Additionally, the weight of the beam itself, which is not negligible, is represented as a distributed load. To verify the stiffness criterion, an H/L ratio of 2.2 was initially chosen. Using tables of maximum deflection, employing the superposition method and also considering the load P equivalent to 26700N and the load application point (offset) at x = 4.5 m, the following expression for the beam\u0026rsquo;s maximum deflection is obtained:\n\\[y_{\\text{max}} = 2 \\left[ \\left( \\frac{P \\times b}{6 \\times E \\times I_z \\times 10} \\right) \\times \\left( \\left( 5^3 - \\left( 10^2 - b^2 \\right) \\times 5 \\right) \\right) - \\frac{5 \\times w \\times 10^4}{384 \\times E \\times I} \\right] \\] Next, an expression for a given moment of inertia around z, Iz, was obtained as a function of the section\u0026rsquo;s height H.\n\\[ I_z = \\frac{2}{10^{12}} \\left[\\left(10 \\times (2H - 20)^3\\right) \u0026#43; \\left({2L \\times 10^3}\\right)\\right] \u0026#43; 10L(H - 5)^2 \\] The distributed loading, w, was defined using the density of the chosen material ( \\(\\rho\\) ) = 78450 N/ \\(m^3\\) :\n\\[w = \\frac{Volume \\times \\rho}{L} = 4.564H - 31.38\\] Upon solving the equation for maximum deflection, an expression in terms of H was obtained. From the graph, a value of H = 260 mm was selected, corresponding to L = 118.2 mm, thereby fulfilling the rigidity criterion.\nAt present, the computation of the Von Mises equivalent stress has become feasible. This involves determining both the shear stress resulting from torsion and the shear stress attributed to it.\n\\[\\tau_V = \\frac{V \\times Q}{I_z \\times b} = \\frac{27170 \\times 2 \\times (0.125 \\times 0.0025 \u0026#43; 0.255 \\times 0.0023)}{0.00052 \\times 0.02} = 3.234 \\times 10^6 \\text{Pa} \\\\ \\\\ \\tau_T = \\frac{T}{2 \\times A_m \\times t} = \\frac{2250 \\times 2}{2 \\times (0.1664 \\times 0.510) \\times 0.1} = 2.651 \\times 10^6 \\text{Pa} \\\\ \\\\ \\sigma_M = \\frac{M_c}{I_z} = \\frac{131660 \\times 0.26}{0.00052} = 6.637 \\times 10^7 \\text{Pa} \\\\\\] Subsequently:\n\\[\\sigma_{VM} = \\sqrt{\\sigma_M^2 \u0026#43; 3\\left(\\tau_V^2 \u0026#43; \\tau_T^2\\right)} = 6.723 \\times 10^7 \\text{Pa}\\] Having the safety factor:\n\\[n = \\frac{S_y}{\\sigma_{VM}} = \\frac{772 \\times 10^6}{6.723 \\times 10^7} = 11.482 \u0026gt; 2.08\\] 2.3.2. Fatigue Verification # The minimum stress is determined by the weight of the beam and the winch car itself (considering the winch car unloaded). Conversely, when the winch car is loaded (the scenario considered for calculating the static safety factor), the corresponding stress will be at its maximum. It can be derived the ratio between the minimum and maximum stresses by calculating the minimum stress for the unloaded car. Repeating this process for the calculation of the Von Mises stress for the unloaded load case yields.\n\\[R = \\frac{\\sigma_{VM_0}}{\\sigma_{VM}} = \\frac{1.106 \\times 10^7}{6.723 \\times 10^7} = 0.1645\\] The fatigue limit stress was determined to be 321.617 MPa through the calculation of Marin\u0026rsquo;s factors.\n\\[n_{Goodman} = \\frac{1}{\\frac{\\sigma_a}{S_e} \u0026#43; \\frac{\\sigma_m}{S_u}} = 8.355\\\\ \\\\ \\\\ n_{Yield} = \\frac{1}{\\frac{\\sigma_a \u0026#43; \\sigma_m}{S_y}} = 11.482\\\\\\] For a 25% overload (1.25 times the load) occurring 10% of the time and taking a factor of f = 0.858 figure 6-18 of Shigley\u0026rsquo;s Mechanical Design book\n\\[\\sigma = \\frac{1.25 \\times \\sigma_a}{1 - \\frac{1.25 \\times \\sigma_m}{S_{ut} \\times 10^6}} = 3.51 \\times 10^7 \\, \\text{Pa}\\] \\[a = \\frac{(f \\times S_{ut})^2}{S_e \\times 10^6} = 3.35 \\times 10^9\\] \\[b = -\\frac{1}{3} \\times \\log \\left( \\frac{f \\times S_{ut}}{S_e \\times 10^6} \\right) = -0.391\\] \\[\\text{Cycles} = \\left( \\frac{\\sigma}{a} \\right)^\\frac{1}{b} = 1.17 \\times 10^5 \\text{cycles}\\] 2.4. Finite Element Analysis # 2.4.1. Beam Analysis # For the analysis of the resilient beam using finite element methods, the commercial software Solidworks was employed. The numerical model comprises a simply supported beam on the two hinges of the plate to be bolted to the winch\u0026rsquo;s head, with a load of 27.6 kN applied at the geometric location where the winch car wheels would be. The beam\u0026rsquo;s self-weight is also considered.\nIn terms of the developed stresses, at the neutral axis (which in this case is the centroidal axis), the Von Mises equivalent stress is zero or close to zero, as expected. It is also inferred that the highest stresses exist at the outermost fibers of the section, where there is a maximum tensile stress in the lower outer fiber and a compressive stress in the upper outer fiber.\nBoth these stresses are considerably lower than the material\u0026rsquo;s yield stress, ensuring the specified safety factor.\nThe maximum deflection due to loading measures 9.584 mm and is positioned at the midpoint of the beam span. Comparing this with the analytically obtained deflection of 11.5 mm, there is a relative error of 16.7%. This error arises from the consideration of internal reinforcements within the beam and, simultaneously, from the boundary conditions not being applied at the beam ends but rather at the hinge point.\n2.4.2. Assembly Analysis # For the analysis of stresses arising from a bolted connection, a finite element model was developed, considering only half of the beam due to symmetry effects. The resilient beam is connected to a rigid plate via a bolted connection. The applied load is 26.7 kN, and the beam\u0026rsquo;s self-weight is also accounted for in the simulation.\nBoundary conditions involve restricting rotation and translation at the lower base of the plate to which the beam is bolted, and considering symmetry in the beam, allowing for the modeling of only half of it.\nFor defining the connection at each bolt, a pre-load of 50900 N was specified, corresponding to an M36 bolt of grade 10.6.\nThe highest Von Mises equivalent stresses are located near the bolt head regions, measuring around 323 MPa, ensuring the mechanical strength criteria specified for the project.\nAdditionally, this model presents maximum stresses at the hole edge of the bolted plate, which increase as the mesh around it becomes finer. In this scenario, the existence of a geometric singularity (an edge without area) leading to very high stresses was considered. However, this singularity was disregarded in the analysis.\nThe maximum deflection in the deformed configuration of the beam was 4.27 mm, approximately half of the deflection obtained in the previous finite element model (simply supported beam).\n2.5. Welded Joint # In this section, the aim is to study the welded connection of the internal forces within the beam and the welded connection of the bolted fixation plates along with the welding between the plates.\nThe intention is to analyze the welded connection concerning static, yield, and fatigue aspects. Both components to be welded are made of the same material (AISI 1095 HR Steel).\n2.5.1 External Welding # The welding performed has a height, h, of 5 mm. Therefore, the throat height, a, is such that \\(a = \\frac{h}{\\sqrt{2}} = 3.54 \\text{mm} \\) .\nThe procedure for calculating the weld beads in the three cases is similar, involving the computation of the unit second moment of area (Ju), the moment of inertia (Is) and the weld area (As). For the calculation of the unit second moment of area for more complex sections, it is feasible to compute it by dividing the section into several rectangles and selecting the appropriate expression from the table (Table 9-1 and 9-2 in Shigley\u0026rsquo;s book) corresponding to the specific case.\n\\[J_u = \\frac{b \\times d^2}{2} = \\frac{10 \\times 0.17642^2}{2 \\times 2} = 0.1556 \\text{m}^3\\] Given this information, the moment of inertia is determined by the product of the throat height, denoted as a, and the unit second moment of area:\n\\[J = J_u \\times a = 5.501 \\times 10^{-4} \\text{m}^4\\] As outlined in Table 9.1 in Shigley\u0026rsquo;s book, the formula for the throat area is expressed as follows:\n\\[A_s = 0.707 \\times h \\times d = 0.707 \\times 20 \\times 0.005 = 0.0707 \\text{m}^2\\] With this data, it is possible to calculate the primary shear stress:\n\\[\\tau_V = \\frac{F}{A_s} = \\frac{31350}{0.0707} = 4.43 \\times 10^5 \\text{Pa}\\] In the study of secondary shear stress, the component attributed to the torsional moment and the bending moment is calculated, with the former being represented by the following expression.\n\\[\\tau_T = \\frac{T_c}{J} = \\frac{2250 \\times 0.082}{5.501 \\times 10^{-4}} = 3.608 \\times 10^5 \\text{Pa}\\] In the case of secondary shear stress due to the bending moment, it is given that:\n\\[\\tau_M = \\frac{M_r}{I} = \\frac{131660 \\times 5}{\\frac{10^3}{6} \\times 0.0035} = 1.116 \\times 10^6 \\text{Pa}\\] Hence, the summation of each of these components enables the assessment of the stress value induced by the moments.\n\\[\\tau_{MT} = \\tau_M \u0026#43; \\tau_T = 1.116 \\times 10^6 \u0026#43; 3.608 \\times 10^5 = 1.478 \\times 10^6 \\, \\text{Pa}\\] By calculating the total stress induced by the moments and the shear force, it is concluded that:\n\\[\\tau = \\sqrt{\\tau_{MT}^2 \u0026#43; \\tau_V^2} = \\sqrt{1.478 \\times 10^6 \u0026#43; 4.43 \\times 10^5} = 1.543 \\times 10^6 \\, \\text{Pa}\\] To conclude the study of welded connections between the vertical and horizontal plates, it is proposed to evaluate the static safety coefficient and compare it with the initially defined value using the Pugsley method (n = 2.08). This comparison aims to verify if the obtained value surpasses the initially set one.\n\\[\\text{Nestatica} = \\frac{0.4 \\times S_y}{\\tau} = \\frac{0.4 \\times 460 \\times 10^6}{1.543 \\times 10^6} = 119.25\\] OK!\n2.5.2 Internal Welding # It was mentioned that the purpose of the internal vertical reinforcements is to prevent localized deformation of the beam when subjected to the forces resulting from the equipment\u0026rsquo;s operational regime. They also serve as a means to provide additional stiffness to the box beam. The shear stresses present in the two webs of the box beam, during loading and translation of the beam, could lead to detrimental localized deformations affecting the equipment. It was recommended that vertical transverse reinforcements should also be applied to areas where the beam is supported and bolted to the \u0026ldquo;headstock\u0026rdquo;.\nAccording to the CMAA (Crane Manufacturers Association of America) specification for overhead cranes, the spacing between vertical reinforcements should not exceed:\n\\[a = \\frac{350}{\\sqrt{v} \\times t} = \\frac{350}{\\sqrt{0.333} \\times 0.3937} \\approx 6065.5 \\text{mm}\\] a: Spacing between vertical reinforcements (in) v: Maximum shear stress in the section (ksi) - 2.3E6 Pa = 0.333 ksi t: Thickness of the beam\u0026rsquo;s web (in) - 10 mm It was determined to install 11 reinforcements along the length of the beam, with two of them acting as caps to seal the structural section.\nThe welding of internal reinforcements is similar to that of welding between vertical and horizontal plates, with a height, h, of 5mm. Therefore, the throat height, a, is such that ar = \\(\\frac{h}{sqrt{2}}\\) = 3.54 mm.\nThe radius:\n\\[𝑟 = \\sqrt{\\left(\\frac{0.5}{2}\\right)^2 \u0026#43; \\left(\\frac{0.1564}{2}\\right)^2} = 0.261 \\, \\text{m}\\] Replacing in the stress calculation:\n\\[\\tau_{\\text{T}} = \\frac{2250 \\times r}{J_{\\text{u}} \\times ar} = \\frac{2250 \\times 0.261}{0.00354 \\times \\frac{0.5 \\times \\left(3 \\times 0.1564^2 \u0026#43; 0.5^2\\right)}{6}} = 6.186 \\times 10^6 \\, \\text{Pa}\\] In the case of stresses due to transverse force:\n\\[\\tau_{\\text{V}} = \\frac{F}{A} = \\frac{31350}{0.00354 \\times (2 \\times 0.5)} = 8.867 \\times 10^6 \\, \\text{Pa}\\] The calculation of the angle between the stresses caused by the torsional moment and the transverse force involved using the following expression:\n\\[\\cos \\theta = \\frac{0.25}{r} = 0.954 \\Rightarrow \\theta = \\cos^{-1}(0.954) = 0.303 \\, \\text{rad} = 17.378^\\circ\\] The expression used to calculate the angle between the stresses caused by the torsional moment and the transverse force was applied for substitution into the equation used to determine the resultant.\n\\[\\tau_{\\text{C}} = \\tau_{\\text{R}} = \\sqrt{\\tau_{\\text{T}}^2 \u0026#43; \\tau_{\\text{V}}^2 \u0026#43; 2\\tau_{\\text{T}}\\tau_{\\text{V}}\\cos(2\\theta)} = 1.439 \\times 10^7 \\, \\text{Pa}\\] For the safety factor calculation:\n\\[n_e = \\frac{0.4 \\times S_y}{\\tau_{\\text{C}}} = \\frac{0.4 \\times 460 \\times 10^6}{1.439 \\times 10^7} = 12.788\\] Based on this value, it is concluded that it exceeds the previously established value, prompting to conduct a further study of this welded joint.\n2.5.3. Bolted Joint Welding # For the study of the welded joint in the bolted fixing plate, I was considering a weld bead height of h = 10mm — higher than previously assigned in the previous welded joint to ensure a higher safety margin. As mentioned before, with more complex sections, it is necessary to divide them into more uniform and simpler sections. To do this, using tables 9-1 and 9-2 of Shigley\u0026rsquo;s Mechanical Design book were consulted to extract the values of Ju and Iu, respectively.\nsdam dakoo \\[I_u = \\frac{0.244^3}{6} \u0026#43; 2 \\times \\frac{0.08^3}{6} \u0026#43; \\frac{0.5964 \\times 0.26^2}{2} \u0026#43; 2 \\times \\frac{0.180 \\times 0.244^2}{2} = 0.0335 \\, \\text{m}^3\\] \\[J_u = \\frac{0.5964^3}{6} \u0026#43; 2 \\times \\frac{0.180^3}{6} \u0026#43; \\frac{0.244 \\times 0.180^2}{2} \u0026#43; 2 \\times \\frac{0.008 \\times 0.26^2}{2} = 0.0418 \\, \\text{m}^3\\] Similarly to the calculations for previous welded joints:\n\\[\\tau_{\\text{MT}} = \\tau_{\\text{T}} \u0026#43; \\tau_{\\text{M}} = \\frac{131775 \\times 0.13}{\\frac{0.0335}{\\sqrt{2}} \\times 0.01} \u0026#43; \\frac{2250 \\times \\fra{0.5964}{2}}{\\frac{0.0418}{\\sqrt{2}} \\times 0.01}\\] For the primary shear stress, it is critical to compute the applied shear force as well as the throat area of the weld:\n\\[F = 1150 \\times 5 \u0026#43; 26700 = 32475 N \\, \\\\ P_s = 2 \\times 0.5964 \u0026#43; 2 \\times 0.244 \u0026#43; 4 \\times 0.18 \u0026#43; 4 \\times 0.008 = 2.4328 m \\, \\\\ A_s = 0.707 \\times h \\times P_s = 0.707 \\times 0.101 \\times 2.4328 = 0.0172 m^2 \\, \\\\ \\tau_V = \\frac{F}{A_s} = \\frac{32475}{0.0172} = 1.89 \\times 10^6 \\, \\text{Pa} \\, \\\\\\] Calculating the total stress due to moments and shear force:\n\\[\\tau = \\sqrt{\\tau_{MT}^2 \u0026#43; \\tau_V^2}\\] To conclude, let\u0026rsquo;s evaluate the safety factor in this static corner weld and compare it with the value initially defined via the Pugsley method (n = 2.08) to verify if indeed the obtained value is higher.\n\\[n_{\\text{static}} = \\frac{0.4 \\times S_y}{\\tau} = \\frac{0.4 \\times 460 \\times 10^6}{7.468 \\times 10^7} = 2.464\\] It is OK! ✔️\nThis value isn\u0026rsquo;t far from the initially assigned one, also being the lowest among all the welded joints. Therefore, moving on to the fatigue design, assessing the safety factor, which is expected to decrease. This conditions will be verified whether it still holds true — where the fatigue design of the weld bead on the plate to be bolted to the head is the determining factor. In the fatigue analysis, both mean and alternating load components are considered.\n\\[M_{alt} = \\frac{131775 - 27970}{2} = 51902.5 \\, \\text{Nmm} \\, \\\\ M_{med} = \\frac{131775 \u0026#43; 27970}{2} = 79872.5 \\, \\text{Nmm} \\, \\\\ T_{alt} = \\frac{2250 - (2300 \\times 0.0842)}{2} = 1028.2 \\, \\text{Nmm} \\, \\\\ T_{med} = \\frac{2250 \u0026#43; (2300 \\times 0.0842)}{2} = 1221.8 \\, \\text{Nmm} \\, \\\\ F_{alt} = \\frac{32475 - (1155 \\times 5 \u0026#43; 2300)}{2} = 12200 \\, \\text{N} \\\\ F_{med} = \\frac{32475 \u0026#43; (1155 \\times 5 \u0026#43; 2300)}{2} = 20275 \\, \\text{N}\\] Using a similar methodology as employed in the static design calculation but incorporating alternating and mean components, it results:\n\\[\\tau_{M_{\\text{alt}}} = \\frac{M_{\\text{alt}} \\times 0.13}{I} \u0026#43; \\frac{T_{\\text{alt}} \\times \\frac{0.5964}{2}}{J} = \\frac{51902.5 \\times 0.13}{\\frac{0.0335}{\\sqrt{2}} \\times 0.01} \u0026#43; \\frac{1028.2 \\times \\frac{0.5964}{2}}{\\frac{0.0418}{\\sqrt{2}} \\times 0.01}\\] \\[\\tau_{M_{\\text{med}}} = \\frac{M_{\\text{med}} \\times 0.13}{I} \u0026#43; \\frac{T_{\\text{med}} \\times \\frac{0.5964}{2}}{J} = \\frac{79872.5 \\times 0.13}{\\frac{0.0335}{\\sqrt{2}} \\times 0.01} \u0026#43; \\frac{1221.8 \\times \\frac{0.5964}{2}}{\\frac{0.0418}{\\sqrt{2}} \\times 0.01}\\] For the calculation of direct shear stress:\n\\[\\tau_{V_{alt}} = \\frac{F_{\\text{alt}}}{A_s} = \\frac{12200}{0.0172} = 7.092 \\times 10^5 \\, \\text{Pa}\\] \\[\\tau_{V_{med}} = \\frac{F_{\\text{med}}}{A_s} = \\frac{20275}{0.0172} = 1.179 \\times 10^6 \\, \\text{Pa}\\] For calculating the total stress due to moments and shear force:\n\\[\\tau_{\\text{alt}} = 1.5 \\sqrt{\\tau_{M_{alt}}^2 \u0026#43; \\tau_{V_{alt}}^2} = 4.43 \\times 10^7 \\, \\text{Pa}\\] \\[\\tau_{\\text{med}} = 1.5 \\sqrt{\\tau_{M_{med}}^2 \u0026#43; \\tau_{V_{med}}^2} = 6.77 \\times 10^7 \\, \\text{Pa}\\] The minimum-to-maximum stress ratio was obtained using the following equation:\n\\[R = \\frac{\\tau_{\\text{Mmed}} - \\tau_{\\text{Malt}}}{\\tau_{\\text{Mmed}} \u0026#43; \\tau_{\\text{Malt}}} = 0.208\\] The minimum stress is never zero because there will always be a certain associated weight, either from the weight of the beam itself or from the load imposed by the winch car. To conclude, let\u0026rsquo;s calculate the safety factor values according to the Goodman criterion and the yield criterion. For this, it is important to define the fatigue limit stress using the Marin factors.\nHence:\nSe\u0026rsquo; = 0.5 \\(\\times\\) 830 = 415 MPa \\(Ka = a \\times S_{ut}^{-b} = 0.702\\) (hot rolled) Kb = 1 Kc = 0.59 (considering shear) Kd = 1 (operating at room temperature) Ke = 1 (reliability at 50%) Kf = 1 (corrosion and other factors neglected) Therefore, obtaining a fatigue limit stress of Se = 172 MPa. \\[n_{\\text{Goodman}} = \\frac{1}{\\frac{\\tau_{\\text{med}}}{S_e} \u0026#43; \\frac{\\tau_{\\text{alt}}}{\\frac{2}{3}S_{ut}}} = \\frac{1}{\\frac{67.7}{172} \u0026#43; \\frac{44.3}{\\frac{2}{3} 830} = 2.111 \\, \\\\ \\\\\\] \\[n_{\\text{Yield}} = \\frac{\\frac{1}{\\sqrt{3}} \\times S_y}{\\tau_{\\text{alt}} \u0026#43; \\tau_{\\text{med}}} = 2.37\\] 2.6. Bolted Joint # The study will proceed with the bolted joint in terms of static and yielding analysis. The components to be bolted are two AISI 1095 HR steel plates, each with a thickness of 10mm. A total of 6 bolts are accounted for.\n2.6.1 Bolt Load # To calculate the tensile force in the bolts furthest away, P can be determined as follows:\n\\[P = \\frac{M \\times s}{\\sum s_i} = \\frac{131775 \\times 191 \\times 10^{-3}}{0.117366} = 214449 N\\] note\ns is the distance from the farthest bolt to the hinge line. In this case, there won\u0026rsquo;t be any shear force on the bolts since there\u0026rsquo;s no torsion in the plane perpendicular to the bolts.\n2.6.2 Bolt Selection # To select the bolts, an iterative process with rapid convergence was used. It began with an initial estimate of C (joint stiffness constant) equal to 0.35. Following this, the maximum preload force 𝐹𝑖 was calculated to determine the minimum stress area value.\n\\[F_b = \\frac{C \\times n_b \\times P}{\\frac{1}{\\chi} - 1} = 399768 \\, \\text{N} \\\\\\] Given \\(\\chi\\) = 0.75 for non-permanent connections and \\(n_b\\) = 2.\n\\[F_{\\text{comb}} = n_{\\text{comb}} \\left( \\frac{P_s}{f_m} \u0026#43; (1 - C)P \\right) = 247475 \\, \\text{N} \\\\\\] In this case, there are no shear forces on the bolts, so Ps = 0.\n\\[F_i = \\max{F_{\\text{b}}, F_{\\text{comB}}} = 399768 \\, \\text{N} \\\\\\] \\[A_{t_{min}}} = \\frac{F_i}{\\chi \\times S_p} = 642 \\, \\text{mm}^2 \\\\\\] Since these bolts will be structural components, class 10.9 was chosen, corresponding to a proof load Sp = 830 MPa. With the obtained value of \\(A_{t_{min}}\\) , resulting from table 8-1 of Shigley\u0026rsquo;s Mechanical Design book, it is feasible to determine the nominal diameter that meets the minimum area requirement. In this case, at least an M36 bolt will be required.\nBolt d (mm) At (mm²) Ar (mm²) P (mm) Sp (MPa) Su (MPa) M36x4 36 817 759 4 830 1040 Next, C is recalculated, and the compliance with the safety factor is verified. The threaded length of the bolt can be calculated as follows:\n\\[LT = 2 \\times d \u0026#43; 6 = 78 mm (L \u0026lt; 125mm) \\\\\\] Having the concern of having threads in only one of the two plates to avoid stress concentrations, the bolt length should be 90mm, resulting in lt = 90-78 = 12mm of unthreaded portion within the 20mm of engagement (two 10mm plates). Consequently, the threaded engagement length will be ld = 20-12 = 8 mm. The unthreaded area corresponds to:\n\\[A_d = \\frac{\\pi \\times d^2}{4} = 1017.36 \\, \\text{mm}^2 \\\\\\] Thus, obtaining the following stiffness values:\n\\[k_b = \\frac{A_d \\times A_t \\times E}{A_d \\times l_t \u0026#43; A_t \\times l_d} = 9.728 \\times 10^9 \\\\\\] \\[k_m = \\frac{0.5744 \\times p_i \\times E \\times d}{2 \\times \\left( \\frac{5 \\times (0.5774 \\times l \u0026#43; 0.5 \\times d)}{0.5774 \\times l \u0026#43; 2.5 \\times d}\\right)} = 18.3 \\times 10^9 \\\\\\] It is now possible to calculate the joint stiffness:\n\\[C = \\frac{k_b}{k_b\u0026#43;k_m} = 0.347 \\\\\\] The proof force is given by \\(F_p = S_p \\times A_t\\) = 678110 N, and the preload force can now be obtained as \\(F_i = F_p \\times \\chi\\) = 508582.5 N. The static and combined safety factors are determined through the following calculation:\n\\[n_{\\text{est}} = \\frac{F_p - F_i}{C \\times P} = 2.54 \\\\\\] \\[n_{\\text{comb}} = \\frac{F_i}{\\frac{P_s}{f_m} \u0026#43; (1 - C) \\times P} = 4.11 \\\\\\] The combined safety factor, in this case, is equivalent to the separation safety factor of the joint since \\(P_s\\) = 0. The slip safety factor is also not applicable for the same reason, as there is no slipping.\ninfo\nAll safety factors are higher than the design safety factor. Thus, the bolts used in the joint are verified accordingly. ✔️ 3 Considerations \u0026amp; Future Tasks # Undertaking a project like this can raise awareness of the complexities involved in designing and analyzing structural or mechanical equipment. Such an experience often encourages seeking information from standards and technical documentation, fostering an investigative approach to problem-solving throughout the project.\nI consider it was a great opportunity to develop problem-solving skills and an analytical \u0026ndash; investigative mindset.\nFor future work, I would say there are several potential avenues to explore:\nexample\nRefinement and Optimization: Consider refining the design further for enhanced efficiency or cost-effectiveness.\nFailure Analysis: Explore potential failure modes and conduct a failure analysis to anticipate weaknesses or stress points that might arise during operation. This could involve simulations or in-depth theoretical studies.\nMaterial and Manufacturing Improvements: Investigate alternative materials or manufacturing techniques that might enhance the performance, durability, or ease of production of the designed equipment.\nReal-World Implementation: If possible, observe or participate in the implementation or assembly of the designed structure or equipment to gain practical insights and refine future designs based on real-world constraints. In this case, it was considered for industry used, but a generalization could also be implemented for other use cases.\nEnvironmental and Sustainability Considerations: Consider incorporating sustainability features into the design or assessing the environmental impact of the equipment. This could involve materials sourcing, energy efficiency, or end-of-life considerations.\n..and that is all I could think of!\n"},{"id":11,"href":"/docs/2code/5od/_index3/","title":"Particle Swarm Optimization","section":"Evolutionary Computation","content":" Introduction # "},{"id":12,"href":"/docs/2code/1drone/_index4/","title":"Drone Controller Design Pt. 2","section":"UAV Red Bull Air Racing","content":" Phase 3. Amazing Race \u0026amp; Crazy 8 # tip\nIf you wish to skip the theoretical and implementation details, please click here to jump to the summarized findings Ch. 8 - Amazing Race. I have cool images! ✌️ 1 Continuing from Phase 2\u0026hellip; # In the final phase of the project, a more practical approach was adopted to tackle the problem. Discrete controllers and observers were designed for the drone, with simulations implemented to test it in a highly realistic environment. This involved using provided tracks and fine-tuning controllers to minimize following errors while maintaining optimal speed without causing critical destabilization.\n2 Discrete Time Linearized Model # As previously indicated, the drone model can be segmented into four subsystems. Among these, the yaw and vertical axis subsystems are second-order.\n\\[\\dot{X}(t) = \\begin{bmatrix} 0 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \\\\ \\end{bmatrix} X(t) \u0026#43; \\begin{bmatrix} b \\\\ 0 \\\\ \\end{bmatrix} u(t)\\] The longitudinal and lateral axis subsystems are fourth order.\n\\[\\dot{X}(t) = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; g \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ \\end{bmatrix} X(t) \u0026#43; \\begin{bmatrix} b \\\\ 0 \\\\ 0 \\\\ 0 \\\\ \\end{bmatrix} u(t)\\] The discretization of a continuous time state space model only affects the A and B matrices. The resultant discretized A and B matrices are computed as shown in the following equations:\n\\[\\bar{A} = e^{A^T} = \\mathcal{L}^{-1}(sI - A)^{-1}\\] \\[\\bar{B} = \\int_{0}^{T} e^{A\\tau} B \\, d\\tau \\quad \\text{T : Sample Time}\\] The discretized second order state space models are, therefore, given:\n\\[X(k \u0026#43; 1) = \\begin{bmatrix} 1 \u0026amp; 0 \\\\ T \u0026amp; 1 \\\\ \\end{bmatrix} X(k) \u0026#43; \\begin{bmatrix} bT \\\\ b \\frac{T^2}{2} \\\\ \\end{bmatrix} u(k)\\] The discretized fourth order state space models are:\n\\[X(k \u0026#43; 1) = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ T \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ g T^2/2 \u0026amp; gT \u0026amp; 1 \u0026amp; 0 \\\\ gT^3/6 \u0026amp; gT^2/2 \u0026amp; T \u0026amp; 1 \\\\ \\end{bmatrix} X(k) \u0026#43; \\begin{bmatrix} bT \\\\ bT^2/2 \\\\ bgT^3/6 \\\\ bgT^4/24 \\\\ \\end{bmatrix} u(k)\\] To derive the discrete models mentioned, the c2d command was utilized in MATLAB. This command was applied to the state-space model generated via the ss command. A zero-order hold was implemented at the input of the continuous system, and a sample time of 0.01s was assumed. Computing the poles of the obtained discrete models can be obtained:\n\\[\\left|zI - \\bar{A}\\right| = 0\\] This figure displays the root locus concerning the second and fourth-order discrete systems. As anticipated, all poles are positioned at z = 1, aligning with the system\u0026rsquo;s marginal stability where its poles were situated at s = 0 in continuous time.\nIn earlier project sections, the system underwent analysis regarding its controllability and observability. With the current focus on a discrete model, the evaluation extends to its reachability — confirming the system\u0026rsquo;s capability to transition from any initial state to any final state through a finite actuation sequence. Additionally, observability is scrutinized to determine if it\u0026rsquo;s feasible to ascertain the initial state from observing the system output within a specified time interval.\nTwo other pertinent properties are controlability, assured if reachability is established, and reconstructability, ensured if observability is confirmed. These aspects collectively contribute to understanding and manipulating the system in its discrete form. To assess the reachability of the system, it\u0026rsquo;s essential to calculate the rank of the reachability matrix.\n\\[\\text{rank} \\left(\\bar{B} \\bar{A} \\bar{B} \\ldots \\bar{A}^{n-2} \\bar{B} \\bar{A}^{n-1} \\bar{B}\\right) = n\\] For the second and fourth order systems, the rank of the reachability matrix is given by:\n\\[\\text{rank} \\begin{bmatrix} bT \u0026amp; bT \\\\ b\\frac{T^2}{2} \u0026amp; 3b\\frac{T^2}{2} \\\\ \\end{bmatrix} = 2 \\quad \\forall T \u0026gt; 0\\] \\[\\text{rank} \\begin{bmatrix} bT \u0026amp; bT \u0026amp; bt \u0026amp; bt \\\\ b\\frac{T^2}{2} \u0026amp; 7b\\frac{T^2}{2} \u0026amp; 5b\\frac{T^2}{2} \u0026amp; 3b\\frac{T^2}{2} \\\\ bg\\frac{T^3}{6} \u0026amp; 37bg\\frac{T^3}{6} \u0026amp; 19bg\\frac{T^3}{6} \u0026amp; 7bg\\frac{T^3}{6} \\\\ bg\\frac{T^4}{24} \u0026amp; 175b\\frac{T^4}{24} \u0026amp; 65b\\frac{T^4}{24} \u0026amp; 5b\\frac{T^4}{8} \\\\ \\end{bmatrix} = 4 \\quad \\forall T \u0026gt; 0\\] Reachibility ✔️\nTo determine the observability of the system, it\u0026rsquo;s crucial to compute the rank of the observability matrix:\n\\[\\text{rank} \\begin{bmatrix} \\bar{C} \\\\ \\bar{C}\\bar{A} \\\\ \\bar{C}\\bar{A}^2 \\\\ \\ldots \\\\ \\bar{C}\\bar{A}^{n-1} \\\\ \\end{bmatrix}\\] For the second and fourth order systems, the rank of the observability matrix is given by:\n\\[\\text{rank} \\begin{bmatrix} 0 \u0026amp; 1 \\\\ T \u0026amp; 1 \\\\ \\end{bmatrix} = 2 \\quad \\forall T \u0026gt; 0\\] \\[\\text{rank} \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\\\ gT^3/6 \u0026amp; gT^2/2 \u0026amp; T \u0026amp; 1 \\\\ 4gT^3/3 \u0026amp; 2gT^2 \u0026amp; 2T \u0026amp; 1 \\\\ 9gT^3/2 \u0026amp; 9gT^2/2 \u0026amp; 3T \u0026amp; 1 \\\\ \\end{bmatrix} = 4 \\quad \\forall T \u0026gt; 0\\] Observability ✔️\n3 Controller Design # With the verification of reachability and observability properties, the stage is set for designing the necessary controllers and observers. Notably, based on preceding project findings, I opted against designing a controller via pole placement. I will explore two strategies: the discrete linear quadratic regulator (LQR) and the model predictive control (MPC), both extensively discussed and analyzed in subsequent sections.\ninfo\nIt\u0026rsquo;s worth noting that these two controllers employ slightly different design approaches. The LQR is specifically tailored for each of the subsystems outlined in the previous section, mirroring the approach taken with the continuous system. This direct strategy aligns with the existence of four independent subsystems and their corresponding references, essential for the drone\u0026rsquo;s tracking, considering that the roll and pitch variables are not directly controlled.\nIn contrast, the MPC considers the entire 12th order discretized system. The group\u0026rsquo;s design parameters necessitated the inclusion of roll and pitch variables in the system output for better drone stabilization. While this could have been achieved by modifying the previously presented subsystems, the MPC MATLAB toolbox\u0026rsquo;s graphical interface offered a more intuitive and convenient method to design the MPC for the entire system.\n3.1. Linear Quadratic Regulator # In the preceding phase, I presnted and executed the LQR in the continuous domain. Now, in this phase of the project, the discrete iteration of the LQR was implemented. The LQR inherently seeks an optimal controller capable of striking a balance between performance and minimizing actuation. It achieves this by aiming to minimize the discrete version of the performance index.\n\\[J = \\int_{0}^{\\infty} (x^T(t)Qx(t) \u0026#43; u^T(t)Ru(t)) \\, dt\\] Similar to the approach in the continuous domain, matrix Q penalizes state deviations from zero, while matrix R penalizes significant actuations. However, previously, the LQR values were primarily optimized for step responses, whereas, in this phase, the optimization targeted trajectory following, commencing with the straightforward square trajectory. Employing a trial-and-error method, the following values were selectedfor each subsystem:\n\\[Q_{\\text{vertical}} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 100 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0.01 \\\\ \\end{bmatrix} \\quad R_{\\text{vertical}} \\] \\[Q_{\\text{yaw}} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 10 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0.01 \\\\ \\end{bmatrix} \\quad R_{\\text{yaw}} \\] \\[Q_{\\text{longitudinal}} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0.1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0.1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 100 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\\\ \\end{bmatrix} \\quad R_{\\text{longitudinal}}\\] \\[Q_{\\text{lateral}} = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0.1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0.1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 100 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\\\ \\end{bmatrix} \\quad R_{\\text{lateral}}\\] 3.2. Model Predictive Control # The model predictive control (MPC) operates similarly to the LQR, employing an optimization approach for controller derivation. However, MPC integrates constraints within the optimization problem, addressing limitations concerning both actuation and state variables, including their respective rates of change.\nIn addition to imposed variable restrictions, MPC involves tuning two key parameters: the prediction horizon (Hp), dictating how far into the future the output is forecasted, and the control horizon (Hc), determining the prediction span for control actions. When both horizons tend to infinity, MPC\u0026rsquo;s behavior aligns with what would be achieved using an LQR.\nConcerning Hp tuning, a larger time interval generally enhances performance, but this can compromise MPC\u0026rsquo;s efficacy, particularly with smaller sample times. With a 0.01s sample time, performance issues were found. To align Hp closer to the system\u0026rsquo;s settling time, the computation time needed significantly exceeded the physical time available, rendering it impractical for real-time application. Hence, it was opted to reduce the MPC\u0026rsquo;s sample time to 0.1s, enabling real-time execution while maintaining good control performance.\nHp tuning significantly impacts MPC stability; it should be smaller than Hc for stability. Beyond this requirement, its value is determined through a trial-and-error process for optimal control results.\nConcerning actuation restrictions, the MPC considered physical limitations in the motors, as represented:\n\\[0 \u0026lt; u \u0026lt; 11.1 \\text{(V)}\\] warning\nThroughout this project, a prominent factor contributing to the unstable behavior of the nonlinear model was the significant tilt angle (pitch and roll) exhibited by the drone. Consequently, these restrictions were enforced within the MPC.\n−0.2 \u0026lt; pitch \u0026lt; 0.2 ✔️ −0.2 \u0026lt; roll \u0026lt; 0.2 ✔️\nThe weight allocated to each reference tracking error underwent a trial-and-error tuning process. It\u0026rsquo;s crucial to note that the highest weight was assigned to the vertical reference to prevent substantial altitude loss in the nonlinear model during lateral movements. This strategic allocation aimed to maintain stability and minimize altitude fluctuations during such maneuvers.\n4 Kalman Filter Design # In the ongoing phases of this project, it\u0026rsquo;s acknowledged that real-world measurements are inevitably corrupted by noise. Specifically for the drone, six independent measurements are assumed to be affected by white noise with known variances. As these noisy measurements can impact the drone\u0026rsquo;s performance, selecting an estimator to mitigate these effects becomes imperative. Consequently, I employed the Kalman filter for this purpose.\ninfo\nNotably, in this phase of the project, where the primary focus lies in achieving optimal results within more realistic scenarios, the discrete Luenberger observer was disregarded. Noise variances for Kalman Filter - (click to expand) Variable Noise Variance Px 7.3221e-4 Py 4.2829e-4 Pz 1.8000e-4 Roll 3.4817e-4 Pitch 2.6060e-4 Yaw 3.8313e-5 The matrix \\(Q_0\\) is a pivotal parameter in gauging the confidence in the model. Following a tuning process, the value below was selected.\n\\[Q_0 = I_{12} \\times 10^{-7}\\] The matrix \\(R_0\\) is related to how reliable are the measurements and contains the noise variances.\n\\[R_0 = \\begin{bmatrix} 7.32 \\times 10^{-4} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 4.28 \\times 10^{-4} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1.80 \\times 10^{-4} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 3.48 \\times 10^{-4} \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 2.60 \\times 10^{-4} \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 3.83 \\times 10^{-4} \\\\ \\end{bmatrix}\\] 5 Simulation # To evaluate the designed controllers, three distinct trajectories were selected: the simple square, the crazy 8, and the amazing race trajectories. While the waypoints forming these trajectories were provided, details such as the time instances for the drone to traverse each waypoint and the specific path geometry connecting these waypoints were left as design parameters to determine.\nIt is hoped to outline the methodology adopted to derive the ultimate trajectories implemented in the simulator. It is also shown the attained results and remarks on the drone\u0026rsquo;s behaviour throughout these trajectories, shedding light on its performance under different control schemes.\n5.1. Implementation # Two Simulink files — one for the LQR and another for the MPC — were created. The LQR implementation utilized relevant blocks, while the MPC and Kalman filter were integrated using available Simulink blocks.\nEfforts were made to ensure the simulator closely mimicked a real system. Consequently, both the linear and nonlinear models are continuous, while the LQR, MPC, and Kalman filter operate in discrete time. However, in practice, signals processed by discrete elements in a computer would consist of sampled points rather than the \u0026ldquo;stair-like\u0026rdquo; signals simulated using the zero-order hold.\nwarning\nDespite attempts to replicate this behaviour using a sampler block, the Simulink solver continued to produce \u0026ldquo;stair-like\u0026rdquo; signals. Nonetheless, this discrepancy does not invalidate the results obtained, as the discrete blocks only consider signals at each multiple of the sample time. This effect is likely related to limitations within the solver. Another crucial consideration is that the linearized model assumes a zero yaw angle. As the controllers were developed based on this assumption, the nonlinear model encounters issues when the yaw is not zero. To address this, a rotation about the z-axis must be applied to the output of the nonlinear model, as depicted in equation 24. This adjustment allows for the use of the same linear controllers, yielding satisfactory results even when the yaw is not zero in the nonlinear model.\n\\[\\dot{p} = \\begin{bmatrix} \\cos(\\psi) \u0026amp; -\\sin(\\psi) \u0026amp; 0 \\\\ \\sin(\\psi) \u0026amp; \\cos(\\psi) \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\\\ \\end{bmatrix} v\\] 5.2. Trajectories # The connection between provided waypoints requires a specified time function. At the minimum, this function must satisfy the values at both the beginning and end of the designated time interval, a requirement easily met by a rectilinear line.\nHowever, to ensure a smoother trajectory that the drone can follow with minimal error, additional conditions must be addressed. These conditions encompass specifying the velocity and acceleration at the initial and final time instants. This necessitates the use of third and fifth-order polynomials, respectively. A firth-order polynomial was chosen offering enhanced flexibility in shaping trajectories and ensuring smoother transitions between waypoints, critical for the drone\u0026rsquo;s trajectory tracking.\n\\[x(t) = a_5x^5 \u0026#43; a_4x^4 \u0026#43; a_3x^3 \u0026#43; a_2x^2 \u0026#43; a_1x \u0026#43; a_0\\] Each trajectory segment for every reference (including three coordinates and yaw) is described by a fifth-order polynomial. To achieve zero velocities and accelerations at the initial and final time instants, denoted as \\(t_i\\) and \\(t_f\\) , the following equation can be utilized:\n\\dot{x}(t_i) = \\dot{x}(t_f) = \\ddot{x}(t_i) = \\ddot{x}(t_f) = 0\nFor waypoints situated along a rectilinear section of the trajectory, constant velocities to enhance lap time were chosen. Consequently, in such cases, the fifth-order polynomial simplifies into a rectilinear line, offering a straightforward and efficient path between these waypoints.\nReference tracking for x,y,z and yaw for the Linear model with noise - (click to expand) example\nFor better understanding, the trajectories were exemplified. Beginning marked with green and end marked with a red. Simple Square Trajectory ✔️ Crazy 8 Trajectory ✔️ Amazing Race Trajectory ✔️ 5.3. 3D Virtual World # The incorporation of a 3D virtual world into Simulink facilitated real-time visualization of the drone\u0026rsquo;s movements. This block received position coordinates (x, y, z) along with pitch, roll, and yaw angles to visualize the drone\u0026rsquo;s orientation. Additionally, to enhance the visual representation, wing rotation was considered, factoring in the voltage applied to each motor.\nnote\n*Virtual world representation: Drone depicted at the origin, denoting its initial position. Notably, in this representation, the drone aligns with the x-axis forward, the y-axis to the right, and the z-axis downward, providing a clear orientation within the 3D virtual environment. In the integrated virtual environment, a grid composed of squares, each measuring 1 meter per side, aids in visualizing the drone\u0026rsquo;s movement in spatial terms. Moreover, adjustments were made to scale the drone\u0026rsquo;s size, enhancing its representation to reflect a more realistic proportion within the virtual world.\n6 LQR Results # During this phase, two potential outcomes were explored for each race trajectory, employing different dynamic models:\nLinear Model Nonlinear Model To ensure the realism and stability of the drone\u0026rsquo;s trajectories, certain restrictions were imposed on the LQR controller. These constraints aimed to create a more authentic representation of the drone\u0026rsquo;s behaviour and enhance stability. The constraints employed were as follows:\nActuation Values: Kept at or below 11.1 volts. Positional Errors: Restricted to remain consistently below 1 meter, while yaw error was constrained below 0.3 radians. Roll and Pitch Angles: Never allowed to exceed 0.8 radians (approximately 45 degrees) at any point throughout any trajectory. These constraints were integral not only to uphold the integrity of the project but also to simulate the behaviour of a real drone more accurately. However, the primary objective and overarching goal of this project remained to achieve the shortest possible time for each trajectory.\n6.1. Simple Square # In pursuit of achieving the lowest possible time for the simple square trajectory, the linear model was optimized to complete the path within 13 seconds, while the nonlinear model achieved a time of 12 seconds. It was aimed for 12 seconds as even a mere second holds substantial significance in a timed race scenario.\n6.1.1. Linear Model # In the linear model, the reference tracking displays high precision overall. However, when closely examined, minor oscillations become apparent in the tracking due to noise interference. This noise burdens the actuation, causing sporadic increases and creating an appearance of static. Nonetheless, our LQR and Kalman filter implementations effectively manage this, with the actuation peaking at around 10.1 Volts.\nReference tracking for x,y,z and yaw for the linear model - (click to expand) The biggest error was obtained on the vertical movement (z axis) and it was of about 0.7 meters.\nActuation (left) and errors (right) for the linear model - (click to expand) 6.1.2. Nonlinear Model # In the nonlinear model, significant discrepancies are evident in vertical position and yaw angle tracking. Although the tracking consistently returns to the reference, unexpected oscillations persist, leading to instability. Additionally, noise continues to impact actuation, peaking at around 10.4 Volts, despite eventual convergence to the reference trajectory.\nReference tracking for x,y,z and yaw for the nonlinear model - (click to expand) Actuation (left) and errors (right) for the nonlinear model - (click to expand) In comparison to the linear model, the errors in the nonlinear model appear more erratic but exhibit improved outcomes. Specifically, both lateral and vertical movements (y and z-axis) align more closely, reaching approximately 0.38 meters in matching discrepancies. The next table shows the constraint parameters values obtained for each model for the simple square.\nLQR - Simple Square Time (s) Position Error (m) Yaw Error (rad²) Maximum Roll (rad) Maximum Pitch (rad) Linear Model with Noise 13 0.1678 0.0008301 0.79 0.79 Non-Linear Model with Noise 12 0.211 0.001614 0.69 0.76 The table highlights that with increased model complexity, errors and maximum values for roll and pitch also increase. However, the goal remained to push the LQR and Kalman filter to their limits without compromising the constraints set initially, aiming for the lowest time travel of 12 seconds. It\u0026rsquo;s worth noting that achieving a shorter time travel implies higher velocities, leading to larger errors overall.\nThe following trajectory plots will showcase the reference, Linear Model, and Nonlinear Model for the Simple Square trajectory.\nFrom previous observation, it\u0026rsquo;s evident that the plots exhibit striking similarities, making it challenging to discern differences, ultimately indicating a successful tracking for the simple square trajectory.\n6.2. Crazy 8 # The Crazy 8 trajectory instructs the UAV to trace the shape of an \u0026ldquo;8,\u0026rdquo; divided by the center, ascending along the z-axis in the first half and descending in the second half.\n6.2.1. Linear Model # For the Linear model, a travel time of 17 seconds was assumed, yielding the following results.\nReference tracking for x,y,z and yaw for the linear model - (click to expand) Actuation (left) and errors (right) for the linear model - (click to expand) Both figures illustrate the substantial influence of noise on actuation, resulting in pronounced instability. However, the Kalman Filter demonstrates remarkable effectiveness in managing this noise, as evidenced by only slight oscillations in pitch. While minor deviations from the reference trajectory might be observable upon close inspection, one is generally content with the results for the \u0026ldquo;Crazy 8\u0026rdquo; trajectory using the Linear model. The maximum errors for the linear model consistently hover around similar values, with the z-axis recording the highest error at approximately 0.3 meters.\n6.2.2. Nonlinear Model # Acknowledging that the race will employ the nonlinear model, extensive iterations were conducted to seek the shortest possible time for the trajectory. Ultimately, these efforts resulted in reducing the time travel by one second for the nonlinear model.\nReference tracking for x,y,z and yaw for the nonlinear model - (click to expand) Actuation (left) and errors (right) for the nonlinear model - (click to expand) Utilizing the Nonlinear model with noise, a 16-second trajectory duration was achieved. The drone showcased commendable reference tracking for longitudinal and lateral movements, though minor deviations were observed in vertical movement and yaw angle tracking.\nActuation spiked to the maximum constraint of 11 Volts due to noise-induced stress, enabling higher drone velocity for reduced travel time. However, this led to slightly less stable reference tracking, particularly in increased yaw angle oscillations. The roll and pitch exhibited differing behaviours compared to the linear model to accommodate nonlinear aspects.\nVertical movement displayed the highest discrepancy, reaching a maximum error of 0.5 meters.\nThe subsequent table outlines time values and constraints for each model during the Crazy 8 trajectory.\nLQR - Crazy 8 Time (s) Position Error (m) Yaw Error (rad²) Maximum Roll (rad) Maximum Pitch (rad) Linear Model 17 0.2833 0.006547 0.7 0.46 Non-Linear Model 16 0.3241 0.00794 0.69 0.56 note\nOne might question why the Nonlinear model achieved a lower time value, but examining the errors and actuation provides insight into this. In the LQR controller, aiming for better trajectory times results in increased errors as the drone needs to maneuver faster, leading to sharper turns, and consequently, higher pitch and roll values. Crazy 8: linear trajectory (left) and nonlinear (right) - (click to expand) 6.3. Amazing Race # The \u0026ldquo;Amazing Race\u0026rdquo; trajectory is designed for maximum speed through waypoints, mirroring real drone movements. Despite my efforts to optimize time while adhering to constraints, even reducing the time by one second risks violating one or all constraints. Testing revealed a minimum travel time of 60 seconds for both models. Following the Amazing Race section, a table will detail the constraint parameter values observed during this trajectory.\n6.3.1. Linear Model # Reference tracking for x,y,z and yaw for the linear model - (click to expand) Actuation (left) and errors (right) for the linear model - (click to expand) Once more, the LQR demonstrates precise tracking along the Amazing Race trajectory. However, spikes persist in the actuation, induced by the LQR\u0026rsquo;s continuous adjustments to counter noise-induced changes. Despite these spikes, none of the constraints are breached, with the maximum actuation spike recorded at approximately 10 Volts. The complexity of the task led to more erratic error behavior, although overall results remained satisfactory, with the maximum error reaching around 0.4 rad² for the yaw angle.\n6.3.2. Nonlinear Model # Reference tracking for x,y,z and yaw for the nonlinear model - (click to expand) Actuation (left) and errors (right) for the nonlinear model - (click to expand) In the Nonlinear model, deviations start surfacing during reference tracking, causing occasional slight drifts from the reference, although the drone ultimately reconverges to it. Despite this, the overall tracking throughout the trajectory remains relatively accurate. However, mitigating these deviations would entail increasing the drone\u0026rsquo;s travel time, yet in a race, every second counts. Additionally, the maximum values for roll and pitch noticeably escalate. A reduction of just one second along the path could surpass the 0.8 rad (45º) constraint, leading to the drone\u0026rsquo;s descent—something bound to avoid.\nRegarding actuation, the expected pattern persists, with a spike reaching around 10 Volts. The errors between the Linear and Nonlinear models showcase similar trends, with lateral and vertical movements being the primary offenders, reaching a maximum error of approximately 0.4 meters.\nThe subsequent table presents the constraint parameter values for each model studied during the Amazing Race trajectory.\nLQR - Amazing Race Time (s) Position Error (m) Yaw Error (rad²) Maximum Roll (rad) Maximum Pitch (rad) Linear Model 60 0.1509 0.005645 0.48 0.7 Non-Linear Model 60 0.1613 0.005131 0.74 0.67 Amazing Race: linear trajectory (left) and nonlinear (right) - (click to expand) note\nAs depicted, the plots exhibit a similar overall shape but manifest differences throughout the trajectory. Notably, in the second-to-last curve, the reference demands a sharp turn from the drone. However, the designed controller struggles to match this curve precisely, causing the drone to execute a wider turn instead. Despite this, our thorough waypoint checks along the path lead us to consider this Amazing Race with a 60-second travel time a resounding success! 7 MPC Results # 7.1. Simple Square # 7.1.1. Linear Model # In selecting a 25-second duration for the Simple Square trajectory, maintaining this duration was crucial to minimize errors and uphold tracking accuracy. The Linear model showcased commendable reference tracking, as illustrated. The image indicates precise reference tracking by the drone, while also adhering to the constraints for pitch and roll.\nReference tracking for x,y,z and yaw for the linear model - (click to expand) From the actuation plot, it is observed the admissible limits and the maximum position error is near 0.6 meters.\nActuation (left) and errors (right) for the linear model - (click to expand) 3D Trajectory for the linear model - (click to expand) 7.1.2. Nonlinear Model # The Nonlinear model exhibited reference tracking akin to the Linear model, maintaining accurate tracking and adhering to the constraints. However, there were slight variations observed in the pitch and roll, displaying slightly more variability compared to the Linear model.\nReference tracking for x,y,z and yaw for the nonlinear model - (click to expand) From the actuation plot, it is observed the admissible limits and the maximum position error almost the same as in the linear model near 0.6 meters, however in the nonlinear model it can be seen a local maximus that wasn\u0026rsquo;t not detected in the linear model.\nActuation (left) and errors (right) for the nonlinear model - (click to expand) 3D Trajectory for the nonlinear model - (click to expand) MPC - Simple Square Time (s) Position Error (m) Yaw Error (rad^2) Linear Model 25 0.1682 0.0002414 Non-Linear Model 25 0.1908 0.0002915 7.2. Crazy 8 # 7.2.1. Linear Model # A duration of 35 seconds was selected for the Crazy 8 trajectory utilizing MPC. Once more, commendable reference tracking was observed, and the constraints for the angles remained effective. Additionally, there were no motor saturations, with the maximum actuation reaching approximately 8.2 Volts. The maximum error recorded was 0.5 meters.\nReference tracking for x,y,z and yaw for the linear model - (click to expand) From the actuation plot, it is observed the admissible limits and the maximum position error is near 0.6 meters.\nActuation (left) and errors (right) for the linear model - (click to expand) 3D Trajectory for the linear model - (click to expand) 7.2.2. Nonlinear Model # The Nonlinear model similarly yielded positive outcomes. Reference tracking remained accurate, maintaining constraints within the angles. Additionally, there were no instances of motor saturation, with the maximum actuation reaching around 8.4 Volts. The maximum error observed was 0.6 meters.\nReference tracking for x,y,z and yaw for the nonlinear model - (click to expand) Actuation (left) and errors (right) for the nonlinear model - (click to expand) 3D Trajectory for the nonlinear model - (click to expand) MPC - Crazy 8 Time (s) Position Error (m) Yaw Error (rad^2) Linear Model 35 0.2485 0.001326 Non-Linear Model 35 0.2866 0.001438 7.3. Amazing Race # 7.3.1. Linear Model # In the case of the largest track, a lap time of 90 seconds was opted for using MPC. While reducing the time was possible, it would inevitably lead to errors surpassing acceptable values. Throughout this duration, reference tracking remained commendable, with a maximum error of 0.6 meters. No motor saturation was observed. Figures 34 and 35 illustrate the tracking, actuation, errors, and trajectory. Additionally, Figure 36 displays the 3D trajectory of the linear model.\nReference tracking for x,y,z and yaw for the linear model - (click to expand) Actuation (left) and errors (right) for the linear model - (click to expand) 3D Trajectory for the linear model - (click to expand) 7.3.2. Nonlinear Model # The outcomes for the Nonlinear model remain positive. Reference tracking sustained its accuracy, adhering to constraints within the angles. Additionally, no motor saturation was noted, with the maximum actuation reaching approximately 8.5 Volts. The maximum error recorded was 0.8 meters.\nReference tracking for x,y,z and yaw for the nonlinear model - (click to expand) Actuation (left) and errors (right) for the nonlinear model - (click to expand) 3D Trajectory for the nonlinear model - (click to expand) MPC - Amazing Race Time (s) Position Error (m) Yaw Error (rad^2) Linear Model 90 0.2182 0.003338 Non-Linear Model 90 0.252 0.003468 8 Amazing Race # In this phase, the goal was exploring drone modeling, controller design, and trajectory racing. The initial phase focused on acquiring the drone\u0026rsquo;s complete and linearized models under hovering conditions, with varied success in initial controller attempts.\nIn the subsequent phase, emphasis shifted towards controller design using pole placement and LQR methodologies, alongside studying sensor noise effects and employing the Kalman filter. Results improved notably, especially with the Kalman filter\u0026rsquo;s advantage in simulating measurement noise. A preliminary attempt at navigating a more complex trajectory also yielded promising outcomes.\nThe third phase introduced a more realistic scenario, implementing controllers and observers in discrete time.\nTests mirrored real-world scenarios, with actual trajectories used for simulations and a competitive aspect to achieve optimal results based on accumulated knowledge.\nControllers based on optimization methods (LQR and MPC) were prioritized, while the pole placement method and Luenberger estimator were discarded due to their suboptimal performance, especially in the presence of noise.\nTrajectories emerged as critical design parameters, impacting performance significantly. Results showed a consistent trade-off: achieving faster travel times increased velocities, leading to larger errors — a finding consistent across both controllers. Broadly, the LQR consistently delivered faster times across all trajectories. Conversely, the MPC facilitated a more stable drone behaviour by incorporating constraints on roll and pitch values. Detailed results are outlined in the table below.\nNonlinear LQR Position Error (m) LQR Yaw Error (rad^2) LQR Time (s) MPC Position Error (m) MPC Yaw Error (rad^2) MPC Time (s) Simple Square 0.2110 0.001614 12 0.1908 0.0002915 25 Crazy 8 0.3241 0.00794 16 0.2866 0.001438 35 Amazing Race 0.1613 0.005131 60 0.2520 0.003468 90 Using the MATLAB graphical interface for MPC design led to a potential loss of sensitivity when fine-tuning it. Consequently, the MPC might hold untapped potential not fully explored in this project, presenting an area for further improvement and exploration.\ntip\nAdvance to UAV Computer Vision Here ✌️ "},{"id":13,"href":"/docs/1design/4mcomp/","title":"FEM Software Development","section":"Design Portfolio","content":" Finite Element Method: A Virtual Tetris # 1 DIY: A FEA Playground # tip\nIf you wish to skip the theoretical and implementation details, and would like to know my thoughts on attempting to code a finite element method software or alternatively develop a SDK for existing SW, please click here to jump to the summarized findings Ch. 4 - My Considerations. 1.1. Partial Differential Equations (PDEs) # In engineering and physics, problems are often described by partial differential equations (PDEs). The \u0026ldquo;strong form\u0026rdquo; refers to the original differential equation that must hold exactly throughout the domain, including both the governing equation and the boundary conditions.\nHowever, there are cases where directly solving the strong form might be challenging due to complexities in the equation, irregular geometries, or varying boundary conditions. This is where the \u0026ldquo;weak formulation\u0026rdquo; or (\u0026ldquo;weak form\u0026rdquo;) becomes advantageous.\nThe weak form introduces a relaxation of the constraints imposed by the strong form by multiplying the governing equation with a weight function (typically a test function) and integrating it over the domain. This relaxation allows for more flexibility in solution techniques and offers several advantages:\nHandling Boundary Conditions: The weak form often simplifies the imposition of different types of boundary conditions.\nSolvability: Some differential equations in the strong form might not have exact solutions or might be difficult to solve directly. The weak form can lead to a more manageable equation for numerical methods.\nAdaptability to Numerical Methods: Finite element, boundary element, and other numerical methods are often more easily applied to weak formulations due to the integral nature of the equations.\nHandling Discontinuities: In problems involving discontinuities or singularities, the weak form can handle these cases more effectively.\nMinimization of Requirements: In some cases, the requirement for differentiability or the number of times an equation needs to be differentiated is reduced, easing computational complexity.\nOverall, the weak form is favoured in many situations because it relaxes the strictness of the original problem while maintaining the essential properties required for solutions, making it more adaptable for various solution techniques, especially in numerical analysis.\n1.2. Strong Form # Let\u0026rsquo;s begin by establishing the strong formulation of the problem, which serves as the foundation of our problem. In this formulation, we encapsulate the fundamental differential equation governing the system\u0026rsquo;s behaviour. This equation, along with the precise boundary conditions and initial values, constitutes the direct representation of the underlying physical laws guiding the system\u0026rsquo;s dynamics.\n\\[\\theta - \\nabla \\cdot (k \\nabla u) = f\\] For the torsional loading problem k = 1 and f = 2. The following equations indulge:\n\\[\\frac{\\partial^2 \\phi}{\\partial x^2} \u0026#43; \\frac{\\partial^2 \\phi}{\\partial y^2} = - 2G \\theta\\] This is referring to the Prandtl stress function, which defines shear stresses as:\n\\[\\tau_{xz} = \\frac{\\partial \\phi}{\\partial y} \\text{ and } \\tau_{yz} = \\frac{\\partial \\phi}{\\partial x}\\] The resolution of a torsion problem involves solving the Prandtl equation by imposing the boundary condition around the entire perimeter of the figure, as is known:\n\\[\\phi = 0\\] To do this, the Prandtl function is divided by \\(G\\theta\\) , considering this value is not known, as follows in the next set of expressions:\n\\[\\frac{\\partial^2 \\psi}{\\partial x^2} \u0026#43; \\frac{\\partial^2 \\psi}{\\partial y^2} = - 2 \\text{ and } \\psi = \\frac{\\phi}{G \\theta}\\] \\[\\tau_{yz} = -G \\theta \\frac{\\partial \\psi}{\\partial x} \\text{ and } \\tau_{xz} = G \\theta \\frac{\\partial \\psi}{\\partial y}\\] The developed program will calculate the solution given by \\(\\psi\\) for each node, the shear stresses, and the value of torsional rigidity. The problem of \\(G \\theta\\) is solved using the formula:\n\\[G \\theta = \\frac{Mt}{J}\\] In the previous formula, the M (torsional moment) and t (thickness) take the value of 1.\n1.3. Weak Form # The weak form enables transforming the differential equation into an integral equation, where the initial approach involves integrating the equation across the entire domain. Rules are applied to obtain the weak form, namely, defining the residual by multiplying it with an arbitrary function, integrating by parts the highest-order term, and rearranging the equation. Thus:\n\\[\\iint_S \\frac{\\partial \\phi_i}{\\partial x} \\frac{\\partial \\phi_j}{\\partial x} \u0026#43; \\frac{\\partial \\phi_i}{\\partial y} \\frac{\\partial \\phi_j}{\\partial y} dA = \\iint_S 2\\phi_i dA\\] The stiffnex matrix is given by:\n\\[K_{ij} = \\iint_S \\frac{\\partial \\phi_i}{\\partial x} \\frac{\\partial \\phi_j}{\\partial x} \u0026#43; \\frac{\\partial \\phi_i}{\\partial y} \\frac{\\partial \\phi_j}{\\partial y} dx dy\\] Additionally, the load vector is presented as:\n\\[F_i = \\iint_S 2 \\phi_i dx dy\\] In the considered problem, the only essential boundary condition will be the null solution across the entire perimeter of the figure, accompanied by a distributed load of magnitude 2 applied across the entire mesh.\n1.4. Analytical Integration # Simplifying the problem\u0026rsquo;s resolution, only regular 4-node elements with 1 degree of freedom will be considered. Information from the book \u0026ldquo;Introduction to the Finite Element Method (3rd edition)\u0026rdquo; by J.N. Reddy provides the following details:\nStiffness matrix (e): \\(K^e = \\frac{k}{6ab} \\begin{bmatrix} 2(a^2\u0026#43;b^2) \u0026amp; a^2-2b^2 \u0026amp; -(a^2\u0026#43;b^2) \u0026amp; -2a^2\u0026#43;b^2\\\\ a^2-2b^2 \u0026amp; 2(a^2\u0026#43;b^2) \u0026amp; -2a^2\u0026#43;b^2 \u0026amp; -(a^2\u0026#43;b^2)\\\\ -(a^2\u0026#43;b^2) \u0026amp; -2a^2\u0026#43;b^2 \u0026amp; 2(a^2\u0026#43;b^2) \u0026amp; a^2-2b^2\\\\ -2a^2\u0026#43;b^2 \u0026amp; -(a^2\u0026#43;b^2) \u0026amp; a^2-2b^2 \u0026amp; 2(a^2\u0026#43;b^2)\\\\ \\end{bmatrix} \\) Load vector (e): \\(f^e =\\frac{fab}{4} \\begin{bmatrix} 1\\\\ 1\\\\ 1\\\\ 1\\\\ \\end{bmatrix} \\) Where \u0026lsquo;a\u0026rsquo; corresponds to the length of the base of the element, and \u0026lsquo;b\u0026rsquo; corresponds to the height of the element.\n1.5. Numerical Integration # These functions aim to calculate the elemental stiffness matrix using the Gauss-Jordan approximation, which simplifies integration to a summation. To achieve this, a coordinate transformation from \\((x,y)\\) to \\( (\\xi, \\eta) \\) is applied, while also computing the Jacobian of this transformation. Subsequently, the rules of Gauss points are employed.\nIn Gauss integration, the stiffness matrix K is computed through reduced integrals:\n\\[K_{ij} = \\frac{\\partial \\phi_i}{\\partial x} \\frac{\\partial \\phi_j}{\\partial x} \u0026#43; \\frac{\\partial \\phi_i}{\\partial y} \\frac{\\partial \\phi_j}{\\partial y} \\times J \\times w\\] \\[J = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi} \u0026amp; \\frac{\\partial x}{\\partial \\eta}\\\\ \\frac{\\partial y}{\\partial \\xi} \u0026amp; \\frac{\\partial y}{\\partial \\eta}\\\\ \\end{bmatrix} = \\frac{ab}{4}\\] In the previous Gauss integration, \u0026lsquo;w\u0026rsquo; corresponds to the integration weights. For a 1x1 integration, the integration is performed solely at the center of the element, with a weight of w = 1. For 2x1 or 1x2 integration, each \u0026lsquo;w\u0026rsquo; value represents the sum of 2 reduced integrals (2 different points within the element), and the weight is w=2. For a 2x2 integration, the summation includes 4 reduced integrals (4 different points), and w=1. The following values of \\(\\overline{x}\\) and \\(\\overline{y}\\) correspond to the Gauss points:\n\\[\\phi_1 = (1-\\frac{\\overline{y}}{b})(1-\\frac{\\overline{x}}{a}) \\quad \\quad \\phi_2 = \\frac{\\overline{x}}{a}(1-\\frac{\\overline{y}}{b})\\] \\[\\phi_3 = \\frac{\\overline{y}}{b}\\frac{\\overline{x}}{a} \\quad \\quad \\phi_4 = \\frac{\\overline{y}}{b}(1-\\frac{\\overline{x}}{a})\\] Consequently:\n\\[ \\text{1x1 Rule} : \\overline{x}=\\frac{a}{2} \\quad \\text{and} \\quad \\overline{y}=\\frac{b}{2}\\] \\[ \\text{2x2 Rule} : \\overline{x_{1,2}}=\\frac{a}{2}(1 \\pm \\sqrt{\\frac{1}{3}}) \\quad \\text{and} \\quad \\overline{y_{1,2}}=\\frac{b}{2}(1 \\pm \\sqrt{\\frac{1}{3}})\\] 1.6. Torsional Constant # After calculating the nodal solution, the torsion constant J can be determined by:\n\\[J^e = \\int_0^b \\int_0^a 2 \\psi^e dxdy = \\frac{ab}{2}(\\psi_1 \u0026#43; \\psi_2 \u0026#43; \\psi_3 \u0026#43; \\psi_4) \\qquad J = \\sum_i J_i^e\\] 1.7. Shear Stresses # \\[\\tau_{yz} = -G \\theta \\frac{\\partial \\psi}{\\partial x} = -G \\theta (\\frac{\\partial \\phi_1}{\\partial \\overline{x}}\\psi_1 \u0026#43; \\frac{\\partial \\phi_2}{\\partial \\overline{x}}\\psi_2 \u0026#43; \\frac{\\partial \\phi_3}{\\partial \\overline{x}}\\psi_3 \u0026#43; \\frac{\\partial \\phi_4}{\\partial \\overline{x}}\\psi_4)\\] \\[\\tau_{xz} = G \\theta \\frac{\\partial \\psi}{\\partial y} = G \\theta (\\frac{\\partial \\phi_1}{\\partial \\overline{y}}\\psi_1 \u0026#43; \\frac{\\partial \\phi_2}{\\partial \\overline{y}}\\psi_2 \u0026#43; \\frac{\\partial \\phi_3}{\\partial \\overline{y}}\\psi_3 \u0026#43; \\frac{\\partial \\phi_4}{\\partial \\overline{y}}\\psi_4)\\] \\[\\tau_{xy} = \\sqrt{\\tau_{yz}^2 \u0026#43;\\tau_{xz}^2}\\] 2 MATLAB: Time for some coding! # 2.1. READ_ME.md # The program starts by executing the script \u0026ldquo;MainG10.m\u0026rdquo; directly available on my github page and should contain all the subfunctions and their respective \u0026rsquo;txt\u0026rsquo; files in the respective folder. Once the program is initiated, the user inputs the data file name in the form of \u0026ldquo;nome.txt.\u0026rdquo; The data file should contain the node coordinates, connectivity matrix, and boundary conditions. The data file created for this problem is named \u0026ldquo;dadosg10.txt\u0026rdquo;.\nAfter submitting the data file, the program reads the file and automatically opens a figure displaying the mesh with numbered nodes and elements. Simultaneously, a menu with various options is displayed. The user should first choose the type of integration and then select the desired plots for shear stresses, stress contour lines, and nodal solutions. Submitting the options is done by entering the corresponding number. The program is terminated by entering the number 0.\nUpon program completion, a file is created containing the data obtained from the last integration performed.\nREMARK: The node numbering associated with a given element in the incidence matrix is done counterclockwise, as shown in the accompanying image. Any other numbering will yield incorrect results for solving this problem. The coordinates in the node matrix are in SI units, therefore in meters. Introducing values in different units in the data file will result in incorrect units in the final program output. The material conductivity or property should be 1; if it\u0026rsquo;s not, the results won\u0026rsquo;t be valid for this torsion problem. Regarding boundary conditions, only essential boundary conditions equal to zero are allowed. However, they will be set to zero if another finite value is associated. The distributed loading assumes the value 2; however, if the value differs, the program will still provide results—though they may not be reasonable for solving the initially presented problem. All other boundary conditions should be null, and if they\u0026rsquo;re not, an error message will be displayed.\n2.2. Validation Based on Book # The developed program has been tested for a known problem described in the book \u0026ldquo;Introduction to the Finite Element Method (3rd edition)\u0026rdquo; by J.N. Reddy - Example 8.5.6. In this example, torsion of a square section bar was considered. As the problem is axisymmetric, nodal solution and shear stresses were calculated for a quarter of the square. The following results were obtained at the nodes for the nodal solution, using a 4x4 mesh:\n\\[\\begin{bmatrix} x \u0026amp; y \u0026amp; \\text{Analytical} \u0026amp; \\text{Gauss 2x2} \u0026amp; \\text{Gauss 1x2} \u0026amp; \\text{Gauss 1x1} \u0026amp; \\text{Reddy} \\\\ 0.0000 \u0026amp; 0.0000 \u0026amp; 0.1492 \u0026amp; 0.1492 \u0026amp; 0.1501 \u0026amp; 0.1513 \u0026amp; 0.1492 \\\\ 0.1250 \u0026amp; 0.0000 \u0026amp; 0.1412 \u0026amp; 0.1412 \u0026amp; 0.1421 \u0026amp; 0.1429 \u0026amp; 0.1412 \\\\ 0.2500 \u0026amp; 0.0000 \u0026amp; 0.1161 \u0026amp; 0.1161 \u0026amp; 0.1168 \u0026amp; 0.1176 \u0026amp; 0.1161 \\\\ 0.3750 \u0026amp; 0.0000 \u0026amp; 0.0707 \u0026amp; 0.0707 \u0026amp; 0.0711 \u0026amp; 0.0714 \u0026amp; 0.0707 \\\\ 0.1250 \u0026amp; 0.2500 \u0026amp; 0.1103 \u0026amp; 0.1103 \u0026amp; 0.1110 \u0026amp; 0.1116 \u0026amp; 0.1103 \\\\ 0.2500 \u0026amp; 0.2500 \u0026amp; 0.0919 \u0026amp; 0.0919 \u0026amp; 0.0926 \u0026amp; 0.0935 \u0026amp; 0.0919 \\\\ 0.3750 \u0026amp; 0.2500 \u0026amp; 0.0573 \u0026amp; 0.0573 \u0026amp; 0.0577 \u0026amp; 0.0580 \u0026amp; 0.0573 \\\\ \\end{bmatrix}\\] The following results were obtained for \\(\\bar{\\tau_{yz}} = \\frac{\\tau_{yz}}{G\\theta} = \\tau_{yz} \\times J\\) for 4x4 mesh:\n\\[\\begin{bmatrix} x \u0026amp; y \u0026amp; \\text{Analytical} \u0026amp; \\text{Gauss 2x2} \u0026amp; \\text{Gauss 1x2} \u0026amp; \\text{Gauss 1x1} \u0026amp; \\text{Known Sol.} \\\\ 0.06250 \u0026amp; 0.0625 \u0026amp; 0.0618 \u0026amp; 0.0618 \u0026amp; 0.0621 \u0026amp; 0.0625 \u0026amp; 0.0618 \\\\ 0.1875 \u0026amp; 0.0625 \u0026amp; 0.1942 \u0026amp; 0.1942 \u0026amp; 0.1955 \u0026amp; 0.1970 \u0026amp; 0.1939 \\\\ 0.3125 \u0026amp; 0.0625 \u0026amp; 0.3529 \u0026amp; 0.3529 \u0026amp; 0.3553 \u0026amp; 0.3577 \u0026amp; 0.3516 \\\\ 0.4375 \u0026amp; 0.0625 \u0026amp; 0.5528 \u0026amp; 0.5528 \u0026amp; 0.5560 \u0026amp; 0.5593 \u0026amp; 0.5504 \\\\ \\end{bmatrix}\\] It\u0026rsquo;s observed that stiffness matrices obtained through analytical integration or Gauss 2x2 are closely aligned with the known values. In fact, the values from analytical integration and Gauss 2x2 are identical when approximated to 4 decimal places. The fewer points used in the Gauss integration, the greater the error, with Gauss 1x1 showing the largest discrepancy between obtained and known values. The largest relative error found in analytical integration and Gauss 2x2 was 0.436%. For Gauss 1x2 integration, the largest relative error was 1.05%, while Gauss 1x1 integration showed the largest relative error of 1.73%. Overall, the values are close to the known ones, indicating that the developed program is functioning correctly.\n3 Comparison with FEM commercial software Siemens NX # In addition, the problem was tackled by resorting to the commercial software NX, which unfortunately lacks a dedicated solver for torsion problems. As a workaround, the issue was addressed using the Sol 153 solver – Steady State Nonlinear Heat Transfer. This approach was selected due to the analogy between torsion and heat problems. Specific conditions were applied, including setting a boundary temperature at T = 0°C, introducing a uniform heat generation of 2 W/m³ throughout the section, and assigning a thermal conductivity value of K = 1 to the material. To compare results, the Prandtl function was solved using different integration methods in Matlab against the outcomes obtained through NX.\nThe data from the upcoming tables indicates that the minimum error occurs in the analytical integration type and in the numerical integration type with 2x2 Gauss points. As observed in the known problem, the error values are identical for these two integration types. It\u0026rsquo;s worth noting that in the 1x1 Gauss points integration, there is a considerable relative error percentage (15.2%), which decreases in the case of 2x1 (8.6%) and 1x2 Gauss points (4.84%)\n3.1. Analytical Integration # Maximum error deviation: 3,99501E-06%\n3.2. Gauss Integration 2x2 # Maximum error deviation: 3,99501E-06 %\n3.3. Gauss Integration 2x1 # Maximum error deviation: 8,605963869 %\n3.4. Gauss Integration 1x2 # Maximum error deviation: 4,839239833 %\n3.5. Gauss Integration 1x1 # Maximum error deviation: 15,19098164 %\n3.6. Torsion Coefficients NX vs. Matlab # The nodal solution values, node positions, and connectivity matrix data in NX were used to compute the torsion constant, J, akin to the calculations performed for J in the analytical or Gauss integrations in Matlab.\nCalculating the value of J for various refinements yielded:\n\\[\\begin{bmatrix} \\text{Number of nodes} \u0026amp; J \\text{computed from NX} (m^4) \\\\ 96 \u0026amp; 6.11911850 \\times 10^{-5} \\\\ 234 \u0026amp; 6.85679916 \\times 10^{-5} \\\\ 600 \u0026amp; 7.06099102 \\times 10^{-5} \\\\ 1765 \u0026amp; 7.13958341 \\times 10^{-5} \\\\ 4720 \u0026amp; 7.16633419 \\times 10^{-5} \\\\ 41461 \u0026amp; 7.18205027 \\times 10^{-5} \\\\ \\end{bmatrix}\\] For the considered 96 nodes:\n\\[\\begin{bmatrix} \\text{J NX} (m^4) \u0026amp; \\text{J Matlab} (m^4) \u0026amp; \\text{Relative Error} (\\%) \\\\ 6.1191185 \\times 10^{-5} \u0026amp; 6.11890982 \\times 10^{-5} \u0026amp; 3.41041 \\times 10^{-3} \\\\ \\end{bmatrix}\\] The conclusion drawn from these findings is that as the mesh undergoes refinement, the constant torsion value J tends to stabilize. It\u0026rsquo;s evident from these results that the approximation done by Matlab remains quite acceptable. This is highlighted by the fact that the J value derived from Matlab aligns closely with the analytical integration value and is also in close proximity to the J value computed in NX for 96 nodes, which itself approximates the converged value.\n3.7. Max and Min Stresses NX vs. Matlab # \\[\\begin{bmatrix} \\text{Stresses} \u0026amp; \\text{Matlab} \u0026amp; \\text{NX} \u0026amp; \\text{Relative Error} (\\%) \\\\ \\text{Maximum (Pa)} \u0026amp; 1279.447 \u0026amp; 1279.404 \u0026amp; 3.40677E-03 \\\\ \\text{Minimum (Pa)} \u0026amp; 25.790852 \u0026amp; 25.789972 \u0026amp; 3.41135E-03 \\\\ \\end{bmatrix}\\] The comparison between the results from Matlab (analytical integration) and NX led to the conclusion that quite satisfactory outcomes were attained. It was observed that the relative error obtained for the extreme values falls within the order of \\(10^{-3}\\) in percentage.\n3.8. Results Siemens NX # The initial mesh comprises 96 nodes. The mesh underwent 5 refinements to analyze the convergence of values. The results for the temperature distribution and gradient distribution are presented below for the six meshes, respectively on the left and right sides.\nMeshing in NX Siemens: Initial Mesh - (click to expand) Lastly, the 41468 nodes are represented for the final mesh refinement.\nMeshing in NX Siemens: Final Mesh - (click to expand) 3.9. Results MATLAB # When the program is executed, it generates several figures such as the mesh representation with numbered elements and nodes, the contour lines representing stress, and the display of shear stresses with their respective distribution.\nElements and Nodes of the Mesh Shear Stress Ditribution Shear Stress Contour Plot Nodal Solution: Analytical Integration Isometric View: Stress Isolines The nodal solution values, distribution of shear stresses, value of J, and torsional stiffness were, in addition, also obtained from the analytical integration, as reported.\nMinimum stress of 1.28 \\(\\times 10^{3}\\) Pa: (x,y) = (2.0 \\(\\times 10^{-1}\\) , 1.1 \\(\\times 10^{-1}\\) ) m Minimum stress of 2.58 \\(\\times 10^{1}\\) Pa: (x,y) = (2.4 \\(\\times 10^{-1}\\) , 9.0 \\(\\times 10^{-2}\\) ) m Torsion cofficient J: 6.11 \\(\\times 10^{-5} Pa \\cdot m^4\\) Torsional stiffness GJ: 4.65 \\(\\times 10^{6} Pa \\cdot m^4\\) To calculate GJ, the torsional stiffness, simply multiply the torsion coefficient J by the shear modulus, typically around 76 GPa.\n4 My Considerations # While the current analysis has demonstrated promising alignment between the NX and Matlab outputs, future endeavours could focus on enhancing the model\u0026rsquo;s precision and expanding its applicability.\nThe reason for choosing MATLAB over other programming languages was mainly due to the fact that at this time I was most proficient with using MATLAB \u0026ndash; not being so confident in my skills in regards to other languages. Nonetheless, while developing the Finite Element Method (FEM) software in MATLAB, I encountered several limitations that made me reconsider the choice of programming language. MATLAB, with its user-friendly environment and extensive libraries, initially seemed suitable for rapid prototyping and algorithm testing. However, as the project progressed, certain factors became evident that might have been better addressed using alternatives such as: C++.\nMATLAB\u0026rsquo;s interpreted nature, though convenient for quick code iterations, posed performance concerns as the simulations scaled. The compiled nature of C++ would have offered better performance optimization, crucial for handling large datasets and computationally intensive FEM calculations. Control over memory management and low-level operations in C++ would have allowed for fine-tuning algorithms and achieving higher efficiency in handling complex simulations.\nMoreover, MATLAB\u0026rsquo;s portability requirements often necessitated the distribution of MATLAB Runtime or Compiler for deployment on other systems (let alone requirements). In contrast, C++ offers inherent portability, allowing for easier cross-platform compatibility without additional runtime dependencies.\nWhile MATLAB\u0026rsquo;s user-friendliness is remarkable (honestly, most people should implement it and surely would rise up to the same outcome), after a brief web searching, I found that dedicated FEM libraries in C++, such as deal.II, DUNE, and libMesh, provide specialized tools for FEM simulations, offering robust solvers, mesh generation capabilities, and a community-driven framework specifically tailored for such applications. Are they really capable? I am not sure.\nIn retrospect, considering the computational demands, performance optimizations, and scalability required for the FEM software, implementing it in C++ might have offered a more efficient and scalable solution, despite MATLAB\u0026rsquo;s initial ease of use, adequacy to simple cases and rapid development capabilities.\nHowever\u0026hellip;\nInstead of embarking on independent software development, I also explored alternative avenues. For instance, my experience with electron beam technology highlighted the crucial need for simulating phenomena within a vacuum chamber \u0026ndash; extremely low pressures. I discovered existing Software Development Kits tailored precisely for this purpose. Prominent software packages like ANSYS and COMSOL Multiphysics offer simulations that encompass this specific phenomenon.\nThis approach would have potentially offered a balanced solution, combining the advantages of a robust, commercially supported framework with the customization required for such project. However, it\u0026rsquo;s essential to consider licensing costs and the level of customization achievable within the confines of these SDKs compared to developing from scratch in MATLAB or C++. As obviously, you are somehow restricted..\n5 Future Work # As for attempting to improve my MATLAB model, I would probably steer in the following direction:\nexample\nValidation with Experimental Data: Conducting experiments or obtaining real-world data to validate the computational findings could strengthen the model\u0026rsquo;s reliability.\nComplex Geometries and Material Variations: Expanding the study to encompass more complex geometries and diverse material properties can broaden the application scope of the torsion problem solution.\nParametric Studies: Conducting parametric studies to evaluate the impact of various parameters (such as material properties, dimensions, or loading conditions) on the torsional behavior can provide deeper insights.\nIntegration of Advanced Techniques: Exploring the integration of advanced numerical methods or simulation techniques could improve the computational efficiency and accuracy of the analysis.\n"},{"id":14,"href":"/docs/2code/5od/hamiltonian/","title":"Fortran: Hamiltonian Graphs","section":"Evolutionary Computation","content":" Introduction # "},{"id":15,"href":"/docs/1design/5om/","title":"Car Transmission Design","section":"Design Portfolio","content":" The Manual Gear Train Blueprint # 1 Normal Gear Train Composed of Cylindrical Gears # tip\nIf you wish to skip the theoretical and implementation details, please click here to jump to the summarized findings Ch. 4 - You Spin Me Right Round. 1.1. Functionality # A gearbox is used when different values of torque and rotational speed are desired from one shaft (input shaft) to another (output shaft). This is achieved through the combination of gears of different sizes. A gearbox can also reverse the direction of rotation, causing the output shaft to rotate in the opposite direction to the input shaft.\n1.2. Description # This gear train consists of four shafts: the engine shaft, the output shaft, the counter shaft, and a dummy shaft. All gears are cylindrical with straight teeth and are constantly engaged. The study focuses solely on the gear train and not on its driving method, assuming the engine shaft to be driven by any type of motor.\nThe input shaft has only one gear, meshed with another gear connected to the counter shaft, transmitting motion to it. The counter shaft has a total of four gears: two corresponding to first and second speeds, and another for reverse gear.\nThe gears for first and second speeds are engaged with gears connected to the output shaft via bearings, allowing them to rotate independently of the output shaft. There are two engagement sleeves on the output shaft that rotate in synchronization with it.\nFirst and second speeds are achieved by meshing one of the engagement sleeves with a component linked to one of these gears supported by bearings, causing the gears on the output shaft and the engagement sleeve to rotate together. By engaging the engagement sleeve, linking the counter shaft to the output shaft via the gear connected to the engagement sleeve, and the gear linked to the counter shaft, the output shaft is connected to the counter shaft.\nThe third speed is obtained by meshing one of the engagement sleeves with a component linked to the engine shaft, directly linking the engine shaft to the output shaft.\nFor engaging reverse gear, the engagement sleeve meshes with a component linked to a gear, similar to first and second speeds. To achieve this, one of the gears connected to the counter shaft meshes with a gear linked to the dummy shaft. This dummy shaft has another gear that meshes with the gear linked to the output shaft via bearings, and this gear is connected to the component with which the engagement sleeve meshes.\nThe presence of the dummy shaft causes the direction of rotation in reverse gear to be opposite to that of the engine shaft.\n1.3. Mechanism # In this design of a compound normal gear train - a gearbox with 4 gears including reverse, the rotational speed of the output shaft depends on a multiplication of transmission from various sets of gears. Among the components that make up the transmission is the synchronizer, whose function is to synchronize the rotations of gear pairs to allow precise engagement of the desired gear when in motion.\nnote\nIn this project, synchronizers were not designed, so shifting between the various gears will have to be done with the gearbox elements stationary. 1.3.1. Neutral Gear # In this case, none of the gear sleeves is connected to a gearwheel, therefore, there is no power transmission from the countershaft to the output shaft.\n1.3.2. First Gear # In this situation, one of the gear sleeves is connected to gearwheel 9, linking the countershaft to the output shaft and enabling power transmission to the output shaft. In this scenario, the transmission ratio between the motor shaft and the output shaft is 3.333.\n1.3.3. Second Gear # In this case, one of the gear sleeves is connected to gearwheel 8, linking the countershaft to the output shaft and enabling power transmission to the output shaft. In this situation, the transmission ratio between the motor shaft and the output shaft is 2.4.\n1.3.3. Third Gear # In this situation, one of the gear sleeves directly connects the motor shaft to the output shaft, enabling power transmission to the output shaft. In this case, the transmission ratio between the motor shaft and the output shaft is 1.\n1.3.4. Reverse Gear # In this case, one of the gear sleeves is connected to gearwheel 10, linking the countershaft to the output shaft, enabling power transmission to the output shaft. In this situation, the rotation of the output shaft is in the opposite direction to that of the motor shaft. The transmission ratio between the motor shaft and the output shaft is -3.333.\n2 Available Alternatives Analysis # For the transmission to be designed, a comparison among the various gearbox options available in the market is necessary. There are three possible solutions:\nSliding-gear transmission: In this type, the gear wheels of the output shaft mesh with those of the countershaft as per the speed requirements. Both the output shaft and the countershaft gear wheels are mobile. This is the oldest method.\nFixed-gear transmission: All gear wheels are engaged based on transmission ratios. The gear wheels of the output shaft are supported by bearings and engagement is achieved through gear sleeves.\nEpicyclic (planetary) gear transmission: In this type of gearbox, control over the two input speeds is managed by the sun gear and the ring gear. For consecutive gear sets, there is a connection between the planet carrier of one set and the ring gear of the other. The speeds of the ring gears are controlled at a transmission control station. This method is utilized in automatic transmissions in automobiles.\nThese three options offer different mechanisms for achieving gear engagement and transmission control, each with its own advantages and applications. The choice among them would depend on the specific requirements and functionalities needed for the project at hand.\nexample\nSee below for the comparison between the sliding-gear, fixed-gear and epicyclic-gear. Aspect Sliding-gear Fixed-gear Epicyclic-gear Epicycloidal Fixed Gears Bad Good Good Speed of Changes Bad Neutral Good Compactness Bad Good Good Wear Damage Bad Good Good Possibility of Helical Teeth Bad Good Good Smoothness of Changes Bad Neutral Good Complexity Level Very good Good Neutral Repair Ease Good Good Neutral Robustness Neutral Good Good Cost Good Good Neutral A decision to opt for a fixed-gear transmission over an epicyclic gearbox based on the provided table seems well-reasoned. The simplicity of fixed-gear transmissions compared to the complexity of epicyclic gearboxes usually results in lower costs. Epicyclic gearboxes, being more intricate, generally lead to increased expenses due to the need for a longer project study period, assembly time, and the creation of a transmission control station. The epicyclic gearbox would require an electro-mechanical control station, whereas the others would be operated solely mechanically.\nBoth fixed and sliding-gear transmissions would likely have similar design and assembly costs since their components are more common and less intricate compared to the epicyclic gearbox.\nUltimately, the decision to choose a fixed-gear transmission aligns with the design\u0026rsquo;s objectives of cost efficiency and simpler implementation, considering the complexities and associated costs of the alternatives.\n3 Design Calculations # Let\u0026rsquo;s proceed considering the requirements provided. To determine the gear parameters based on the specified transmission ratios, it is possible to continue calculating the gear teeth for each gear ratio.\nFirst gear: Reduction of 3.333 Second gear: Reduction of 2.4 Third gear: Ratio of 1 Reverse gear: Reduction of -3.333 (rotation in the opposite direction) These values were extracted from a deep dive into manual transmission design forum.\nCenter distance between shafts: 70 mm Pitch diameter of the first gear: 60 mm Standard module (M): 2 Real pressure angle: α = 20º All gears are external and in contact with each other are lubricated with light mineral oil 3.1. Characteristics of the Gear Wheel # To calculate the number of teeth (Z1) of the first gear, the formula for the gear ratio of a pair of gears can be used:\n\\[\\text{Gear ratio} = \\frac{Z_1}{Z_2} = \\frac{N_1}{N_2} = \\frac{D1}{M} = \\frac{60}{2} = 30\\] Crown diameter ( \\(D_a\\) ) for the first gear: \\[D_{a1} = D1 \u0026#43; 2M = 60 \u0026#43; 2 \\times 2 = 64 mm\\] Root diameter ( \\(D_f\\) ) for the first gear: \\[D_{f1} = D1 - 2.5M = 60 - 2.5 \\times 2 = 55 mm\\] Base diameter ( \\(d_b\\) ) for the first gear: \\[d_{b1} = D1 \\times cos(\\alpha) = 60 \\times cos(20º) \\approx 56.3816 mm\\] Angular pitch ( \\(p_{ang}\\) ) for the first gear: \\[p_{ang1} = \\frac{2 \\times \\pi}{z_1} = \\frac{2 \\times \\pi}{30} approx 0.2094º\\] 3.2. Characteristics of the Gear Tooth # Tooth height (h) for the first gear: \\[h_{1} = h_{a1} \u0026#43; h_{f1} = 2.25 \\times M = 2.25 \\times 2 = 4.5 mm\\] Addendum ( \\(h_a\\) ) for the first gear: \\[h_{a1} = M = 2 mm\\] Deddendum ( \\(h_f\\) ) for the first gear: \\[h_{f1} = 1.25 \\times M = 2.5 mm\\] Root clearance ( \\(j\\) ) for the first gear: \\[j_1 = h_{f1} - h_{a1} = 0.25 \\times M = 0.25 \\times 2 = 0.5 mm\\] Circular pitch ( \\(p\\) ) for the first gear: \\[p_1 = \\pi \\times M = \\pi \\times 2 = 6.283 mm\\] Tooth thickness ( \\(s\\) ) and tooth space ( \\(e\\) ) for the first gear: \\[s_1 = e_1 = 0.5 \\times p_1 = 0.5 \\times 6.283 = 3.142 mm\\] Tooth gap ( \\(g\\) ) for the first gear: \\[g_1 = p_1 - 2 \\times s_1 = 6.283 - 2 \\times 3.142 = 0 mm\\] Diameter pitch ( \\(Pd\\) ) for the first gear: \\[Pd_1 = \\frac{1}{M} = \\frac{1}{2} = 0.5 mm^{-1}\\] It\u0026rsquo;s possible to calculate the parameters of the other gears using similar formulas to those applied previously for the first gear. Based on the given transmission ratios and specifications regarding the tooth profile, it\u0026rsquo;s feasible to calculate characteristics of the other gears, such as number of teeth, diameters, tooth height, angular pitch, among others. The next figure represents a diagram of the gear assembly.\n3.3. Gear Train Parameters # Thus:\nGear E1 E2 E3=E5=E6=E7 E4 E8=E10 E9 Z 30 40 20 25 50 45 D (mm) 60 80 40 50 100 90 Da (mm) 64 84 44 54 104 94 Df (mm) 55 75 35 45 95 85 db (mm) 56.382 75.175 37.578 46.985 93.970 84.572 pang (º) 0.2094 0.1571 0.3142 0.2513 0.1257 0.1396 h (mm) 4.5 4.5 4.5 4.5 4.5 4.5 ha (mm) 2 2 2 2 2 2 hf (mm) 2.5 2.5 2.5 2.5 2.5 2.5 j (mm) 0.5 0.5 0.5 0.5 0.5 0.5 p (mm) 6.283 6.283 6.283 6.283 6.283 6.283 g (mm) 0 0 0 0 0 0 s=e (mm) 3.142 3.142 3.142 3.142 3.142 3.142 Pd (1mm) 0.5 0.5 0.5 0.5 0.5 0.5 3.3.1. Extra Calculations # Center distance between shafts: \\[a_{12} = \\frac{D1 \u0026#43; D2}{2} = \\frac{60 \u0026#43; 80}{2} = 70 mm\\] \\[a_{38} = \\frac{D3 \u0026#43; D8}{2} = \\frac{40 \u0026#43; 100}{2} = 70 mm\\] \\[a_{49} = \\frac{D4 \u0026#43; D9}{2} = \\frac{59 \u0026#43; 90}{2} = 70 mm\\] \\[a_{57} = \\frac{D5 \u0026#43; D7}{2} = \\frac{40 \u0026#43; 40}{2} = 40 mm\\] \\[a_{7,10} = \\frac{D7 \u0026#43; D10}{2} = \\frac{40 \u0026#43; 100}{2} = 70 mm\\] 3.3.2. First Gear # Representative diagram of the gear assembly for the 1st gear ratio:\nIntermediate transmission ratio: \\(i_{12}\\) = -1.333 \\[i_{12} = - \\frac{D_2}{D_1} = - \\frac{80}{60} = -1.3333 \\] Intermediate transmission ratio: \\(i_{38}\\) = -2.5 \\[i_{38} = - \\frac{D_8}{D_3} = - \\frac{100}{40} = -2.50\\] Transmission ratio in the 1st gear: \\(i_{18}\\) = 3.3333 \\[i_{18} = i_{12} \\times i_{38} \\Rightarrow i_{18} = \\frac{n_1}{n_8} = 3.3333 \\] \\[n_8 = n_{\\text{output}} = \\frac{n_{\\text{input}}}{i_{18}} = \\frac{n_{\\text{input}}}{3.3333} \\] The rotational speed for the output shaft in the 1st gear is 3.(3) times lower than the rotational speed of the motor shaft.\n3.3.3. Second Gear # Representative diagram of the gear assembly for the 2nd gear ratio:\nIntermediate transmission ratio: \\(i_{12}\\) = -1.333 \\[i_{12} = - \\frac{D_2}{D_1} = - \\frac{80}{60} = -1.3333 \\] Intermediate transmission ratio: \\(i_{49}\\) = -1.8 \\[i_{38} = - \\frac{D_9}{D_3} = - \\frac{90}{50} = -1.80\\] Transmission ratio in the 2nd gear: \\(i_{19}\\) = 2.4 \\[i_{19} = i_{12} \\times i_{49} \\Rightarrow i_{19} = \\frac{n_1}{n_9} = 2.4\\] \\[n_9 = n_{\\text{output}} = \\frac{n_{\\text{input}}}{i_{19}} = \\frac{n_{\\text{input}}}{2.4} \\] As expected, the rotational speed of the output shaft in the 2nd gear will be higher than the speed of the output shaft in the 1st gear - an increase in the number of rotations, yet still 2.4 times lower than the rotational speed of the motor shaft.\n3.3.3. Third Gear # Since the defined transmission ratio is 1, as both shafts are connected by the gear sleeve, it can be concluded that the input shaft speed will be equal to the output shaft speed.\n\\[n_{\\text{input}} = n_{\\text{output}}\\] 3.3.3. Reverse Gear # Representative diagram of the gear assembly for the reverse gear ratio:\nFor the gear associated with the reverse gear, it\u0026rsquo;s important to consider the transmission provided by the countershaft that assists in reversing the direction. The transmission can be calculated as follows\nIntermediate transmission ratio: \\(i_{12}\\) = -1.333 \\[i_{12} = - \\frac{D_2}{D_1} = - \\frac{80}{60} = -1.3333 \\] Intermediate transmission ratio: \\(i_{56}\\) = -1 \\[i_{56} = - \\frac{D_6}{D_5} = - \\frac{40}{40} = 1\\] Intermediate transmission ratio: \\(i_{49}\\) = -1.8 \\[i_{7,10} = - \\frac{D_10}{D_7} = - \\frac{100}{40} = -2.5\\] Transmission ratio in the 2nd gear: \\(i_{19}\\) = 2.4 \\[i_{1,10} = i_{12} \\times i_{56} \\times i_{7,10} \\Rightarrow i_{1,10} = \\frac{n_1}{n_10} = -3.3333\\] \\[n_10 = n_{\\text{output}} = \\frac{n_{\\text{input}}}{i_{1,10}} = - \\frac{n_{\\text{input}}}{3.3333} \\] The output shaft rotates at a speed 3.(3) times slower than the motor shaft, mirroring the observation in the 1st gear. The negative sign signifies a reversal in the output shaft\u0026rsquo;s rotation direction compared to the motor shaft.\n3.4. Gear Relations # To check the performance of the gears and investigate the presence of potential external interferences, it\u0026rsquo;s necessary to perform calculations based on their contact relations. For the meshing between gears E1-E2, the gear of the motor shaft with the first gear of the counter-shaft is computed as follows:\nApproach length ( \\(l_a\\) ) \\[l_a = \\sqrt{R_{a2}^2 - (R^2 \\cdot \\cos(\\alpha))^2} - R_2 \\cdot \\sin(\\alpha) = 5.0586 \\text{mm} \\] \\[\\Rightarrow l_a = \\sqrt{42^2 - (40 \\cdot \\cos(20^\\circ))^2} - 40 \\cdot \\sin(20^\\circ) = 5.0586 \\text{mm}\\] note\nR2 and Ra2 correspond to the pitch radius and crown radius of the wheel, while R1 and Ra1 correspond to the pitch radius and crown radius of the Pinion. For the meshing between gears E1-E2; Ra2 = (Da2)/2 = 42 and Ra1 = (Da1)/2 = 32. Retraction length ( \\(l_f\\) ) \\[l_f = \\sqrt{R_{a_1}^2 - (R_1 \\cdot \\cos(\\alpha))^2} - R_1 \\cdot \\sin(\\alpha) = 4.8814 \\text{mm}\\] \\[\\Rightarrow l_f = \\sqrt{32^2 - (30 \\cdot \\cos(20^\\circ))^2 - 30 \\cdot \\sin(20^\\circ)} = 4.8814 \\text{mm}\\] Knowing the values of the approach and retraction lengths, the conduction ratio ( \\(\\epsilon\\) ) is given by:\n\\[\\epsilon = \\frac{l}{p \\cdot cos(\\alpha)}= \\frac{l_a \u0026#43; l_f}{p \\cdot \\cos(\\alpha)} = \\frac{5.0586 \u0026#43; 4.8814}{6.283 \\cdot \\cos(20^\\circ)} = 1.6836\\] The value of \\(\\epsilon\\) = 1.6836 \\(\\geq\\) 1.3, thus satisfying this condition. It is also feasible to assess the total slip related to the maximum specific slip:\n\\[g_{s1 \\text{max}} = \\frac{1}{i_{12}} \\times \\frac{D_2 \\cdot \\sin(\\alpha) \u0026#43; 2 l_a}{D_1 \\cdot \\sin(\\alpha) - 2 l_a} - 1 = \\frac{1}{1.3333} \\times \\frac{80 \\cdot \\sin(20^\\circ) \u0026#43; 2(5.0586)}{60 \\cdot \\sin(20^\\circ) - 2(5.0586)} - 1 = 1.7017\\] \\[g_{s2 \\text{max}} = 1 - i \\times \\frac{D_1 \\cdot \\sin(\\alpha) \u0026#43; 2 l_f}{D_2 \\cdot \\sin(\\alpha) - 2 l_f} = 1 - 1.3333 \\times \\frac{60 \\cdot \\sin(20^\\circ) \u0026#43; 2(4.8814)}{80 \\cdot \\sin(20^\\circ) - 2(4.8814)} = -1.2944\\] \\[g_{\\text{total}} = \\left(\\frac{1}{R_1} \u0026#43; \\frac{1}{R_2}\\right) \\frac{l_a^2 \u0026#43; l_f^2}{2 \\cdot \\cos(\\alpha)} = \\left(\\frac{1}{30} \u0026#43; \\frac{1}{40}\\right) \\frac{5.0586^2 \u0026#43; 4.8814^2}{2 \\cdot \\cos(20^\\circ)} = 1.5338\\] For calculating efficiency, it\u0026rsquo;s necessary to evaluate the coefficient of static friction \\(\\mu\\) . To do this, I consulted the table in the engineering toolbox website. Considering the surface condition between the gears in a light mineral oil, we extracted the value of \\(\\mu\\) as 0.23 from the table.\nGiven that the friction factor is determined by f = tan( \\(\\mu\\) ), it is found that f = tan(0.23) = 0.234.\n\\[\\eta = 1 - \\frac{f}{\\cos(\\alpha)} \\left(\\frac{1}{D_1} \u0026#43; \\frac{1}{D_2}\\right) \\frac{l_a^2 \u0026#43; l_f^2}{l_a \u0026#43; l_f} = 1 - \\frac{0.1614}{\\cos(20^\\circ)} \\left(\\frac{1}{60} \u0026#43; \\frac{1}{80}\\right) \\frac{5.0586^2 \u0026#43; 4.8814^2}{5.0586 \u0026#43; 4.8814} \\, \\\\ \\eta = 91.69\\%\\] warning\nEfficiency is always a critical factor in cost reduction during operation. Using this formula, it becomes evident that it\u0026rsquo;s not highly precise and heavily relies on the coefficient of static friction. For a more accurate result closer to reality, conducting some experimental tests would be necessary. However, it remains useful for estimating the influence of various variables on overall efficiency. To prevent the existence of primary external interferences, the minimum number of teeth on the pinion is calculated:\n\\[Z_{1 \\text{min}} \\geq -Z_2 \u0026#43; \\sqrt{Z_2^2 \u0026#43; \\frac{4 \\cdot (1 \u0026#43; Z_2)}{\\sin^2(\\alpha)}} = -40 \u0026#43; \\sqrt{40^2 \u0026#43; \\frac{4 \\cdot (1\u0026#43;40)}{sin^2(20^\\circ)}} = 14.789 \\approx 15 \\text{ teeth}\\] Since in this first gearing E1-E2, Z1 = 30 teeth, the condition is verified, and there\u0026rsquo;s no risk of primary external interferences. Similarly, the formulas can be applied to all gearings. A MATLAB code was developed to systematize these calculations.\nE1-E2 E3-E8 E4-E9 E5-E6 E7-E10 Z1 30 20 25 20 20 Z2 40 50 45 20 50 i 1.3333 2.5 1.8 1 2.5 R1 (mm) 30 20 25 20 20 Ra1 (mm) 32 22 27 22 22 R2 (mm) 40 50 45 20 50 Ra2 (mm) 42 52 47 22 52 la (mm) 5.059 5.180 5.125 4.596 5.180 lf (mm) 4.881 4.596 4.758 4.596 4.596 ε 1.6836 1.6558 1.6738 1.5569 1.6558 gs1max 1.7017 4.3677 2.3267 4.0955 4.3677 gs2max -1.2944 -1.2864 -1.2529 -4.0955 -1.2864 gtotal 1.5338 1.7862 1.6189 2.2479 1.7862 η (%) 91.69 90.16 91.17 86.82 90.16 Z1min 14.789 15.145 14.983 13.438 15.145 All \\(\\mu\\) values satisfy the condition of being \\(\\geq\\) 1.3. Furthermore, in all gearings, Z1 is greater than \\(\\Z_{1min}\\) , ensuring the absence of interferences.\n3.5. Nominal Load # To comply with safety standards, a safety factor was defined using the Pugsley method.\nIt was considered that material quality, repair, and inspection were not prioritized in this case. However, controlling the applied load and information regarding tests with similar parts was deemed important. The economic impact is also crucial, as one of the objectives is to minimize costs.\n\\[n_s = n_{sx} n_{sy} = 2.05 \\cdot 1 = 2.05\\] With a safety factor of 2.05 obtained, in addition to using the values from Shigley\u0026rsquo;s Mechanical Design book, the mechanical properties of the chosen material AISI 1040 QT at 650ºC can be extracted:\n\\[n_s = \\frac{\\sigma_y}{\\sigma_{max}} \\Rightarrow \\sigma_{max} = \\frac{434}{2} = 217 MPa\\] 4 You Spin Me Right Round # The designed system met the initially set requirements. It\u0026rsquo;s worth noting that all gearbox elements need to stop rotating before changing gears since it lacks synchronizers. It was opted for a gearbox without synchronizers to avoid complexity and considering its application. A potential use for such a gearbox, albeit larger and with more speeds, could be in a machine tool like a lathe. These machines can operate without changing the transmission ratio while running. If this type of gearbox were used, it might be in a low-cost machine tool, hence why cost was a priority in this project. An improvement to the system could involve adding synchronizers. This would allow the machine operator to change speeds without having to stop the machine.\n5 Task for Later # Future work or potential improvements could include exploring:\nexample\nAdditive Manufacturing: Investigating the feasibility of using additive manufacturing techniques to build components with enhanced precision or novel designs, potentially reducing manufacturing complexities.\nSynchronizer Integration: Developing and integrating synchronizers into the gearbox system to enable gear shifting without stopping the machine, enhancing its operational efficiency and convenience.\nMaterial Selection and Enhancement: Exploring other material options or enhancements that could improve the gearbox\u0026rsquo;s performance, such as materials with higher heat resistance or increased durability.\nEfficiency Optimization: Conducting studies to optimize the gearbox\u0026rsquo;s efficiency without compromising its functionality, potentially through design modifications or lubrication improvements.\nSneak Peak of MATLAB # "},{"id":16,"href":"/docs/2code/1drone/_index5/","title":"Drone Computer Vision","section":"UAV Red Bull Air Racing","content":" Phase 4. UAV Computer Vision # tip\nIf you wish to skip the theoretical and implementation details, please click here to jump to the summarized findings Ch. 3 - Pixel Pilots Certification Acquired. I have cool images! ✌️ 1 Computer Vision for Obstacle Detection # In preparation for the Red Bull drone race, a comprehensive dataset was compiled, consisting of images capturing gates from diverse angles, distances, and lighting conditions. These images showcase the gates amidst various backgrounds, providing a range of scenarios that drones might encounter during the race. The intention behind gathering such a varied dataset is to enable the development of an algorithm capable of accurately identifying these gates despite changes in perspective, distance, lighting, and background colors, facilitating precise navigation for the drones during the high-paced race.\n2 Gate Characterization # The analysis of the images reveals that the gates used for detection exhibit a shallow square shape, predominantly appearing in shades of blue along their sides and darker tones overall. Each gate features white letters and small squares within them, affixed to a metal structure supported by two ground-based supports. While the gates primarily share a base color, variations in lighting conditions result in perceptible differences. For instance, exposure to red light causes the white small squares to take on a red hue, as follows:\n2.1. Colorspace Region Segmentation # The initial phase involves image segmentation, commencing with a test set of images showcase below. These specific images were chosen due to their similarity in appearance, presenting a frontal view to the camera with minimal distortion and consistent colors unaffected by varying lighting conditions. This selection aims to establish a baseline for segmentation, allowing for a focused and controlled analysis of gate recognition and isolation within these images.\nThe strategy involved an examination of different color spaces to identify potential relationships between them. It was done by observing the RGB color space aiming to discern any possible connections or patterns among the color channels within the images.\nIn the image, it is seen the original RGB components as they are, without any changes. It\u0026rsquo;s hard to spot the gate distinctly from the background in any of these components. None of them make the gate stand out separately. So, it looks like using these RGB components isn\u0026rsquo;t the best for separating the gate from the rest. Next up was trying out the HSV color representation.\nIn the HSV representation, an adjustment was made to the original images specifically for the Hue component. The process involved converting the image to the HSV color space, modifying its Saturation and Value components to a saturation of 1, and then re-converting the image back to the RGB color space. This resulted in a representation highlighting the genuine colors of the image, with only the Hue component \u0026ldquo;enabled\u0026rdquo;.\nWhen the image is observed, the gate is distinctly noticeable from the background in the Hue component. The dark and blue tones from the original picture are reflected as dark blue in the Hue representation, while the small white squares take on a magenta hue. The background spans a range from light blue to green and red in this representation. While the Saturation and Value components alone do not facilitate gate identification.\nThe Lab and YCbCr representations didn\u0026rsquo;t yield satisfactory results as the distinction between the background and the gate was hardly noticeable. Consequently, the HSV color space emerged as the most effective choice for segmenting the gate in the images.\nTo execute the segmentation, the images from the test dataset were examined in their HSV representations. Through visual inspection and some trial and error, specific conditions (thresholds) for the HSV values were established to pinpoint the gate\u0026rsquo;s location.\nThis process generated a black and white image where all the points meeting the conditions were highlighted. However, restricting the HSV values alone proved insufficient. Some parts of the background shared similar HSV values with the gate, leading to noise in the resulting images.\n2.2. Black and White Segmentation # Applying thresholds to the HSV values, a first approximation of the gate can be found.\nTo refine the image, several morphological operations need to be applied. In exploring various techniques, one solution considered was to initiate the noise reduction process by cropping the initial image. Utilizing a cropping function facilitated the selection of a specific region of interest (ROI). An illustration of this method is depicted in the subsequent figure.\nWhile the outcomes appeared acceptable for the selected images in the testing set where the gate was in proximity to the camera, this method was ultimately dismissed. Its limitation became apparent with images where the gate was situated farther away, rendering the approach less effective. Moreover, in real-life scenarios involving drones that sway considerably from side to side, cropping the image and narrowing the field of vision was deemed risky. This approach could potentially result in the drone losing track of the gate entirely, which is an undesirable outcome.\n2.3. Morphological Operations # To isolate the gate and eliminate unwanted noise, a shift in approach was necessary, focusing on morphological operations. For the test image set, various scenarios were taken into account based on the image conditions. In the general case, the following morphological operations were applied:\n1. Small dilation operation: Utilizing the MATLAB function \u0026lsquo;imdilate\u0026rsquo;, this operation aimed to connect isolated pixels located at the corners of the gate with the rest of the gate. The \u0026lsquo;cube\u0026rsquo; structure with a magnitude of 2 was employed for this purpose. 2. Retaining the largest area: This step involved employing the MATLAB function \u0026lsquo;bwareafilt\u0026rsquo; to retain solely the gate in the black and white image. Initially, all connected components within a specified range were extracted, followed by preserving solely the largest area. This process became necessary due to potential noise accumulation and formation of objects in the image caused by the dilation process in certain cases. 3. Closing small holes: The MATLAB function \u0026lsquo;imclose\u0026rsquo; function was employed to close only the small holes that form part of the gate shape. This operation aimed to fill these small gaps within the gate structure. A closing operation with a magnitude of 80 was applied using the \u0026lsquo;cube\u0026rsquo; structure to ensure closure when the gate shape wasn\u0026rsquo;t entirely closed (e.g., when the rectangle wasn\u0026rsquo;t fully closed). It\u0026rsquo;s worth noting that the MATLAB function \u0026lsquo;imfill\u0026rsquo; function was avoided to prevent inadvertently filling the actual opening of the gate where drones navigate through. 4. Smoothing the region: To further refine the image and eliminate residual noise, an MATLAB function \u0026lsquo;imopen\u0026rsquo; operation was executed using the \u0026lsquo;cube\u0026rsquo; structure with a magnitude of 20. This process aids in cleaning up any remaining artifacts or noise in the image. Notably, employing a higher magnitude might risk reopening the gate\u0026rsquo;s rectangular structure itself, hence the careful choice of parameters for this operation. 5. Reapplying the mask derived from the obtained black and white image: This was achieved by performing a boolean logic multiplication between the black and white image (acting as a mask) and the original image. The result was a segmented image where the gate was isolated and distinctly visible. Another method explored was the superpixels technique which involves segmenting the image. It is a relatively state-of-the-art technique that often couples numerous superpixels with clustering to enhance image recognition. There are recent papers being published, but a particularly interesting one can be seen here.. The divided image contain many superpixels and each superpixel is then represented by the average color value within its region. The intention behind this approach was to implement the superpixels segmentation preceding the HSV segmentation and assess whether this sequential method could yield improved results. The goal was to evaluate if the combination of superpixels segmentation followed by HSV segmentation could enhance the accuracy of isolating the gate in the images.\nThis method helps reducing the number of different colors in the image which could help the segmentation process in some cases.\nThis method was found to be functional but lacked reliability for consistent segmentation. A lower count of superpixels resulted in poorer outcomes, while a higher count led to slower segmentation without notable improvement. Moreover, in some instances, an increased count made segmentation more challenging as the gate and background merged together.\nThe segmentation algorithm underwent testing on various images. It worked well for images with similar background colors and lighting conditions, often necessitating minor adjustments to the thresholds for optimization. However, for other images, a new set of thresholds had to be determined.\nTo facilitate threshold selection, two new parameters were introduced to group images with similar colors. One parameter, denoted as \u0026lsquo;c\u0026rsquo;, signifies the center of mass of the histogram obtained using the MATLAB \u0026lsquo;imhist\u0026rsquo; function. This parameter helped isolate images with pink or red backgrounds, requiring unique thresholds due to their distinct characteristics. Additionally, two images featuring a large red and black banner in the background were also isolated as they demanded slight threshold adjustments.\nThe second parameter was established to represent the x-coordinate with the maximum value in the histogram obtained from MATLAB \u0026lsquo;imhist\u0026rsquo; function. This parameter primarily aided in segregating an image with a blue background. While this image had a \u0026lsquo;c\u0026rsquo; parameter similar to others in the testing set, it necessitated different thresholds owing to the blending of the blue background with the gate\u0026rsquo;s blue.\nImages with distinct thresholds also required minor modifications to the order of morphological operations.\nSegmented\n2.4. Edge Detection # The next phase involved edge detection to outline the gate\u0026rsquo;s boundaries using various methods of the MATLAB function \u0026rsquo;edge\u0026rsquo;. The previously obtained segmented image was utilized due to its superior performance in noise removal and clear delineation of the gate.\nThree distinct methods were employed:\nCanny Method: This technique identifies edges by seeking local maximums of the gradient of the image. The gradient is derived from a Gaussian filter. It uses two thresholds—one for strong edges and another for weak edges. Weak edges are included in the output only if they are connected to strong edges. Sobel Operator: This method convolves the image with a small, separable, and integer-valued filter along the horizontal and vertical directions. While computationally inexpensive, its gradient approximation can be relatively coarse, especially for high-frequency variations in the image. Laplacian Filters: These filters are derivative-based and designed to detect areas of rapid change (edges) in images. As derivative filters are sensitive to noise, it\u0026rsquo;s common practice to smooth the image (e.g., using a Gaussian filter) before applying the Laplacian. This combined process is known as the Laplacian of Gaussian (LoG) operation: \\[L(x, y) = \\nabla^2 f(x, y) = \\frac{\\partial^2 f(x, y)}{\\partial x^2} \u0026#43; \\frac{\\partial^2 f(x, y)}{\\partial y^2}\\] The representation of the 2D LoG (Laplacian of Gaussian) function centered on zero and with a Gaussian standard deviation \\(\\sigma\\) is given by:\n\\[\\text{LoG}(x, y) = -\\frac{1}{\\pi \\sigma^4} \\left(1 - \\frac{x^2 \u0026#43; y^2}{2\\sigma^2}\\right) e^{-\\frac{x^2 \u0026#43; y^2}{2\\sigma^2}}\\] Edge detection was carried out on two types of images: the BW mask acquired during the segmentation process and the segmented images. Conducting edge detection on the original images was dismissed due to the excessive background information it would provide.\nWhen performing edge detection on the BW mask, the expected outcome was solely the contours of the mask, encompassing both inner and outer rectangles. Conversely, edge detection on the segmented image aimed to extract additional features such as letters and squares, with the option to adjust the number of extracted features using a threshold.\nThe results displayed two images: edge detection on the BW mask was shown on the left, while edge detection on the segmented image was depicted on the right. The superiority of the Canny method\u0026rsquo;s results was attributed mainly to the adjustability of its two thresholds.\n2.5. Hough Transform # The Hough Transform involves identifying lines within an image by grouping edge points into object candidates, which undergo a voting procedure. This process occurs in a parameter space where the object candidates are considered local maxima. Each point in the Hough Space is represented by two parameters, Rho ( \\(\\rho\\) ) and Theta ( \\(\\theta\\) ). Rho represents the perpendicular distance from the origin to the line, while theta denotes the angle between the x-axis and this vector.\nThe MATLAB implementation comprises a series of functions. The MATLAB function \u0026lsquo;hough\u0026rsquo; computes the Standard Hough Transform (SHT) of a binary image, producing outputs of rho, theta, and H, a matrix representing the parameter space. Subsequently, the MATLAB function \u0026lsquo;houghpeaks\u0026rsquo; locates peaks in the Hough Transform Matrix, typically selecting 20 peaks. Finally, the MATLAB function \u0026lsquo;houghlines\u0026rsquo; function identifies line segments within the image, returning a structure array that represents the merged line segments.\nHough lines serve as an alternative method for line detection. In this case, the Hough lines were applied to the BW mask generated from the Canny edges, as the Canny method displayed the most promising results. This application aimed to enhance the lines extracted from the edges, particularly emphasizing the extremes of the gate. The results are depicted below.\n2.6. Extreme Points and Centroid # The function \u0026lsquo;CornerDetec\u0026rsquo; was created to calculate the extreme points of the gate image post edge detection. As the gate consistently maintains a square shape, the extreme points can be defined by a sequence of maximum and minimum x and y coordinates. For instance, the top-right corner would be the point where the sum of the x and y coordinates is maximized.\nDetermining the centroid involved using the MATLAB function \u0026lsquo;regionprops\u0026rsquo;. Given the gate\u0026rsquo;s square and axisymmetric shape, the centroid could be extracted using either the inner or outer square of the gate.\nDespite prior morphological operations aimed at refining the segmentation quality, residual noise persisted within the images. To reduce the error between the actual centroid and the estimated centroid, the inner square of the gate, less susceptible to edge detection errors, was utilized. In cases where the inner square wasn\u0026rsquo;t entirely identified, the centroid of the outer square was plotted instead.\nResults: Identification of centroid on a different image - (click to expand) Results: Identification of centroid on all images - (click to expand) Results: Identification of hough lines on all images - (click to expand) 2.7. Image Enhancement # To accentuate the gate within the image, the region corresponding to the gate was emphasized. This was achieved by inverting the mask obtained from the segmentation process. Inverting the mask allowed for the removal of the gate from the original image and isolating it for highlighting purposes. To accomplish this, each color channel of the inverted mask was isolated and subsequently combined to create a true color RGB image. Additionally, the lines detected from the extreme points were plotted on this highlighted gate region to further outline its boundaries.\nThe conversion from RGB to HSV can be applied to this image. It\u0026rsquo;s important to note that the green lines visible in the figure are not inherent to the image; they are plotted lines and, consequently, do not manifest in the HSV representation.\nUpon observing the HSV components, it becomes apparent that the gate is distinctly highlighted in the Saturation and Value images. For all the image datasets:\n3 Pixel Pilots Certification Acquired # It became evident that arriving at a solution wasn\u0026rsquo;t straightforward, and while the obtained solution wasn\u0026rsquo;t perfect, it showcased potential for optimization with an expanded dataset. Additional images would enhance the algorithm\u0026rsquo;s ability to recognize the gate under various lighting conditions and backgrounds. Nonetheless, color segmentation emerged as an effective means to segment the gate.\nAmong edge detection methods, the Canny approach stood out as the most effective, although other methods also demonstrated reasonable performance. The Hough transform offered an alternative method to identify lines, proving to be a decent performer.\nDespite minor imperfections resulting from imperfect segmentation, the detection of extreme points and centroids was generally successful.\nUltimately, in this section the work done successfully achieved its goal by effectively isolating and enhancing the gate. Employing various solutions contributed to solving the challenge of gate identification for drone competitions.\nexample\nAs for next steps\u0026hellip;Possibly in a phase 5. It could involve exploring the integration of machine learning techniques to further enhance the gate identification process, potentially leading to real-time detection capabilities. Machine learning models, such as convolutional neural networks (CNNs) or other deep learning architectures, could be trained on an expanded dataset to improve gate recognition across diverse conditions. This adaptation could pave the way for more robust and efficient gate identification systems, especially in real-time scenarios during drone competitions. "},{"id":17,"href":"/docs/2code/5od/","title":"Evolutionary Computation","section":"Coding Portfolio","content":" Introduction # "},{"id":18,"href":"/docs/1design/6ebw/","title":"Electron Beam Technology","section":"Design Portfolio","content":" Thermally Induced Reduction of the Load # "},{"id":19,"href":"/docs/2code/7rm/","title":"Manipulator Robotics: JACO","section":"Coding Portfolio","content":" Introduction # "},{"id":20,"href":"/docs/2code/8au/","title":"Industrial Automation","section":"Coding Portfolio","content":" Introduction # "},{"id":21,"href":"/docs/mod/modifications/","title":"Website Modifications","section":"Docs","content":" Based on UX/UI / bookHidden: true # Hugo Framework # info\nThe wiki is built locally using the Hugo framework. You can run a local environment by following these steps:\nInstall the Hugo Framework Clone this repo Run hugo server --minify in the root directory Open your browser and go to http://localhost:1313 (or as indicated by the Hugo output) Hugo Book Theme Modifications # I\u0026rsquo;ve customized Hugo Book theme template by modifying default settings to offer users more detailed information. I expanded the default three hint options to include three additional key options, alongside color correction. You can still utilize hint shortcode normally.\nREAD_ME - Shortcodes # Book theme dev page This can be customize in this section of the hugo-book/layout/shortcodes/hint-html. tip\nModifications in the _shortcodes.scss file .book-hint { @each $name, $color in $hint-colors { \u0026amp;.#{$name} { border-color: $color; background-color: rgba($color, 0.1); } } } .hint-title { @each $name, $color in $hint-colors { \u0026amp;.#{$name} { color: white; border-color: $color; background-color: $color; border-radius: $border-radius $border-radius 0 0; font-weight: 700; text-transform: capitalize; padding: $padding-4 $padding-16; margin: (-$padding-8) (-$padding-16) $padding-8 (-$padding-16 + $padding-4); } } } .hint-title svg { height: 1em; width: 1em; vertical-align: middle; margin-inline-end: $padding-8; fill: currentColor; } .hint-title span { vertical-align: middle; } tip\nModifications _defaults.css $hint-colors: ( info: #608ADC, note: #608ADC, important: #FFD06B, warning: #FF8EAA, danger: #FF8EAA, tip: #00AD93, example: #A887DE ) !default; @mixin theme-light { --gray-100: #f8f9fa; --gray-200: #e9ecef; --gray-500: #adb5bd; --color-link: #0055bb; --color-visited-link: #8440f1; --body-background: white; --body-font-color: black; --icon-filter: none; --hint-color-info: #608ADC; --hint-color-important: #FFD06B; --hint-color-warning: #FF8EAA; --hint-color-tip: #00AD93; --hint-color-note: #608ADC; --hint-color-example: #A887DE; } tip\nLastly, adaption of the manifest.json file accordingly, as well as addition of new icons in .svg format. This way personalized icons can be added to the shortcodes. { \u0026#34;name\u0026#34;: \u0026#34;{{ .Site.Title }}\u0026#34;, \u0026#34;short_name\u0026#34;: \u0026#34;{{ .Site.Title }}\u0026#34;, \u0026#34;start_url\u0026#34;: \u0026#34;{{ \u0026#34;/\u0026#34; | relURL }}\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;{{ \u0026#34;/\u0026#34; | relURL }}\u0026#34;, \u0026#34;display\u0026#34;: \u0026#34;standalone\u0026#34;, \u0026#34;background_color\u0026#34;: \u0026#34;#000000\u0026#34;, \u0026#34;theme_color\u0026#34;: \u0026#34;#000000\u0026#34;, \u0026#34;icons\u0026#34;: [ { \u0026#34;src\u0026#34;: \u0026#34;{{ \u0026#34;/favicon.svg\u0026#34; | relURL }}\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34; } ] } danger\nModifications in the relative path to the hint-icons.svg must be changed - in case addition of new icons. Otherwise failed to deploy \u0026amp; build new pages. {{- $noticeType := .Get 0 -}} {{- $replaced := .Get 0 -}} {{- $type := .Get 1 -}} {{ if ne $type \u0026#34;noTitle\u0026#34; }} \u0026lt;blockquote class=\u0026#34;book-hint2 {{ $noticeType }}\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;hint-title {{ $noticeType }}\u0026#34;\u0026gt; \u0026lt;svg class=\u0026#34;book-icon\u0026#34;\u0026gt; \u0026lt;use href=\u0026#34;/svg/hint-icons.svg#{{- $replaced -}}-notice\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; \u0026lt;/svg\u0026gt;\u0026lt;span\u0026gt;{{ $replaced }}\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; {{ .Inner | markdownify }} \u0026lt;/blockquote\u0026gt; {{ else }} \u0026lt;blockquote class=\u0026#34;book-hint {{ .Get 0 }}\u0026#34;\u0026gt; {{ .Inner | markdownify }} \u0026lt;/blockquote\u0026gt; {{ end }} Modification # info\ndark-theme modified color gradient for hint shortcodes changed google analytics connection Last source modification November 25, 2023 by Ricardo Chin Developer # Created by Ricardo Chin Contributors # Manuel Sousa - Fixed the shortcode hint icons display; "}]